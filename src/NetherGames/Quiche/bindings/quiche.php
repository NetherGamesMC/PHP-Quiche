<?php declare(strict_types=1);
namespace NetherGames\Quiche\bindings;
use FFI;
use NetherGames\Quiche\bindings\double;
interface iQuiche {}
interface iQuiche_ptr {}
/**
 * @property string_ptr $tzname
 * @property int $getdate_err
 * @property int $timezone
 * @property int $daylight
 * @property struct_in6_addr $in6addr_any
 * @property struct_in6_addr $in6addr_loopback
 * @property struct_in6_addr $in6addr_nodelocal_allnodes
 * @property struct_in6_addr $in6addr_linklocal_allnodes
 * @property struct_in6_addr $in6addr_linklocal_allrouters
 * @property struct_in6_addr $in6addr_linklocal_allv2routers
 */
class Quiche {
    const __x86_64__ = 1;
    const __LP64__ = 1;
    const __GNUC_VA_LIST = 1;
    const __GNUC__ = 4;
    const __GNUC_MINOR__ = 2;
    const __STDC__ = 1;
    const __WORDSIZE = 64;
    const __DARWIN_ONLY_64_BIT_INO_T = 0;
    const __DARWIN_ONLY_UNIX_CONFORMANCE = 1;
    const __DARWIN_ONLY_VERS_1050 = 0;
    const __DARWIN_UNIX03 = 1;
    const __DARWIN_64_BIT_INO_T = 1;
    const __DARWIN_VERS_1050 = 1;
    const __DARWIN_NON_CANCELABLE = 0;
    const __DARWIN_C_ANSI = 010000;
    const __DARWIN_C_FULL = 900000;
    const __STDC_WANT_LIB_EXT1__ = 1;
    const __DARWIN_NO_LONG_LONG = 0;
    const _DARWIN_FEATURE_64_BIT_INODE = 1;
    const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;
    const _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;
    const __has_ptrcheck = 0;
    const __PTHREAD_SIZE__ = 8176;
    const __PTHREAD_ATTR_SIZE__ = 56;
    const __PTHREAD_MUTEXATTR_SIZE__ = 8;
    const __PTHREAD_MUTEX_SIZE__ = 56;
    const __PTHREAD_CONDATTR_SIZE__ = 8;
    const __PTHREAD_COND_SIZE__ = 40;
    const __PTHREAD_ONCE_SIZE__ = 8;
    const __PTHREAD_RWLOCK_SIZE__ = 192;
    const __PTHREAD_RWLOCKATTR_SIZE__ = 16;
    const INT8_MAX = 127;
    const INT16_MAX = 32767;
    const INT32_MAX = 2147483647;
    const INT64_MAX = 9223372036854775807;
    const UINT8_MAX = 255;
    const UINT16_MAX = 65535;
    const UINT32_MAX = 4294967295;
    const UINT64_MAX = 18446744073709551615;
    const INTPTR_MAX = 9223372036854775807;
    const UINTPTR_MAX = 18446744073709551615;
    const WCHAR_MAX = 0x7fffffff;
    const __bool_true_false_are_defined = 1;
    const false = 0;
    const true = 1;
    const __DARWIN_WCHAR_MAX = 0x7fffffff;
    const _FORTIFY_SOURCE = 2;
    const _QUAD_HIGHWORD = 1;
    const _QUAD_LOWWORD = 0;
    const __DARWIN_LITTLE_ENDIAN = 1234;
    const __DARWIN_BIG_ENDIAN = 4321;
    const __DARWIN_PDP_ENDIAN = 3412;
    const __API_TO_BE_DEPRECATED = 100000;
    const __API_TO_BE_DEPRECATED_MACOS = 100000;
    const __API_TO_BE_DEPRECATED_IOS = 100000;
    const __API_TO_BE_DEPRECATED_MACCATALYST = 100000;
    const __API_TO_BE_DEPRECATED_WATCHOS = 100000;
    const __API_TO_BE_DEPRECATED_TVOS = 100000;
    const __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;
    const __API_TO_BE_DEPRECATED_VISIONOS = 100000;
    const __MAC_10_0 = 1000;
    const __MAC_10_1 = 1010;
    const __MAC_10_2 = 1020;
    const __MAC_10_3 = 1030;
    const __MAC_10_4 = 1040;
    const __MAC_10_5 = 1050;
    const __MAC_10_6 = 1060;
    const __MAC_10_7 = 1070;
    const __MAC_10_8 = 1080;
    const __MAC_10_9 = 1090;
    const __MAC_10_10 = 101000;
    const __MAC_10_10_2 = 101002;
    const __MAC_10_10_3 = 101003;
    const __MAC_10_11 = 101100;
    const __MAC_10_11_2 = 101102;
    const __MAC_10_11_3 = 101103;
    const __MAC_10_11_4 = 101104;
    const __MAC_10_12 = 101200;
    const __MAC_10_12_1 = 101201;
    const __MAC_10_12_2 = 101202;
    const __MAC_10_12_4 = 101204;
    const __MAC_10_13 = 101300;
    const __MAC_10_13_1 = 101301;
    const __MAC_10_13_2 = 101302;
    const __MAC_10_13_4 = 101304;
    const __MAC_10_14 = 101400;
    const __MAC_10_14_1 = 101401;
    const __MAC_10_14_4 = 101404;
    const __MAC_10_14_5 = 101405;
    const __MAC_10_14_6 = 101406;
    const __MAC_10_15 = 101500;
    const __MAC_10_15_1 = 101501;
    const __MAC_10_15_4 = 101504;
    const __MAC_10_16 = 101600;
    const __MAC_11_0 = 110000;
    const __MAC_11_1 = 110100;
    const __MAC_11_3 = 110300;
    const __MAC_11_4 = 110400;
    const __MAC_11_5 = 110500;
    const __MAC_11_6 = 110600;
    const __MAC_12_0 = 120000;
    const __MAC_12_1 = 120100;
    const __MAC_12_2 = 120200;
    const __MAC_12_3 = 120300;
    const __MAC_12_4 = 120400;
    const __MAC_12_5 = 120500;
    const __MAC_12_6 = 120600;
    const __MAC_12_7 = 120700;
    const __MAC_13_0 = 130000;
    const __MAC_13_1 = 130100;
    const __MAC_13_2 = 130200;
    const __MAC_13_3 = 130300;
    const __MAC_13_4 = 130400;
    const __MAC_13_5 = 130500;
    const __MAC_13_6 = 130600;
    const __MAC_14_0 = 140000;
    const __MAC_14_1 = 140100;
    const __MAC_14_2 = 140200;
    const __IPHONE_2_0 = 20000;
    const __IPHONE_2_1 = 20100;
    const __IPHONE_2_2 = 20200;
    const __IPHONE_3_0 = 30000;
    const __IPHONE_3_1 = 30100;
    const __IPHONE_3_2 = 30200;
    const __IPHONE_4_0 = 40000;
    const __IPHONE_4_1 = 40100;
    const __IPHONE_4_2 = 40200;
    const __IPHONE_4_3 = 40300;
    const __IPHONE_5_0 = 50000;
    const __IPHONE_5_1 = 50100;
    const __IPHONE_6_0 = 60000;
    const __IPHONE_6_1 = 60100;
    const __IPHONE_7_0 = 70000;
    const __IPHONE_7_1 = 70100;
    const __IPHONE_8_0 = 80000;
    const __IPHONE_8_1 = 80100;
    const __IPHONE_8_2 = 80200;
    const __IPHONE_8_3 = 80300;
    const __IPHONE_8_4 = 80400;
    const __IPHONE_9_0 = 90000;
    const __IPHONE_9_1 = 90100;
    const __IPHONE_9_2 = 90200;
    const __IPHONE_9_3 = 90300;
    const __IPHONE_10_0 = 100000;
    const __IPHONE_10_1 = 100100;
    const __IPHONE_10_2 = 100200;
    const __IPHONE_10_3 = 100300;
    const __IPHONE_11_0 = 110000;
    const __IPHONE_11_1 = 110100;
    const __IPHONE_11_2 = 110200;
    const __IPHONE_11_3 = 110300;
    const __IPHONE_11_4 = 110400;
    const __IPHONE_12_0 = 120000;
    const __IPHONE_12_1 = 120100;
    const __IPHONE_12_2 = 120200;
    const __IPHONE_12_3 = 120300;
    const __IPHONE_12_4 = 120400;
    const __IPHONE_13_0 = 130000;
    const __IPHONE_13_1 = 130100;
    const __IPHONE_13_2 = 130200;
    const __IPHONE_13_3 = 130300;
    const __IPHONE_13_4 = 130400;
    const __IPHONE_13_5 = 130500;
    const __IPHONE_13_6 = 130600;
    const __IPHONE_13_7 = 130700;
    const __IPHONE_14_0 = 140000;
    const __IPHONE_14_1 = 140100;
    const __IPHONE_14_2 = 140200;
    const __IPHONE_14_3 = 140300;
    const __IPHONE_14_5 = 140500;
    const __IPHONE_14_4 = 140400;
    const __IPHONE_14_6 = 140600;
    const __IPHONE_14_7 = 140700;
    const __IPHONE_14_8 = 140800;
    const __IPHONE_15_0 = 150000;
    const __IPHONE_15_1 = 150100;
    const __IPHONE_15_2 = 150200;
    const __IPHONE_15_3 = 150300;
    const __IPHONE_15_4 = 150400;
    const __IPHONE_15_5 = 150500;
    const __IPHONE_15_6 = 150600;
    const __IPHONE_16_0 = 160000;
    const __IPHONE_16_1 = 160100;
    const __IPHONE_16_2 = 160200;
    const __IPHONE_16_3 = 160300;
    const __IPHONE_16_4 = 160400;
    const __IPHONE_16_5 = 160500;
    const __IPHONE_16_6 = 160600;
    const __IPHONE_16_7 = 160700;
    const __IPHONE_17_0 = 170000;
    const __IPHONE_17_1 = 170100;
    const __IPHONE_17_2 = 170200;
    const __WATCHOS_1_0 = 10000;
    const __WATCHOS_2_0 = 20000;
    const __WATCHOS_2_1 = 20100;
    const __WATCHOS_2_2 = 20200;
    const __WATCHOS_3_0 = 30000;
    const __WATCHOS_3_1 = 30100;
    const __WATCHOS_3_1_1 = 30101;
    const __WATCHOS_3_2 = 30200;
    const __WATCHOS_4_0 = 40000;
    const __WATCHOS_4_1 = 40100;
    const __WATCHOS_4_2 = 40200;
    const __WATCHOS_4_3 = 40300;
    const __WATCHOS_5_0 = 50000;
    const __WATCHOS_5_1 = 50100;
    const __WATCHOS_5_2 = 50200;
    const __WATCHOS_5_3 = 50300;
    const __WATCHOS_6_0 = 60000;
    const __WATCHOS_6_1 = 60100;
    const __WATCHOS_6_2 = 60200;
    const __WATCHOS_7_0 = 70000;
    const __WATCHOS_7_1 = 70100;
    const __WATCHOS_7_2 = 70200;
    const __WATCHOS_7_3 = 70300;
    const __WATCHOS_7_4 = 70400;
    const __WATCHOS_7_5 = 70500;
    const __WATCHOS_7_6 = 70600;
    const __WATCHOS_8_0 = 80000;
    const __WATCHOS_8_1 = 80100;
    const __WATCHOS_8_3 = 80300;
    const __WATCHOS_8_4 = 80400;
    const __WATCHOS_8_5 = 80500;
    const __WATCHOS_8_6 = 80600;
    const __WATCHOS_8_7 = 80700;
    const __WATCHOS_9_0 = 90000;
    const __WATCHOS_9_1 = 90100;
    const __WATCHOS_9_2 = 90200;
    const __WATCHOS_9_3 = 90300;
    const __WATCHOS_9_4 = 90400;
    const __WATCHOS_9_5 = 90500;
    const __WATCHOS_9_6 = 90600;
    const __WATCHOS_10_0 = 100000;
    const __WATCHOS_10_1 = 100100;
    const __WATCHOS_10_2 = 100200;
    const __TVOS_9_0 = 90000;
    const __TVOS_9_1 = 90100;
    const __TVOS_9_2 = 90200;
    const __TVOS_10_0 = 100000;
    const __TVOS_10_0_1 = 100001;
    const __TVOS_10_1 = 100100;
    const __TVOS_10_2 = 100200;
    const __TVOS_11_0 = 110000;
    const __TVOS_11_1 = 110100;
    const __TVOS_11_2 = 110200;
    const __TVOS_11_3 = 110300;
    const __TVOS_11_4 = 110400;
    const __TVOS_12_0 = 120000;
    const __TVOS_12_1 = 120100;
    const __TVOS_12_2 = 120200;
    const __TVOS_12_3 = 120300;
    const __TVOS_12_4 = 120400;
    const __TVOS_13_0 = 130000;
    const __TVOS_13_2 = 130200;
    const __TVOS_13_3 = 130300;
    const __TVOS_13_4 = 130400;
    const __TVOS_14_0 = 140000;
    const __TVOS_14_1 = 140100;
    const __TVOS_14_2 = 140200;
    const __TVOS_14_3 = 140300;
    const __TVOS_14_5 = 140500;
    const __TVOS_14_6 = 140600;
    const __TVOS_14_7 = 140700;
    const __TVOS_15_0 = 150000;
    const __TVOS_15_1 = 150100;
    const __TVOS_15_2 = 150200;
    const __TVOS_15_3 = 150300;
    const __TVOS_15_4 = 150400;
    const __TVOS_15_5 = 150500;
    const __TVOS_15_6 = 150600;
    const __TVOS_16_0 = 160000;
    const __TVOS_16_1 = 160100;
    const __TVOS_16_2 = 160200;
    const __TVOS_16_3 = 160300;
    const __TVOS_16_4 = 160400;
    const __TVOS_16_5 = 160500;
    const __TVOS_16_6 = 160600;
    const __TVOS_17_0 = 170000;
    const __TVOS_17_1 = 170100;
    const __TVOS_17_2 = 170200;
    const __BRIDGEOS_2_0 = 20000;
    const __BRIDGEOS_3_0 = 30000;
    const __BRIDGEOS_3_1 = 30100;
    const __BRIDGEOS_3_4 = 30400;
    const __BRIDGEOS_4_0 = 40000;
    const __BRIDGEOS_4_1 = 40100;
    const __BRIDGEOS_5_0 = 50000;
    const __BRIDGEOS_5_1 = 50100;
    const __BRIDGEOS_5_3 = 50300;
    const __BRIDGEOS_6_0 = 60000;
    const __BRIDGEOS_6_2 = 60200;
    const __BRIDGEOS_6_4 = 60400;
    const __BRIDGEOS_6_5 = 60500;
    const __BRIDGEOS_6_6 = 60600;
    const __BRIDGEOS_7_0 = 70000;
    const __BRIDGEOS_7_1 = 70100;
    const __BRIDGEOS_7_2 = 70200;
    const __BRIDGEOS_7_3 = 70300;
    const __BRIDGEOS_7_4 = 70400;
    const __BRIDGEOS_7_6 = 70600;
    const __BRIDGEOS_8_0 = 80000;
    const __BRIDGEOS_8_1 = 80100;
    const __BRIDGEOS_8_2 = 80200;
    const __DRIVERKIT_19_0 = 190000;
    const __DRIVERKIT_20_0 = 200000;
    const __DRIVERKIT_21_0 = 210000;
    const __DRIVERKIT_22_0 = 220000;
    const __DRIVERKIT_22_4 = 220400;
    const __DRIVERKIT_22_5 = 220500;
    const __DRIVERKIT_22_6 = 220600;
    const __DRIVERKIT_23_0 = 230000;
    const __DRIVERKIT_23_1 = 230100;
    const __DRIVERKIT_23_2 = 230200;
    const __VISIONOS_1_0 = 10000;
    const __DARWIN_FD_SETSIZE = 1024;
    const __DARWIN_NBBY = 8;
    const KEV_INET_SUBCLASS = 1;
    const KEV_INET_NEW_ADDR = 1;
    const KEV_INET_CHANGED_ADDR = 2;
    const KEV_INET_ADDR_DELETED = 3;
    const KEV_INET_SIFDSTADDR = 4;
    const KEV_INET_SIFBRDADDR = 5;
    const KEV_INET_SIFNETMASK = 6;
    const KEV_INET_ARPCOLLISION = 7;
    const KEV_INET_PORTINUSE = 8;
    const KEV_INET_ARPRTRFAILURE = 9;
    const KEV_INET_ARPRTRALIVE = 10;
    const KEV_DL_SUBCLASS = 2;
    const KEV_DL_SIFFLAGS = 1;
    const KEV_DL_SIFMETRICS = 2;
    const KEV_DL_SIFMTU = 3;
    const KEV_DL_SIFPHYS = 4;
    const KEV_DL_SIFMEDIA = 5;
    const KEV_DL_SIFGENERIC = 6;
    const KEV_DL_ADDMULTI = 7;
    const KEV_DL_DELMULTI = 8;
    const KEV_DL_IF_ATTACHED = 9;
    const KEV_DL_IF_DETACHING = 10;
    const KEV_DL_IF_DETACHED = 11;
    const KEV_DL_LINK_OFF = 12;
    const KEV_DL_LINK_ON = 13;
    const KEV_DL_PROTO_ATTACHED = 14;
    const KEV_DL_PROTO_DETACHED = 15;
    const KEV_DL_LINK_ADDRESS_CHANGED = 16;
    const KEV_DL_WAKEFLAGS_CHANGED = 17;
    const KEV_DL_IF_IDLE_ROUTE_REFCNT = 18;
    const KEV_DL_IFCAP_CHANGED = 19;
    const KEV_DL_LINK_QUALITY_METRIC_CHANGED = 20;
    const KEV_DL_NODE_PRESENCE = 21;
    const KEV_DL_NODE_ABSENCE = 22;
    const KEV_DL_PRIMARY_ELECTED = 23;
    const KEV_DL_ISSUES = 24;
    const KEV_DL_IFDELEGATE_CHANGED = 25;
    const KEV_DL_AWDL_RESTRICTED = 26;
    const KEV_DL_AWDL_UNRESTRICTED = 27;
    const KEV_DL_RRC_STATE_CHANGED = 28;
    const KEV_DL_QOS_MODE_CHANGED = 29;
    const KEV_DL_LOW_POWER_MODE_CHANGED = 30;
    const KEV_INET6_SUBCLASS = 6;
    const KEV_INET6_NEW_USER_ADDR = 1;
    const KEV_INET6_CHANGED_ADDR = 2;
    const KEV_INET6_ADDR_DELETED = 3;
    const KEV_INET6_NEW_LL_ADDR = 4;
    const KEV_INET6_NEW_RTADV_ADDR = 5;
    const KEV_INET6_DEFROUTER = 6;
    const KEV_INET6_REQUEST_NAT64_PREFIX = 7;
    const SOCK_STREAM = 1;
    const SOCK_DGRAM = 2;
    const SOCK_RAW = 3;
    const SOCK_RDM = 4;
    const SOCK_SEQPACKET = 5;
    const SO_DEBUG = 0x0001;
    const SO_ACCEPTCONN = 0x0002;
    const SO_REUSEADDR = 0x0004;
    const SO_KEEPALIVE = 0x0008;
    const SO_DONTROUTE = 0x0010;
    const SO_BROADCAST = 0x0020;
    const SO_USELOOPBACK = 0x0040;
    const SO_LINGER = 0x0080;
    const SO_LINGER_SEC = 0x1080;
    const SO_OOBINLINE = 0x0100;
    const SO_REUSEPORT = 0x0200;
    const SO_TIMESTAMP = 0x0400;
    const SO_TIMESTAMP_MONOTONIC = 0x0800;
    const SO_ACCEPTFILTER = 0x1000;
    const SO_SNDBUF = 0x1001;
    const SO_RCVBUF = 0x1002;
    const SO_SNDLOWAT = 0x1003;
    const SO_RCVLOWAT = 0x1004;
    const SO_SNDTIMEO = 0x1005;
    const SO_RCVTIMEO = 0x1006;
    const SO_ERROR = 0x1007;
    const SO_TYPE = 0x1008;
    const SO_LABEL = 0x1010;
    const SO_PEERLABEL = 0x1011;
    const SO_NUMRCVPKT = 0x1112;
    const SO_NET_SERVICE_TYPE = 0x1116;
    const SO_NETSVC_MARKING_LEVEL = 0x1119;
    const SO_RESOLVER_SIGNATURE = 0x1131;
    const NET_SERVICE_TYPE_BE = 0;
    const NET_SERVICE_TYPE_BK = 1;
    const NET_SERVICE_TYPE_SIG = 2;
    const NET_SERVICE_TYPE_VI = 3;
    const NET_SERVICE_TYPE_VO = 4;
    const NET_SERVICE_TYPE_RV = 5;
    const NET_SERVICE_TYPE_AV = 6;
    const NET_SERVICE_TYPE_OAM = 7;
    const NET_SERVICE_TYPE_RD = 8;
    const NETSVC_MRKNG_UNKNOWN = 0;
    const NETSVC_MRKNG_LVL_L2 = 1;
    const NETSVC_MRKNG_LVL_L3L2_ALL = 2;
    const NETSVC_MRKNG_LVL_L3L2_BK = 3;
    const SAE_ASSOCID_ANY = 0;
    const SAE_CONNID_ANY = 0;
    const CONNECT_RESUME_ON_READ_WRITE = 0x1;
    const CONNECT_DATA_IDEMPOTENT = 0x2;
    const CONNECT_DATA_AUTHENTICATED = 0x4;
    const SOL_SOCKET = 0xffff;
    const AF_UNSPEC = 0;
    const AF_UNIX = 1;
    const AF_INET = 2;
    const AF_IMPLINK = 3;
    const AF_PUP = 4;
    const AF_CHAOS = 5;
    const AF_NS = 6;
    const AF_ISO = 7;
    const AF_ECMA = 8;
    const AF_DATAKIT = 9;
    const AF_CCITT = 10;
    const AF_SNA = 11;
    const AF_DECnet = 12;
    const AF_DLI = 13;
    const AF_LAT = 14;
    const AF_HYLINK = 15;
    const AF_APPLETALK = 16;
    const AF_ROUTE = 17;
    const AF_LINK = 18;
    const pseudo_AF_XTP = 19;
    const AF_COIP = 20;
    const AF_CNT = 21;
    const pseudo_AF_RTIP = 22;
    const AF_IPX = 23;
    const AF_SIP = 24;
    const pseudo_AF_PIP = 25;
    const AF_NDRV = 27;
    const AF_ISDN = 28;
    const pseudo_AF_KEY = 29;
    const AF_INET6 = 30;
    const AF_NATM = 31;
    const AF_SYSTEM = 32;
    const AF_NETBIOS = 33;
    const AF_PPP = 34;
    const pseudo_AF_HDRCMPLT = 35;
    const AF_RESERVED_36 = 36;
    const AF_IEEE80211 = 37;
    const AF_UTUN = 38;
    const AF_VSOCK = 40;
    const AF_MAX = 41;
    const SOCK_MAXADDRLEN = 255;
    const _SS_MAXSIZE = 128;
    const NET_RT_DUMP = 1;
    const NET_RT_FLAGS = 2;
    const NET_RT_IFLIST = 3;
    const NET_RT_STAT = 4;
    const NET_RT_TRASH = 5;
    const NET_RT_IFLIST2 = 6;
    const NET_RT_DUMP2 = 7;
    const NET_RT_FLAGS_PRIV = 10;
    const NET_RT_MAXID = 11;
    const SOMAXCONN = 128;
    const MSG_OOB = 0x1;
    const MSG_PEEK = 0x2;
    const MSG_DONTROUTE = 0x4;
    const MSG_EOR = 0x8;
    const MSG_TRUNC = 0x10;
    const MSG_CTRUNC = 0x20;
    const MSG_WAITALL = 0x40;
    const MSG_DONTWAIT = 0x80;
    const MSG_EOF = 0x100;
    const MSG_NEEDSA = 0x10000;
    const MSG_NOSIGNAL = 0x80000;
    const CMGROUP_MAX = 16;
    const SCM_RIGHTS = 0x01;
    const SCM_TIMESTAMP = 0x02;
    const SCM_CREDS = 0x03;
    const SCM_TIMESTAMP_MONOTONIC = 0x04;
    const SHUT_RD = 0;
    const SHUT_WR = 1;
    const SHUT_RDWR = 2;
    const ITIMER_REAL = 0;
    const ITIMER_VIRTUAL = 1;
    const ITIMER_PROF = 2;
    const DST_NONE = 0;
    const DST_USA = 1;
    const DST_AUST = 2;
    const DST_WET = 3;
    const DST_MET = 4;
    const DST_EET = 5;
    const DST_CAN = 6;
    const TIME_UTC = 1;
    const QUICHE_PROTOCOL_VERSION = 0x00000001;
    const QUICHE_MAX_CONN_ID_LEN = 20;
    const QUICHE_MIN_CLIENT_INITIAL_LEN = 1200;
    const IPPROTO_IP = 0;
    const IPPROTO_HOPOPTS = 0;
    const IPPROTO_ICMP = 1;
    const IPPROTO_IGMP = 2;
    const IPPROTO_GGP = 3;
    const IPPROTO_IPV4 = 4;
    const IPPROTO_TCP = 6;
    const IPPROTO_ST = 7;
    const IPPROTO_EGP = 8;
    const IPPROTO_PIGP = 9;
    const IPPROTO_RCCMON = 10;
    const IPPROTO_NVPII = 11;
    const IPPROTO_PUP = 12;
    const IPPROTO_ARGUS = 13;
    const IPPROTO_EMCON = 14;
    const IPPROTO_XNET = 15;
    const IPPROTO_CHAOS = 16;
    const IPPROTO_UDP = 17;
    const IPPROTO_MUX = 18;
    const IPPROTO_MEAS = 19;
    const IPPROTO_HMP = 20;
    const IPPROTO_PRM = 21;
    const IPPROTO_IDP = 22;
    const IPPROTO_TRUNK1 = 23;
    const IPPROTO_TRUNK2 = 24;
    const IPPROTO_LEAF1 = 25;
    const IPPROTO_LEAF2 = 26;
    const IPPROTO_RDP = 27;
    const IPPROTO_IRTP = 28;
    const IPPROTO_TP = 29;
    const IPPROTO_BLT = 30;
    const IPPROTO_NSP = 31;
    const IPPROTO_INP = 32;
    const IPPROTO_SEP = 33;
    const IPPROTO_3PC = 34;
    const IPPROTO_IDPR = 35;
    const IPPROTO_XTP = 36;
    const IPPROTO_DDP = 37;
    const IPPROTO_CMTP = 38;
    const IPPROTO_TPXX = 39;
    const IPPROTO_IL = 40;
    const IPPROTO_IPV6 = 41;
    const IPPROTO_SDRP = 42;
    const IPPROTO_ROUTING = 43;
    const IPPROTO_FRAGMENT = 44;
    const IPPROTO_IDRP = 45;
    const IPPROTO_RSVP = 46;
    const IPPROTO_GRE = 47;
    const IPPROTO_MHRP = 48;
    const IPPROTO_BHA = 49;
    const IPPROTO_ESP = 50;
    const IPPROTO_AH = 51;
    const IPPROTO_INLSP = 52;
    const IPPROTO_SWIPE = 53;
    const IPPROTO_NHRP = 54;
    const IPPROTO_ICMPV6 = 58;
    const IPPROTO_NONE = 59;
    const IPPROTO_DSTOPTS = 60;
    const IPPROTO_AHIP = 61;
    const IPPROTO_CFTP = 62;
    const IPPROTO_HELLO = 63;
    const IPPROTO_SATEXPAK = 64;
    const IPPROTO_KRYPTOLAN = 65;
    const IPPROTO_RVD = 66;
    const IPPROTO_IPPC = 67;
    const IPPROTO_ADFS = 68;
    const IPPROTO_SATMON = 69;
    const IPPROTO_VISA = 70;
    const IPPROTO_IPCV = 71;
    const IPPROTO_CPNX = 72;
    const IPPROTO_CPHB = 73;
    const IPPROTO_WSN = 74;
    const IPPROTO_PVP = 75;
    const IPPROTO_BRSATMON = 76;
    const IPPROTO_ND = 77;
    const IPPROTO_WBMON = 78;
    const IPPROTO_WBEXPAK = 79;
    const IPPROTO_EON = 80;
    const IPPROTO_VMTP = 81;
    const IPPROTO_SVMTP = 82;
    const IPPROTO_VINES = 83;
    const IPPROTO_TTP = 84;
    const IPPROTO_IGP = 85;
    const IPPROTO_DGP = 86;
    const IPPROTO_TCF = 87;
    const IPPROTO_IGRP = 88;
    const IPPROTO_OSPFIGP = 89;
    const IPPROTO_SRPC = 90;
    const IPPROTO_LARP = 91;
    const IPPROTO_MTP = 92;
    const IPPROTO_AX25 = 93;
    const IPPROTO_IPEIP = 94;
    const IPPROTO_MICP = 95;
    const IPPROTO_SCCSP = 96;
    const IPPROTO_ETHERIP = 97;
    const IPPROTO_ENCAP = 98;
    const IPPROTO_APES = 99;
    const IPPROTO_GMTP = 100;
    const IPPROTO_PIM = 103;
    const IPPROTO_IPCOMP = 108;
    const IPPROTO_PGM = 113;
    const IPPROTO_SCTP = 132;
    const IPPROTO_DIVERT = 254;
    const IPPROTO_RAW = 255;
    const IPPROTO_MAX = 256;
    const IPPROTO_DONE = 257;
    const __DARWIN_IPPORT_RESERVED = 1024;
    const IPPORT_USERRESERVED = 5000;
    const IPPORT_HIFIRSTAUTO = 49152;
    const IPPORT_HILASTAUTO = 65535;
    const IPPORT_RESERVEDSTART = 600;
    const IN_CLASSA_NET = 0xff000000;
    const IN_CLASSA_NSHIFT = 24;
    const IN_CLASSA_HOST = 0x00ffffff;
    const IN_CLASSA_MAX = 128;
    const IN_CLASSB_NET = 0xffff0000;
    const IN_CLASSB_NSHIFT = 16;
    const IN_CLASSB_HOST = 0x0000ffff;
    const IN_CLASSB_MAX = 65536;
    const IN_CLASSC_NET = 0xffffff00;
    const IN_CLASSC_NSHIFT = 8;
    const IN_CLASSC_HOST = 0x000000ff;
    const IN_CLASSD_NET = 0xf0000000;
    const IN_CLASSD_NSHIFT = 28;
    const IN_CLASSD_HOST = 0x0fffffff;
    const INADDR_NONE = 0xffffffff;
    const IN_LOOPBACKNET = 127;
    const INET_ADDRSTRLEN = 16;
    const IP_OPTIONS = 1;
    const IP_HDRINCL = 2;
    const IP_TOS = 3;
    const IP_TTL = 4;
    const IP_RECVOPTS = 5;
    const IP_RECVRETOPTS = 6;
    const IP_RECVDSTADDR = 7;
    const IP_RETOPTS = 8;
    const IP_MULTICAST_IF = 9;
    const IP_MULTICAST_TTL = 10;
    const IP_MULTICAST_LOOP = 11;
    const IP_ADD_MEMBERSHIP = 12;
    const IP_DROP_MEMBERSHIP = 13;
    const IP_MULTICAST_VIF = 14;
    const IP_RSVP_ON = 15;
    const IP_RSVP_OFF = 16;
    const IP_RSVP_VIF_ON = 17;
    const IP_RSVP_VIF_OFF = 18;
    const IP_PORTRANGE = 19;
    const IP_RECVIF = 20;
    const IP_IPSEC_POLICY = 21;
    const IP_FAITH = 22;
    const IP_RECVTTL = 24;
    const IP_BOUND_IF = 25;
    const IP_PKTINFO = 26;
    const IP_RECVTOS = 27;
    const IP_DONTFRAG = 28;
    const IP_FW_ADD = 40;
    const IP_FW_DEL = 41;
    const IP_FW_FLUSH = 42;
    const IP_FW_ZERO = 43;
    const IP_FW_GET = 44;
    const IP_FW_RESETLOG = 45;
    const IP_OLD_FW_ADD = 50;
    const IP_OLD_FW_DEL = 51;
    const IP_OLD_FW_FLUSH = 52;
    const IP_OLD_FW_ZERO = 53;
    const IP_OLD_FW_GET = 54;
    const IP_NAT__XXX = 55;
    const IP_OLD_FW_RESETLOG = 56;
    const IP_DUMMYNET_CONFIGURE = 60;
    const IP_DUMMYNET_DEL = 61;
    const IP_DUMMYNET_FLUSH = 62;
    const IP_DUMMYNET_GET = 64;
    const IP_TRAFFIC_MGT_BACKGROUND = 65;
    const IP_MULTICAST_IFINDEX = 66;
    const IP_ADD_SOURCE_MEMBERSHIP = 70;
    const IP_DROP_SOURCE_MEMBERSHIP = 71;
    const IP_BLOCK_SOURCE = 72;
    const IP_UNBLOCK_SOURCE = 73;
    const IP_MSFILTER = 74;
    const MCAST_JOIN_GROUP = 80;
    const MCAST_LEAVE_GROUP = 81;
    const MCAST_JOIN_SOURCE_GROUP = 82;
    const MCAST_LEAVE_SOURCE_GROUP = 83;
    const MCAST_BLOCK_SOURCE = 84;
    const MCAST_UNBLOCK_SOURCE = 85;
    const IP_DEFAULT_MULTICAST_TTL = 1;
    const IP_DEFAULT_MULTICAST_LOOP = 1;
    const IP_MIN_MEMBERSHIPS = 31;
    const IP_MAX_MEMBERSHIPS = 4095;
    const IP_MAX_GROUP_SRC_FILTER = 512;
    const IP_MAX_SOCK_SRC_FILTER = 128;
    const IP_MAX_SOCK_MUTE_FILTER = 128;
    const MCAST_UNDEFINED = 0;
    const MCAST_INCLUDE = 1;
    const MCAST_EXCLUDE = 2;
    const IP_PORTRANGE_DEFAULT = 0;
    const IP_PORTRANGE_HIGH = 1;
    const IP_PORTRANGE_LOW = 2;
    const IPCTL_FORWARDING = 1;
    const IPCTL_SENDREDIRECTS = 2;
    const IPCTL_DEFTTL = 3;
    const IPCTL_RTEXPIRE = 5;
    const IPCTL_RTMINEXPIRE = 6;
    const IPCTL_RTMAXCACHE = 7;
    const IPCTL_SOURCEROUTE = 8;
    const IPCTL_DIRECTEDBROADCAST = 9;
    const IPCTL_INTRQMAXLEN = 10;
    const IPCTL_INTRQDROPS = 11;
    const IPCTL_STATS = 12;
    const IPCTL_ACCEPTSOURCEROUTE = 13;
    const IPCTL_FASTFORWARDING = 14;
    const IPCTL_KEEPFAITH = 15;
    const IPCTL_GIF_TTL = 16;
    const IPCTL_MAXID = 17;
    const IPV6PORT_RESERVED = 1024;
    const IPV6PORT_ANONMIN = 49152;
    const IPV6PORT_ANONMAX = 65535;
    const IPV6PORT_RESERVEDMIN = 600;
    const INET6_ADDRSTRLEN = 46;
    const __IPV6_ADDR_SCOPE_NODELOCAL = 0x01;
    const __IPV6_ADDR_SCOPE_INTFACELOCAL = 0x01;
    const __IPV6_ADDR_SCOPE_LINKLOCAL = 0x02;
    const __IPV6_ADDR_SCOPE_SITELOCAL = 0x05;
    const __IPV6_ADDR_SCOPE_ORGLOCAL = 0x08;
    const __IPV6_ADDR_SCOPE_GLOBAL = 0x0e;
    const IPV6_ADDR_MC_FLAGS_TRANSIENT = 0x10;
    const IPV6_ADDR_MC_FLAGS_PREFIX = 0x20;
    const IPV6_SOCKOPT_RESERVED1 = 3;
    const IPV6_UNICAST_HOPS = 4;
    const IPV6_MULTICAST_IF = 9;
    const IPV6_MULTICAST_HOPS = 10;
    const IPV6_MULTICAST_LOOP = 11;
    const IPV6_JOIN_GROUP = 12;
    const IPV6_LEAVE_GROUP = 13;
    const IPV6_PORTRANGE = 14;
    const ICMP6_FILTER = 18;
    const IPV6_2292PKTINFO = 19;
    const IPV6_2292HOPLIMIT = 20;
    const IPV6_2292NEXTHOP = 21;
    const IPV6_2292HOPOPTS = 22;
    const IPV6_2292DSTOPTS = 23;
    const IPV6_2292RTHDR = 24;
    const IPV6_2292PKTOPTIONS = 25;
    const IPV6_CHECKSUM = 26;
    const IPV6_V6ONLY = 27;
    const IPV6_IPSEC_POLICY = 28;
    const IPV6_FAITH = 29;
    const IPV6_FW_ADD = 30;
    const IPV6_FW_DEL = 31;
    const IPV6_FW_FLUSH = 32;
    const IPV6_FW_ZERO = 33;
    const IPV6_FW_GET = 34;
    const IPV6_RECVTCLASS = 35;
    const IPV6_TCLASS = 36;
    const IPV6_BOUND_IF = 125;
    const IPV6_RTHDR_LOOSE = 0;
    const IPV6_RTHDR_STRICT = 1;
    const IPV6_RTHDR_TYPE_0 = 0;
    const IPV6_DEFAULT_MULTICAST_HOPS = 1;
    const IPV6_DEFAULT_MULTICAST_LOOP = 1;
    const IPV6_MIN_MEMBERSHIPS = 31;
    const IPV6_MAX_MEMBERSHIPS = 4095;
    const IPV6_MAX_GROUP_SRC_FILTER = 512;
    const IPV6_MAX_SOCK_SRC_FILTER = 128;
    const IPV6_PORTRANGE_DEFAULT = 0;
    const IPV6_PORTRANGE_HIGH = 1;
    const IPV6_PORTRANGE_LOW = 2;
    const IPV6CTL_FORWARDING = 1;
    const IPV6CTL_SENDREDIRECTS = 2;
    const IPV6CTL_DEFHLIM = 3;
    const IPV6CTL_FORWSRCRT = 5;
    const IPV6CTL_STATS = 6;
    const IPV6CTL_MRTSTATS = 7;
    const IPV6CTL_MRTPROTO = 8;
    const IPV6CTL_MAXFRAGPACKETS = 9;
    const IPV6CTL_SOURCECHECK = 10;
    const IPV6CTL_SOURCECHECK_LOGINT = 11;
    const IPV6CTL_ACCEPT_RTADV = 12;
    const IPV6CTL_KEEPFAITH = 13;
    const IPV6CTL_LOG_INTERVAL = 14;
    const IPV6CTL_HDRNESTLIMIT = 15;
    const IPV6CTL_DAD_COUNT = 16;
    const IPV6CTL_AUTO_FLOWLABEL = 17;
    const IPV6CTL_DEFMCASTHLIM = 18;
    const IPV6CTL_GIF_HLIM = 19;
    const IPV6CTL_KAME_VERSION = 20;
    const IPV6CTL_USE_DEPRECATED = 21;
    const IPV6CTL_RR_PRUNE = 22;
    const IPV6CTL_V6ONLY = 24;
    const IPV6CTL_RTEXPIRE = 25;
    const IPV6CTL_RTMINEXPIRE = 26;
    const IPV6CTL_RTMAXCACHE = 27;
    const IPV6CTL_USETEMPADDR = 32;
    const IPV6CTL_TEMPPLTIME = 33;
    const IPV6CTL_TEMPVLTIME = 34;
    const IPV6CTL_AUTO_LINKLOCAL = 35;
    const IPV6CTL_RIP6STATS = 36;
    const IPV6CTL_PREFER_TEMPADDR = 37;
    const IPV6CTL_ADDRCTLPOLICY = 38;
    const IPV6CTL_USE_DEFAULTZONE = 39;
    const IPV6CTL_MAXFRAGS = 41;
    const IPV6CTL_MCAST_PMTU = 44;
    const IPV6CTL_NEIGHBORGCTHRESH = 46;
    const IPV6CTL_MAXIFPREFIXES = 47;
    const IPV6CTL_MAXIFDEFROUTERS = 48;
    const IPV6CTL_MAXDYNROUTES = 49;
    const ICMPV6CTL_ND6_ONLINKNSRFC4861 = 50;
    const IPV6CTL_ULA_USETEMPADDR = 51;
    const IPV6CTL_MAXID = 51;
    const _CLOCK_REALTIME = (0) + 0 /* typedefenum clockid_t */;
    const _CLOCK_MONOTONIC = (6) + 0 /* typedefenum clockid_t */;
    const _CLOCK_MONOTONIC_RAW = (4) + 0 /* typedefenum clockid_t */;
    const _CLOCK_MONOTONIC_RAW_APPROX = (5) + 0 /* typedefenum clockid_t */;
    const _CLOCK_UPTIME_RAW = (8) + 0 /* typedefenum clockid_t */;
    const _CLOCK_UPTIME_RAW_APPROX = (9) + 0 /* typedefenum clockid_t */;
    const _CLOCK_PROCESS_CPUTIME_ID = (12) + 0 /* typedefenum clockid_t */;
    const _CLOCK_THREAD_CPUTIME_ID = (16) + 0 /* typedefenum clockid_t */;
    const QUICHE_ERR_DONE = ((-1)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_BUFFER_TOO_SHORT = ((-2)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_UNKNOWN_VERSION = ((-3)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_INVALID_FRAME = ((-4)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_INVALID_PACKET = ((-5)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_INVALID_STATE = ((-6)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_INVALID_STREAM_STATE = ((-7)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_INVALID_TRANSPORT_PARAM = ((-8)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_CRYPTO_FAIL = ((-9)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_TLS_FAIL = ((-10)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_FLOW_CONTROL = ((-11)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_STREAM_LIMIT = ((-12)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_STREAM_STOPPED = ((-15)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_STREAM_RESET = ((-16)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_FINAL_SIZE = ((-13)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_CONGESTION_CONTROL = ((-14)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_ID_LIMIT = ((-17)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_OUT_OF_IDENTIFIERS = ((-18)) + 0 /* enum quiche_error */;
    const QUICHE_ERR_KEY_UPDATE = ((-19)) + 0 /* enum quiche_error */;
    const QUICHE_CC_RENO = (0) + 0 /* enum quiche_cc_algorithm */;
    const QUICHE_CC_CUBIC = (1) + 0 /* enum quiche_cc_algorithm */;
    const QUICHE_CC_BBR = (2) + 0 /* enum quiche_cc_algorithm */;
    const QUICHE_CC_BBR2 = (3) + 0 /* enum quiche_cc_algorithm */;
    const QUICHE_SHUTDOWN_READ = (0) + 0 /* enum quiche_shutdown */;
    const QUICHE_SHUTDOWN_WRITE = (1) + 0 /* enum quiche_shutdown */;
    const QUICHE_PATH_EVENT_NEW = (0) + 0 /* enum quiche_path_event_type */;
    const QUICHE_PATH_EVENT_VALIDATED = (0) + 1 /* enum quiche_path_event_type */;
    const QUICHE_PATH_EVENT_FAILED_VALIDATION = (0) + 2 /* enum quiche_path_event_type */;
    const QUICHE_PATH_EVENT_CLOSED = (0) + 3 /* enum quiche_path_event_type */;
    const QUICHE_PATH_EVENT_REUSED_SOURCE_CONNECTION_ID = (0) + 4 /* enum quiche_path_event_type */;
    const QUICHE_PATH_EVENT_PEER_MIGRATED = (0) + 5 /* enum quiche_path_event_type */;
    const QUICHE_H3_ERR_DONE = ((-1)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_BUFFER_TOO_SHORT = ((-2)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_INTERNAL_ERROR = ((-3)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_EXCESSIVE_LOAD = ((-4)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_ID_ERROR = ((-5)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_STREAM_CREATION_ERROR = ((-6)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_CLOSED_CRITICAL_STREAM = ((-7)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_MISSING_SETTINGS = ((-8)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_FRAME_UNEXPECTED = ((-9)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_FRAME_ERROR = ((-10)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_QPACK_DECOMPRESSION_FAILED = ((-11)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_STREAM_BLOCKED = ((-13)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_SETTINGS_ERROR = ((-14)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_REQUEST_REJECTED = ((-15)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_REQUEST_CANCELLED = ((-16)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_REQUEST_INCOMPLETE = ((-17)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_MESSAGE_ERROR = ((-18)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_CONNECT_ERROR = ((-19)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_ERR_VERSION_FALLBACK = ((-20)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_DONE = ((self::QUICHE_ERR_DONE - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_BUFFER_TOO_SHORT = ((self::QUICHE_ERR_BUFFER_TOO_SHORT - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_UNKNOWN_VERSION = ((self::QUICHE_ERR_UNKNOWN_VERSION - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_INVALID_FRAME = ((self::QUICHE_ERR_INVALID_FRAME - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_INVALID_PACKET = ((self::QUICHE_ERR_INVALID_PACKET - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_INVALID_STATE = ((self::QUICHE_ERR_INVALID_STATE - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_INVALID_STREAM_STATE = ((self::QUICHE_ERR_INVALID_STREAM_STATE - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_INVALID_TRANSPORT_PARAM = ((self::QUICHE_ERR_INVALID_TRANSPORT_PARAM - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_CRYPTO_FAIL = ((self::QUICHE_ERR_CRYPTO_FAIL - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_TLS_FAIL = ((self::QUICHE_ERR_TLS_FAIL - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_FLOW_CONTROL = ((self::QUICHE_ERR_FLOW_CONTROL - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_STREAM_LIMIT = ((self::QUICHE_ERR_STREAM_LIMIT - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_STREAM_STOPPED = ((self::QUICHE_ERR_STREAM_STOPPED - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_STREAM_RESET = ((self::QUICHE_ERR_STREAM_RESET - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_FINAL_SIZE = ((self::QUICHE_ERR_FINAL_SIZE - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_CONGESTION_CONTROL = ((self::QUICHE_ERR_CONGESTION_CONTROL - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_ID_LIMIT = ((self::QUICHE_ERR_ID_LIMIT - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_OUT_OF_IDENTIFIERS = ((self::QUICHE_ERR_OUT_OF_IDENTIFIERS - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_TRANSPORT_ERR_KEY_UPDATE = ((self::QUICHE_ERR_KEY_UPDATE - 1000)) + 0 /* enum quiche_h3_error */;
    const QUICHE_H3_EVENT_HEADERS = (0) + 0 /* enum quiche_h3_event_type */;
    const QUICHE_H3_EVENT_DATA = (0) + 1 /* enum quiche_h3_event_type */;
    const QUICHE_H3_EVENT_FINISHED = (0) + 2 /* enum quiche_h3_event_type */;
    const QUICHE_H3_EVENT_GOAWAY = (0) + 3 /* enum quiche_h3_event_type */;
    const QUICHE_H3_EVENT_RESET = (0) + 4 /* enum quiche_h3_event_type */;
    const QUICHE_H3_EVENT_PRIORITY_UPDATE = (0) + 5 /* enum quiche_h3_event_type */;
    public static function ffi(?string $pathToSoFile = QuicheFFI::SOFILE): QuicheFFI { return new QuicheFFI($pathToSoFile); }
    public static function sizeof($classOrObject): int { return QuicheFFI::sizeof($classOrObject); }
}
class QuicheFFI {
    const SOFILE = QUICHE_PATH;
    const TYPES_DEF = 'typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
  char __mbstate8[128];
  long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef unsigned int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
  void (*__routine)(void *);
  void *__arg;
  struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
  long __sig;
  char __opaque[56];
};
struct _opaque_pthread_cond_t {
  long __sig;
  char __opaque[40];
};
struct _opaque_pthread_condattr_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_mutex_t {
  long __sig;
  char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_once_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
  long __sig;
  char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
  long __sig;
  char __opaque[16];
};
struct _opaque_pthread_t {
  long __sig;
  struct __darwin_pthread_handler_rec *__cleanup_stack;
  char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
typedef __darwin_intptr_t intptr_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
typedef __darwin_ptrdiff_t ptrdiff_t;
typedef __darwin_size_t rsize_t;
typedef __darwin_wchar_t wchar_t;
typedef __darwin_wint_t wint_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t *qaddr_t;
typedef char *caddr_t;
typedef int32_t daddr_t;
typedef __darwin_dev_t dev_t;
typedef u_int32_t fixpt_t;
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __darwin_gid_t gid_t;
typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;
typedef __darwin_ino64_t ino64_t;
typedef __int32_t key_t;
typedef __darwin_mode_t mode_t;
typedef __uint16_t nlink_t;
typedef __darwin_id_t id_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_off_t off_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
typedef __darwin_uid_t uid_t;
typedef __darwin_clock_t clock_t;
typedef __darwin_ssize_t ssize_t;
typedef __darwin_time_t time_t;
typedef __darwin_useconds_t useconds_t;
typedef __darwin_suseconds_t suseconds_t;
typedef int errno_t;
typedef struct fd_set {
  __int32_t fds_bits[(((1024 % ((sizeof (__int32_t)) * 8)) == 0) ? (1024 / ((sizeof (__int32_t)) * 8)) : ((1024 / ((sizeof (__int32_t)) * 8)) + 1))];
} fd_set;
typedef __int32_t fd_mask;
typedef __darwin_pthread_attr_t pthread_attr_t;
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
typedef __uint8_t sa_family_t;
typedef __darwin_socklen_t socklen_t;
struct iovec {
  void *iov_base;
  size_t iov_len;
};
typedef __uint32_t sae_associd_t;
typedef __uint32_t sae_connid_t;
typedef struct sa_endpoints {
  unsigned int sae_srcif;
  struct sockaddr *sae_srcaddr;
  socklen_t sae_srcaddrlen;
  struct sockaddr *sae_dstaddr;
  socklen_t sae_dstaddrlen;
} sa_endpoints_t;
struct linger {
  int l_onoff;
  int l_linger;
};
struct accept_filter_arg {
  char af_name[16];
  char af_arg[(256 - 16)];
};
struct sockaddr {
  ' . (PHP_OS_FAMILY === 'Darwin' ? 'uint8_t sa_len;' : '') . '
  sa_family_t sa_family;
  char sa_data[14];
};
struct __sockaddr_header {
  ' . (PHP_OS_FAMILY === 'Darwin' ? 'uint8_t sa_len;' : '') . '
  sa_family_t sa_family;
};
struct sockproto {
  __uint16_t sp_family;
  __uint16_t sp_protocol;
};
struct sockaddr_storage {
  ' . (PHP_OS_FAMILY === 'Darwin' ? 'uint8_t ss_len;' : '') . '
  sa_family_t ss_family;
  char __ss_pad1[(((sizeof (__int64_t)) - (sizeof (__uint8_t))) - (sizeof (sa_family_t)))];
  __int64_t __ss_align;
  char __ss_pad2[((((128 - (sizeof (__uint8_t))) - (sizeof (sa_family_t))) - (((sizeof (__int64_t)) - (sizeof (__uint8_t))) - (sizeof (sa_family_t)))) - (sizeof (__int64_t)))];
};
struct msghdr {
  void *msg_name;
  socklen_t msg_namelen;
  struct iovec *msg_iov;
  int msg_iovlen;
  void *msg_control;
  socklen_t msg_controllen;
  int msg_flags;
};
struct cmsghdr {
  socklen_t cmsg_len;
  int cmsg_level;
  int cmsg_type;
};
struct cmsgcred {
  pid_t cmcred_pid;
  uid_t cmcred_uid;
  uid_t cmcred_euid;
  gid_t cmcred_gid;
  short cmcred_ngroups;
  gid_t cmcred_groups[16];
};
struct sf_hdtr {
  struct iovec *headers;
  int hdr_cnt;
  struct iovec *trailers;
  int trl_cnt;
};
struct timespec {
  __darwin_time_t tv_sec;
  long tv_nsec;
};
struct timeval {
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};
struct timeval64 {
  __int64_t tv_sec;
  __int64_t tv_usec;
};
struct itimerval {
  struct timeval it_interval;
  struct timeval it_value;
};
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
struct clockinfo {
  int hz;
  int tick;
  int tickadj;
  int stathz;
  int profhz;
};
struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long tm_gmtoff;
  char *tm_zone;
};
typedef enum {
  _CLOCK_REALTIME = 0,
  _CLOCK_MONOTONIC = 6,
  _CLOCK_MONOTONIC_RAW = 4,
  _CLOCK_MONOTONIC_RAW_APPROX = 5,
  _CLOCK_UPTIME_RAW = 8,
  _CLOCK_UPTIME_RAW_APPROX = 9,
  _CLOCK_PROCESS_CPUTIME_ID = 12,
  _CLOCK_THREAD_CPUTIME_ID = 16,
} clockid_t;
enum quiche_error {
  QUICHE_ERR_DONE = (- 1),
  QUICHE_ERR_BUFFER_TOO_SHORT = (- 2),
  QUICHE_ERR_UNKNOWN_VERSION = (- 3),
  QUICHE_ERR_INVALID_FRAME = (- 4),
  QUICHE_ERR_INVALID_PACKET = (- 5),
  QUICHE_ERR_INVALID_STATE = (- 6),
  QUICHE_ERR_INVALID_STREAM_STATE = (- 7),
  QUICHE_ERR_INVALID_TRANSPORT_PARAM = (- 8),
  QUICHE_ERR_CRYPTO_FAIL = (- 9),
  QUICHE_ERR_TLS_FAIL = (- 10),
  QUICHE_ERR_FLOW_CONTROL = (- 11),
  QUICHE_ERR_STREAM_LIMIT = (- 12),
  QUICHE_ERR_STREAM_STOPPED = (- 15),
  QUICHE_ERR_STREAM_RESET = (- 16),
  QUICHE_ERR_FINAL_SIZE = (- 13),
  QUICHE_ERR_CONGESTION_CONTROL = (- 14),
  QUICHE_ERR_ID_LIMIT = (- 17),
  QUICHE_ERR_OUT_OF_IDENTIFIERS = (- 18),
  QUICHE_ERR_KEY_UPDATE = (- 19),
};
typedef struct quiche_config quiche_config;
enum quiche_cc_algorithm {
  QUICHE_CC_RENO = 0,
  QUICHE_CC_CUBIC = 1,
  QUICHE_CC_BBR = 2,
  QUICHE_CC_BBR2 = 3,
};
typedef struct quiche_conn quiche_conn;
typedef struct {
  struct sockaddr *from;
  socklen_t from_len;
  struct sockaddr *to;
  socklen_t to_len;
} quiche_recv_info;
typedef struct {
  struct sockaddr_storage from;
  socklen_t from_len;
  struct sockaddr_storage to;
  socklen_t to_len;
  struct timespec at;
} quiche_send_info;
enum quiche_shutdown {
  QUICHE_SHUTDOWN_READ = 0,
  QUICHE_SHUTDOWN_WRITE = 1,
};
typedef struct quiche_stream_iter quiche_stream_iter;
typedef struct quiche_connection_id_iter quiche_connection_id_iter;
typedef struct {
  size_t recv;
  size_t sent;
  size_t lost;
  size_t retrans;
  uint64_t sent_bytes;
  uint64_t recv_bytes;
  uint64_t lost_bytes;
  uint64_t stream_retrans_bytes;
  size_t paths_count;
  uint64_t reset_stream_count_local;
  uint64_t stopped_stream_count_local;
  uint64_t reset_stream_count_remote;
  uint64_t stopped_stream_count_remote;
} quiche_stats;
typedef struct {
  uint64_t peer_max_idle_timeout;
  uint64_t peer_max_udp_payload_size;
  uint64_t peer_initial_max_data;
  uint64_t peer_initial_max_stream_data_bidi_local;
  uint64_t peer_initial_max_stream_data_bidi_remote;
  uint64_t peer_initial_max_stream_data_uni;
  uint64_t peer_initial_max_streams_bidi;
  uint64_t peer_initial_max_streams_uni;
  uint64_t peer_ack_delay_exponent;
  uint64_t peer_max_ack_delay;
  _Bool peer_disable_active_migration;
  uint64_t peer_active_conn_id_limit;
  ssize_t peer_max_datagram_frame_size;
} quiche_transport_params;
typedef struct {
  struct sockaddr_storage local_addr;
  socklen_t local_addr_len;
  struct sockaddr_storage peer_addr;
  socklen_t peer_addr_len;
  ssize_t validation_state;
  _Bool active;
  size_t recv;
  size_t sent;
  size_t lost;
  size_t retrans;
  uint64_t rtt;
  size_t cwnd;
  uint64_t sent_bytes;
  uint64_t recv_bytes;
  uint64_t lost_bytes;
  uint64_t stream_retrans_bytes;
  size_t pmtu;
  uint64_t delivery_rate;
} quiche_path_stats;
enum quiche_path_event_type {
  QUICHE_PATH_EVENT_NEW,
  QUICHE_PATH_EVENT_VALIDATED,
  QUICHE_PATH_EVENT_FAILED_VALIDATION,
  QUICHE_PATH_EVENT_CLOSED,
  QUICHE_PATH_EVENT_REUSED_SOURCE_CONNECTION_ID,
  QUICHE_PATH_EVENT_PEER_MIGRATED,
};
typedef struct quiche_path_event quiche_path_event;
typedef struct quiche_socket_addr_iter quiche_socket_addr_iter;
enum quiche_h3_error {
  QUICHE_H3_ERR_DONE = (- 1),
  QUICHE_H3_ERR_BUFFER_TOO_SHORT = (- 2),
  QUICHE_H3_ERR_INTERNAL_ERROR = (- 3),
  QUICHE_H3_ERR_EXCESSIVE_LOAD = (- 4),
  QUICHE_H3_ERR_ID_ERROR = (- 5),
  QUICHE_H3_ERR_STREAM_CREATION_ERROR = (- 6),
  QUICHE_H3_ERR_CLOSED_CRITICAL_STREAM = (- 7),
  QUICHE_H3_ERR_MISSING_SETTINGS = (- 8),
  QUICHE_H3_ERR_FRAME_UNEXPECTED = (- 9),
  QUICHE_H3_ERR_FRAME_ERROR = (- 10),
  QUICHE_H3_ERR_QPACK_DECOMPRESSION_FAILED = (- 11),
  QUICHE_H3_ERR_STREAM_BLOCKED = (- 13),
  QUICHE_H3_ERR_SETTINGS_ERROR = (- 14),
  QUICHE_H3_ERR_REQUEST_REJECTED = (- 15),
  QUICHE_H3_ERR_REQUEST_CANCELLED = (- 16),
  QUICHE_H3_ERR_REQUEST_INCOMPLETE = (- 17),
  QUICHE_H3_ERR_MESSAGE_ERROR = (- 18),
  QUICHE_H3_ERR_CONNECT_ERROR = (- 19),
  QUICHE_H3_ERR_VERSION_FALLBACK = (- 20),
  QUICHE_H3_TRANSPORT_ERR_DONE = (QUICHE_ERR_DONE - 1000),
  QUICHE_H3_TRANSPORT_ERR_BUFFER_TOO_SHORT = (QUICHE_ERR_BUFFER_TOO_SHORT - 1000),
  QUICHE_H3_TRANSPORT_ERR_UNKNOWN_VERSION = (QUICHE_ERR_UNKNOWN_VERSION - 1000),
  QUICHE_H3_TRANSPORT_ERR_INVALID_FRAME = (QUICHE_ERR_INVALID_FRAME - 1000),
  QUICHE_H3_TRANSPORT_ERR_INVALID_PACKET = (QUICHE_ERR_INVALID_PACKET - 1000),
  QUICHE_H3_TRANSPORT_ERR_INVALID_STATE = (QUICHE_ERR_INVALID_STATE - 1000),
  QUICHE_H3_TRANSPORT_ERR_INVALID_STREAM_STATE = (QUICHE_ERR_INVALID_STREAM_STATE - 1000),
  QUICHE_H3_TRANSPORT_ERR_INVALID_TRANSPORT_PARAM = (QUICHE_ERR_INVALID_TRANSPORT_PARAM - 1000),
  QUICHE_H3_TRANSPORT_ERR_CRYPTO_FAIL = (QUICHE_ERR_CRYPTO_FAIL - 1000),
  QUICHE_H3_TRANSPORT_ERR_TLS_FAIL = (QUICHE_ERR_TLS_FAIL - 1000),
  QUICHE_H3_TRANSPORT_ERR_FLOW_CONTROL = (QUICHE_ERR_FLOW_CONTROL - 1000),
  QUICHE_H3_TRANSPORT_ERR_STREAM_LIMIT = (QUICHE_ERR_STREAM_LIMIT - 1000),
  QUICHE_H3_TRANSPORT_ERR_STREAM_STOPPED = (QUICHE_ERR_STREAM_STOPPED - 1000),
  QUICHE_H3_TRANSPORT_ERR_STREAM_RESET = (QUICHE_ERR_STREAM_RESET - 1000),
  QUICHE_H3_TRANSPORT_ERR_FINAL_SIZE = (QUICHE_ERR_FINAL_SIZE - 1000),
  QUICHE_H3_TRANSPORT_ERR_CONGESTION_CONTROL = (QUICHE_ERR_CONGESTION_CONTROL - 1000),
  QUICHE_H3_TRANSPORT_ERR_ID_LIMIT = (QUICHE_ERR_ID_LIMIT - 1000),
  QUICHE_H3_TRANSPORT_ERR_OUT_OF_IDENTIFIERS = (QUICHE_ERR_OUT_OF_IDENTIFIERS - 1000),
  QUICHE_H3_TRANSPORT_ERR_KEY_UPDATE = (QUICHE_ERR_KEY_UPDATE - 1000),
};
typedef struct quiche_h3_config quiche_h3_config;
typedef struct quiche_h3_conn quiche_h3_conn;
enum quiche_h3_event_type {
  QUICHE_H3_EVENT_HEADERS,
  QUICHE_H3_EVENT_DATA,
  QUICHE_H3_EVENT_FINISHED,
  QUICHE_H3_EVENT_GOAWAY,
  QUICHE_H3_EVENT_RESET,
  QUICHE_H3_EVENT_PRIORITY_UPDATE,
};
typedef struct quiche_h3_event quiche_h3_event;
typedef struct {
  uint8_t *name;
  size_t name_len;
  uint8_t *value;
  size_t value_len;
} quiche_h3_header;
typedef struct {
  uint8_t urgency;
  _Bool incremental;
} quiche_h3_priority;
struct in_addr {
  in_addr_t s_addr;
};
struct sockaddr_in {
  ' . (PHP_OS_FAMILY === 'Darwin' ? 'uint8_t sin_len;' : '') . '
  sa_family_t sin_family;
  in_port_t sin_port;
  struct in_addr sin_addr;
  char sin_zero[8];
};
struct ip_opts {
  struct in_addr ip_dst;
  char ip_opts[40];
};
struct ip_mreq {
  struct in_addr imr_multiaddr;
  struct in_addr imr_interface;
};
struct ip_mreqn {
  struct in_addr imr_multiaddr;
  struct in_addr imr_address;
  int imr_ifindex;
};
struct ip_mreq_source {
  struct in_addr imr_multiaddr;
  struct in_addr imr_sourceaddr;
  struct in_addr imr_interface;
};
struct group_req {
  uint32_t gr_interface;
  struct sockaddr_storage gr_group;
};
struct group_source_req {
  uint32_t gsr_interface;
  struct sockaddr_storage gsr_group;
  struct sockaddr_storage gsr_source;
};
struct __msfilterreq {
  uint32_t msfr_ifindex;
  uint32_t msfr_fmode;
  uint32_t msfr_nsrcs;
  uint32_t __msfr_align;
  struct sockaddr_storage msfr_group;
  struct sockaddr_storage *msfr_srcs;
};
struct sockaddr;
struct in_pktinfo {
  unsigned int ipi_ifindex;
  struct in_addr ipi_spec_dst;
  struct in_addr ipi_addr;
};
typedef struct in6_addr {
  union {
    __uint8_t __u6_addr8[16];
    __uint16_t __u6_addr16[8];
    __uint32_t __u6_addr32[4];
  } __u6_addr;
} in6_addr_t;
struct sockaddr_in6 {
  ' . (PHP_OS_FAMILY === 'Darwin' ? 'uint8_t sin6_len;' : '') . '
  sa_family_t sin6_family;
  in_port_t sin6_port;
  __uint32_t sin6_flowinfo;
  struct in6_addr sin6_addr;
  __uint32_t sin6_scope_id;
};
struct ipv6_mreq {
  struct in6_addr ipv6mr_multiaddr;
  unsigned int ipv6mr_interface;
};
struct in6_pktinfo {
  struct in6_addr ipi6_addr;
  unsigned int ipi6_ifindex;
};
struct ip6_mtuinfo {
  struct sockaddr_in6 ip6m_addr;
  uint32_t ip6m_mtu;
};
struct cmsghdr;
struct sockaddr;
';
    const HEADER_DEF = self::TYPES_DEF . 'int __darwin_check_fd_set_overflow(int, void *, int);
int accept(int, struct sockaddr *, socklen_t *) __asm__ ("_accept");
int bind(int, struct sockaddr *, socklen_t) __asm__ ("_bind");
int connect(int, struct sockaddr *, socklen_t) __asm__ ("_connect");
int getpeername(int, struct sockaddr *, socklen_t *) __asm__ ("_getpeername");
int getsockname(int, struct sockaddr *, socklen_t *) __asm__ ("_getsockname");
int getsockopt(int, int, int, void *, socklen_t *);
int listen(int, int) __asm__ ("_listen");
ssize_t recv(int, void *, size_t, int) __asm__ ("_recv");
ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *) __asm__ ("_recvfrom");
ssize_t recvmsg(int, struct msghdr *, int) __asm__ ("_recvmsg");
ssize_t send(int, void *, size_t, int) __asm__ ("_send");
ssize_t sendmsg(int, struct msghdr *, int) __asm__ ("_sendmsg");
ssize_t sendto(int, void *, size_t, int, struct sockaddr *, socklen_t) __asm__ ("_sendto");
int setsockopt(int, int, int, void *, socklen_t);
int shutdown(int, int);
int sockatmark(int);
int socket(int, int, int);
int socketpair(int, int, int, int *) __asm__ ("_socketpair");
int sendfile(int, int, off_t, off_t *, struct sf_hdtr *, int);
int connectx(int, sa_endpoints_t *, sae_associd_t, unsigned int, struct iovec *, unsigned int, size_t *, sae_connid_t *);
int disconnectx(int, sae_associd_t, sae_connid_t);
extern char *tzname[];
extern int getdate_err;
extern long timezone __asm__ ("_timezone");
extern int daylight;
char *asctime(struct tm *);
clock_t clock(void) __asm__ ("_clock");
char *ctime(time_t *);
double difftime(time_t, time_t);
struct tm *getdate(char *);
struct tm *gmtime(time_t *);
struct tm *localtime(time_t *);
time_t mktime(struct tm *) __asm__ ("_mktime");
size_t strftime(char *, size_t, char *, struct tm *) __asm__ ("_strftime");
char *strptime(char *, char *, struct tm *) __asm__ ("_strptime");
time_t time(time_t *);
void tzset(void);
char *asctime_r(struct tm *, char *);
char *ctime_r(time_t *, char *);
struct tm *gmtime_r(time_t *, struct tm *);
struct tm *localtime_r(time_t *, struct tm *);
time_t posix2time(time_t);
void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm *);
time_t timegm(struct tm *);
int nanosleep(struct timespec *__rqtp, struct timespec *__rmtp) __asm__ ("_nanosleep");
int clock_getres(clockid_t __clock_id, struct timespec *__res);
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);
int clock_settime(clockid_t __clock_id, struct timespec *__tp);
int timespec_get(struct timespec *ts, int base);
int adjtime(struct timeval *, struct timeval *);
int futimes(int, struct timeval *);
int lutimes(char *, struct timeval *);
int settimeofday(struct timeval *, struct timezone *);
int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval *, void *);
int select(int, fd_set *, fd_set *, fd_set *, struct timeval *) __asm__ ("_select$1050");
int setitimer(int, struct itimerval *, struct itimerval *);
int utimes(char *, struct timeval *);
char *quiche_version(void);
int quiche_enable_debug_logging(void (*cb)(char *line, void *argp), void *argp);
quiche_config *quiche_config_new(uint32_t version);
int quiche_config_load_cert_chain_from_pem_file(quiche_config *config, char *path);
int quiche_config_load_priv_key_from_pem_file(quiche_config *config, char *path);
int quiche_config_load_verify_locations_from_file(quiche_config *config, char *path);
int quiche_config_load_verify_locations_from_directory(quiche_config *config, char *path);
void quiche_config_verify_peer(quiche_config *config, _Bool v);
void quiche_config_grease(quiche_config *config, _Bool v);
void quiche_config_log_keys(quiche_config *config);
void quiche_config_enable_early_data(quiche_config *config);
int quiche_config_set_application_protos(quiche_config *config, uint8_t *protos, size_t protos_len);
void quiche_config_set_max_idle_timeout(quiche_config *config, uint64_t v);
void quiche_config_set_max_recv_udp_payload_size(quiche_config *config, size_t v);
void quiche_config_set_max_send_udp_payload_size(quiche_config *config, size_t v);
void quiche_config_set_initial_max_data(quiche_config *config, uint64_t v);
void quiche_config_set_initial_max_stream_data_bidi_local(quiche_config *config, uint64_t v);
void quiche_config_set_initial_max_stream_data_bidi_remote(quiche_config *config, uint64_t v);
void quiche_config_set_initial_max_stream_data_uni(quiche_config *config, uint64_t v);
void quiche_config_set_initial_max_streams_bidi(quiche_config *config, uint64_t v);
void quiche_config_set_initial_max_streams_uni(quiche_config *config, uint64_t v);
void quiche_config_set_ack_delay_exponent(quiche_config *config, uint64_t v);
void quiche_config_set_max_ack_delay(quiche_config *config, uint64_t v);
void quiche_config_set_disable_active_migration(quiche_config *config, _Bool v);
int quiche_config_set_cc_algorithm_name(quiche_config *config, char *algo);
void quiche_config_set_initial_congestion_window_packets(quiche_config *config, size_t packets);
void quiche_config_set_cc_algorithm(quiche_config *config, enum quiche_cc_algorithm algo);
void quiche_config_enable_hystart(quiche_config *config, _Bool v);
void quiche_config_enable_pacing(quiche_config *config, _Bool v);
void quiche_config_set_max_pacing_rate(quiche_config *config, uint64_t v);
void quiche_config_enable_dgram(quiche_config *config, _Bool enabled, size_t recv_queue_len, size_t send_queue_len);
void quiche_config_set_max_connection_window(quiche_config *config, uint64_t v);
void quiche_config_set_max_stream_window(quiche_config *config, uint64_t v);
void quiche_config_set_active_connection_id_limit(quiche_config *config, uint64_t v);
void quiche_config_set_stateless_reset_token(quiche_config *config, uint8_t *v);
void quiche_config_set_disable_dcid_reuse(quiche_config *config, _Bool v);
int quiche_config_set_ticket_key(quiche_config *config, uint8_t *key, size_t key_len);
void quiche_config_free(quiche_config *config);
int quiche_header_info(uint8_t *buf, size_t buf_len, size_t dcil, uint32_t *version, uint8_t *type, uint8_t *scid, size_t *scid_len, uint8_t *dcid, size_t *dcid_len, uint8_t *token, size_t *token_len);
quiche_conn *quiche_accept(uint8_t *scid, size_t scid_len, uint8_t *odcid, size_t odcid_len, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len, quiche_config *config);
quiche_conn *quiche_connect(char *server_name, uint8_t *scid, size_t scid_len, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len, quiche_config *config);
ssize_t quiche_negotiate_version(uint8_t *scid, size_t scid_len, uint8_t *dcid, size_t dcid_len, uint8_t *out, size_t out_len);
ssize_t quiche_retry(uint8_t *scid, size_t scid_len, uint8_t *dcid, size_t dcid_len, uint8_t *new_scid, size_t new_scid_len, uint8_t *token, size_t token_len, uint32_t version, uint8_t *out, size_t out_len);
_Bool quiche_version_is_supported(uint32_t version);
quiche_conn *quiche_conn_new_with_tls(uint8_t *scid, size_t scid_len, uint8_t *odcid, size_t odcid_len, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len, quiche_config *config, void *ssl, _Bool is_server);
_Bool quiche_conn_set_keylog_path(quiche_conn *conn, char *path);
void quiche_conn_set_keylog_fd(quiche_conn *conn, int fd);
_Bool quiche_conn_set_qlog_path(quiche_conn *conn, char *path, char *log_title, char *log_desc);
void quiche_conn_set_qlog_fd(quiche_conn *conn, int fd, char *log_title, char *log_desc);
int quiche_conn_set_session(quiche_conn *conn, uint8_t *buf, size_t buf_len);
ssize_t quiche_conn_recv(quiche_conn *conn, uint8_t *buf, size_t buf_len, quiche_recv_info *info);
ssize_t quiche_conn_send(quiche_conn *conn, uint8_t *out, size_t out_len, quiche_send_info *out_info);
size_t quiche_conn_send_quantum(quiche_conn *conn);
ssize_t quiche_conn_send_on_path(quiche_conn *conn, uint8_t *out, size_t out_len, struct sockaddr *from, socklen_t from_len, struct sockaddr *to, socklen_t to_len, quiche_send_info *out_info);
size_t quiche_conn_send_quantum_on_path(quiche_conn *conn, struct sockaddr *local_addr, socklen_t local_len, struct sockaddr *peer_addr, socklen_t peer_len);
ssize_t quiche_conn_stream_recv(quiche_conn *conn, uint64_t stream_id, uint8_t *out, size_t buf_len, _Bool *fin);
ssize_t quiche_conn_stream_send(quiche_conn *conn, uint64_t stream_id, uint8_t *buf, size_t buf_len, _Bool fin);
int quiche_conn_stream_priority(quiche_conn *conn, uint64_t stream_id, uint8_t urgency, _Bool incremental);
int quiche_conn_stream_shutdown(quiche_conn *conn, uint64_t stream_id, enum quiche_shutdown direction, uint64_t err);
ssize_t quiche_conn_stream_capacity(quiche_conn *conn, uint64_t stream_id);
_Bool quiche_conn_stream_readable(quiche_conn *conn, uint64_t stream_id);
int64_t quiche_conn_stream_readable_next(quiche_conn *conn);
int quiche_conn_stream_writable(quiche_conn *conn, uint64_t stream_id, size_t len);
int64_t quiche_conn_stream_writable_next(quiche_conn *conn);
_Bool quiche_conn_stream_finished(quiche_conn *conn, uint64_t stream_id);
quiche_stream_iter *quiche_conn_readable(quiche_conn *conn);
quiche_stream_iter *quiche_conn_writable(quiche_conn *conn);
size_t quiche_conn_max_send_udp_payload_size(quiche_conn *conn);
uint64_t quiche_conn_timeout_as_nanos(quiche_conn *conn);
uint64_t quiche_conn_timeout_as_millis(quiche_conn *conn);
void quiche_conn_on_timeout(quiche_conn *conn);
int quiche_conn_close(quiche_conn *conn, _Bool app, uint64_t err, uint8_t *reason, size_t reason_len);
void quiche_conn_trace_id(quiche_conn *conn, uint8_t **out, size_t *out_len);
void quiche_conn_source_id(quiche_conn *conn, uint8_t **out, size_t *out_len);
quiche_connection_id_iter *quiche_conn_source_ids(quiche_conn *conn);
_Bool quiche_connection_id_iter_next(quiche_connection_id_iter *iter, uint8_t **out, size_t *out_len);
void quiche_connection_id_iter_free(quiche_connection_id_iter *iter);
void quiche_conn_destination_id(quiche_conn *conn, uint8_t **out, size_t *out_len);
void quiche_conn_application_proto(quiche_conn *conn, uint8_t **out, size_t *out_len);
void quiche_conn_peer_cert(quiche_conn *conn, uint8_t **out, size_t *out_len);
void quiche_conn_session(quiche_conn *conn, uint8_t **out, size_t *out_len);
_Bool quiche_conn_is_established(quiche_conn *conn);
_Bool quiche_conn_is_resumed(quiche_conn *conn);
_Bool quiche_conn_is_in_early_data(quiche_conn *conn);
_Bool quiche_conn_is_readable(quiche_conn *conn);
_Bool quiche_conn_is_draining(quiche_conn *conn);
uint64_t quiche_conn_peer_streams_left_bidi(quiche_conn *conn);
uint64_t quiche_conn_peer_streams_left_uni(quiche_conn *conn);
_Bool quiche_conn_is_closed(quiche_conn *conn);
_Bool quiche_conn_is_timed_out(quiche_conn *conn);
_Bool quiche_conn_peer_error(quiche_conn *conn, _Bool *is_app, uint64_t *error_code, uint8_t **reason, size_t *reason_len);
_Bool quiche_conn_local_error(quiche_conn *conn, _Bool *is_app, uint64_t *error_code, uint8_t **reason, size_t *reason_len);
_Bool quiche_stream_iter_next(quiche_stream_iter *iter, uint64_t *stream_id);
void quiche_stream_iter_free(quiche_stream_iter *iter);
void quiche_conn_stats(quiche_conn *conn, quiche_stats *out);
_Bool quiche_conn_peer_transport_params(quiche_conn *conn, quiche_transport_params *out);
int quiche_conn_path_stats(quiche_conn *conn, size_t idx, quiche_path_stats *out);
_Bool quiche_conn_is_server(quiche_conn *conn);
ssize_t quiche_conn_dgram_max_writable_len(quiche_conn *conn);
ssize_t quiche_conn_dgram_recv_front_len(quiche_conn *conn);
ssize_t quiche_conn_dgram_recv_queue_len(quiche_conn *conn);
ssize_t quiche_conn_dgram_recv_queue_byte_size(quiche_conn *conn);
ssize_t quiche_conn_dgram_send_queue_len(quiche_conn *conn);
ssize_t quiche_conn_dgram_send_queue_byte_size(quiche_conn *conn);
ssize_t quiche_conn_dgram_recv(quiche_conn *conn, uint8_t *buf, size_t buf_len);
ssize_t quiche_conn_dgram_send(quiche_conn *conn, uint8_t *buf, size_t buf_len);
void quiche_conn_dgram_purge_outgoing(quiche_conn *conn, _Bool (*f)(uint8_t *, size_t));
_Bool quiche_conn_is_dgram_send_queue_full(quiche_conn *conn);
_Bool quiche_conn_is_dgram_recv_queue_full(quiche_conn *conn);
ssize_t quiche_conn_send_ack_eliciting(quiche_conn *conn);
ssize_t quiche_conn_send_ack_eliciting_on_path(quiche_conn *conn, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len);
_Bool quiche_conn_retired_scid_next(quiche_conn *conn, uint8_t **out, size_t *out_len);
size_t quiche_conn_retired_scids(quiche_conn *conn);
size_t quiche_conn_available_dcids(quiche_conn *conn);
size_t quiche_conn_scids_left(quiche_conn *conn);
size_t quiche_conn_active_scids(quiche_conn *conn);
int quiche_conn_new_scid(quiche_conn *conn, uint8_t *scid, size_t scid_len, uint8_t *reset_token, _Bool retire_if_needed, uint64_t *scid_seq);
int quiche_conn_probe_path(quiche_conn *conn, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len, uint64_t *seq);
int quiche_conn_migrate_source(quiche_conn *conn, struct sockaddr *local, socklen_t local_len, uint64_t *seq);
int quiche_conn_migrate(quiche_conn *conn, struct sockaddr *local, socklen_t local_len, struct sockaddr *peer, socklen_t peer_len, uint64_t *seq);
quiche_path_event *quiche_conn_path_event_next(quiche_conn *conn);
enum quiche_path_event_type quiche_path_event_type(quiche_path_event *ev);
void quiche_path_event_new(quiche_path_event *ev, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_validated(quiche_path_event *ev, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_failed_validation(quiche_path_event *ev, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_closed(quiche_path_event *ev, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_reused_source_connection_id(quiche_path_event *ev, uint64_t *id, struct sockaddr_storage *old_local, socklen_t *old_local_len, struct sockaddr_storage *old_peer, socklen_t *old_peer_len, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_peer_migrated(quiche_path_event *ev, struct sockaddr_storage *local, socklen_t *local_len, struct sockaddr_storage *peer, socklen_t *peer_len);
void quiche_path_event_free(quiche_path_event *ev);
int quiche_conn_retire_dcid(quiche_conn *conn, uint64_t dcid_seq);
quiche_socket_addr_iter *quiche_conn_paths_iter(quiche_conn *conn, struct sockaddr *from, size_t from_len);
_Bool quiche_socket_addr_iter_next(quiche_socket_addr_iter *iter, struct sockaddr_storage *peer, size_t *peer_len);
void quiche_socket_addr_iter_free(quiche_socket_addr_iter *iter);
int quiche_conn_is_path_validated(quiche_conn *conn, struct sockaddr *from, size_t from_len, struct sockaddr *to, size_t to_len);
void quiche_conn_free(quiche_conn *conn);
int quiche_put_varint(uint8_t *buf, size_t buf_len, uint64_t val);
ssize_t quiche_get_varint(uint8_t *buf, size_t buf_len, uint64_t *val);
quiche_h3_config *quiche_h3_config_new(void);
void quiche_h3_config_set_max_field_section_size(quiche_h3_config *config, uint64_t v);
void quiche_h3_config_set_qpack_max_table_capacity(quiche_h3_config *config, uint64_t v);
void quiche_h3_config_set_qpack_blocked_streams(quiche_h3_config *config, uint64_t v);
void quiche_h3_config_enable_extended_connect(quiche_h3_config *config, _Bool enabled);
void quiche_h3_config_free(quiche_h3_config *config);
quiche_h3_conn *quiche_h3_conn_new_with_transport(quiche_conn *quiche_conn, quiche_h3_config *config);
int64_t quiche_h3_conn_poll(quiche_h3_conn *conn, quiche_conn *quic_conn, quiche_h3_event **ev);
enum quiche_h3_event_type quiche_h3_event_type(quiche_h3_event *ev);
int quiche_h3_event_for_each_header(quiche_h3_event *ev, int (*cb)(uint8_t *name, size_t name_len, uint8_t *value, size_t value_len, void *argp), void *argp);
int quiche_h3_for_each_setting(quiche_h3_conn *conn, int (*cb)(uint64_t identifier, uint64_t value, void *argp), void *argp);
_Bool quiche_h3_event_headers_has_body(quiche_h3_event *ev);
_Bool quiche_h3_extended_connect_enabled_by_peer(quiche_h3_conn *conn);
void quiche_h3_event_free(quiche_h3_event *ev);
int64_t quiche_h3_send_request(quiche_h3_conn *conn, quiche_conn *quic_conn, quiche_h3_header *headers, size_t headers_len, _Bool fin);
int quiche_h3_send_response(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t stream_id, quiche_h3_header *headers, size_t headers_len, _Bool fin);
int quiche_h3_send_response_with_priority(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t stream_id, quiche_h3_header *headers, size_t headers_len, quiche_h3_priority *priority, _Bool fin);
ssize_t quiche_h3_send_body(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t stream_id, uint8_t *body, size_t body_len, _Bool fin);
ssize_t quiche_h3_recv_body(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t stream_id, uint8_t *out, size_t out_len);
int quiche_h3_send_goaway(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t id);
int quiche_h3_parse_extensible_priority(uint8_t *priority, size_t priority_len, quiche_h3_priority *parsed);
int quiche_h3_send_priority_update_for_request(quiche_h3_conn *conn, quiche_conn *quic_conn, uint64_t stream_id, quiche_h3_priority *priority);
int quiche_h3_take_last_priority_update(quiche_h3_conn *conn, uint64_t prioritized_element_id, int (*cb)(uint8_t *priority_field_value, uint64_t priority_field_value_len, void *argp), void *argp);
_Bool quiche_h3_dgram_enabled_by_peer(quiche_h3_conn *conn, quiche_conn *quic_conn);
void quiche_h3_conn_free(quiche_h3_conn *conn);
int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, struct in_addr *);
int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *);
int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t, uint32_t, struct sockaddr_storage *);
int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *);
extern struct in6_addr in6addr_any;
extern struct in6_addr in6addr_loopback;
extern struct in6_addr in6addr_nodelocal_allnodes;
extern struct in6_addr in6addr_linklocal_allnodes;
extern struct in6_addr in6addr_linklocal_allrouters;
extern struct in6_addr in6addr_linklocal_allv2routers;
extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, __uint8_t *, int, int);
extern __uint8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(struct cmsghdr *, __uint8_t **);
extern int inet6_option_find(struct cmsghdr *, __uint8_t **, int);
extern size_t inet6_rthdr_space(int, int);
extern struct cmsghdr *inet6_rthdr_init(void *, int);
extern int inet6_rthdr_add(struct cmsghdr *, struct in6_addr *, unsigned int);
extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int);
extern int inet6_rthdr_segments(struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int);
extern int inet6_rthdr_getflags(struct cmsghdr *, int);
extern int inet6_opt_init(void *, socklen_t);
extern int inet6_opt_append(void *, socklen_t, int, __uint8_t, socklen_t, __uint8_t, void **);
extern int inet6_opt_finish(void *, socklen_t, int);
extern int inet6_opt_set_val(void *, int, void *, socklen_t);
extern int inet6_opt_next(void *, socklen_t, int, __uint8_t *, socklen_t *, void **);
extern int inet6_opt_find(void *, socklen_t, int, __uint8_t, socklen_t *, void **);
extern int inet6_opt_get_val(void *, int, void *, socklen_t);
extern socklen_t inet6_rth_space(int, int);
extern void *inet6_rth_init(void *, socklen_t, int, int);
extern int inet6_rth_add(void *, struct in6_addr *);
extern int inet6_rth_reverse(void *, void *);
extern int inet6_rth_segments(void *);
extern struct in6_addr *inet6_rth_getaddr(void *, int);
int bindresvport(int, struct sockaddr_in *);
int bindresvport_sa(int, struct sockaddr *);
';
    private FFI $ffi;
    private static FFI $staticFFI;
    private static \WeakMap $__arrayWeakMap;
    private array $__literalStrings = [];
    public function __construct(?string $pathToSoFile = self::SOFILE) {
        $this->ffi = FFI::cdef(self::HEADER_DEF, $pathToSoFile);
    }

    public static function cast(iQuiche $from, string $to): iQuiche {
        if (!is_a($to, iQuiche::class, true)) {
            throw new \LogicException("Cannot cast to a non-wrapper type");
        }
        return new $to(self::$staticFFI->cast($to::getType(), $from->getData()));
    }

    public static function makeArray(string $class, int|array $elements): iQuiche {
        $type = $class::getType();
        if (substr($type, -1) !== "*") {
            throw new \LogicException("Attempting to make a non-pointer element into an array");
        }
        if (is_int($elements)) {
            $cdata = self::$staticFFI->new(substr($type, 0, -1) . "[$elements]");
        } else {
            $cdata = self::$staticFFI->new(substr($type, 0, -1) . "[" . count($elements) . "]");
            foreach ($elements as $key => $raw) {
                $cdata[$key] = \is_scalar($raw) ? \is_int($raw) && $type === "char*" ? \chr($raw) : $raw : $raw->getData();
            }
        }
        $object = new $class(self::$staticFFI->cast($type, \FFI::addr($cdata)));
        self::$__arrayWeakMap[$object] = $cdata;
        return $object;
    }

    public static function sizeof($classOrObject): int {
        if (is_object($classOrObject) && $classOrObject instanceof iQuiche) {
            return FFI::sizeof($classOrObject->getData());
        } elseif (is_a($classOrObject, iQuiche::class, true)) {
            return FFI::sizeof(self::$staticFFI->type($classOrObject::getType()));
        } else {
            throw new \LogicException("Unknown class/object passed to sizeof()");
        }
    }

    public function getFFI(): FFI {
        return $this->ffi;
    }


    public function __get(string $name) {
        switch($name) {
            case 'tzname': return new string_ptr($this->ffi->tzname);
            case 'getdate_err': return $this->ffi->getdate_err;
            case 'timezone': return $this->ffi->timezone;
            case 'daylight': return $this->ffi->daylight;
            case 'in6addr_any': return new struct_in6_addr($this->ffi->in6addr_any);
            case 'in6addr_loopback': return new struct_in6_addr($this->ffi->in6addr_loopback);
            case 'in6addr_nodelocal_allnodes': return new struct_in6_addr($this->ffi->in6addr_nodelocal_allnodes);
            case 'in6addr_linklocal_allnodes': return new struct_in6_addr($this->ffi->in6addr_linklocal_allnodes);
            case 'in6addr_linklocal_allrouters': return new struct_in6_addr($this->ffi->in6addr_linklocal_allrouters);
            case 'in6addr_linklocal_allv2routers': return new struct_in6_addr($this->ffi->in6addr_linklocal_allv2routers);
            default: return $this->ffi->$name;
        }
    }
    public function __set(string $name, $value) {
        switch($name) {
            case 'tzname': (new string_ptr($this->ffi->tzname))->set($value); break;
            case 'getdate_err': $this->ffi->getdate_err = $value; break;
            case 'timezone': $this->ffi->timezone = $value; break;
            case 'daylight': $this->ffi->daylight = $value; break;
            case 'in6addr_any': (new struct_in6_addr($this->ffi->in6addr_any))->set($value); break;
            case 'in6addr_loopback': (new struct_in6_addr($this->ffi->in6addr_loopback))->set($value); break;
            case 'in6addr_nodelocal_allnodes': (new struct_in6_addr($this->ffi->in6addr_nodelocal_allnodes))->set($value); break;
            case 'in6addr_linklocal_allnodes': (new struct_in6_addr($this->ffi->in6addr_linklocal_allnodes))->set($value); break;
            case 'in6addr_linklocal_allrouters': (new struct_in6_addr($this->ffi->in6addr_linklocal_allrouters))->set($value); break;
            case 'in6addr_linklocal_allv2routers': (new struct_in6_addr($this->ffi->in6addr_linklocal_allv2routers))->set($value); break;
            default: return $this->ffi->$name;
        }
    }
    public function __allocCachedString(string $str): FFI\CData {
        return $this->__literalStrings[$str] ??= string_::ownedZero($str)->getData();
    }
    public function accept(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1, void_ptr | unsigned_int_ptr | null | array $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("unsigned int*", $_2);
            }
        }
        $result = $this->ffi->accept($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_2[$_k];
        }
        return $result;
    }
    public function bind(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $result = $this->ffi->bind($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function connect(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $result = $this->ffi->connect($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function getpeername(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1, void_ptr | unsigned_int_ptr | null | array $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("unsigned int*", $_2);
            }
        }
        $result = $this->ffi->getpeername($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_2[$_k];
        }
        return $result;
    }
    public function getsockname(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1, void_ptr | unsigned_int_ptr | null | array $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("unsigned int*", $_2);
            }
        }
        $result = $this->ffi->getsockname($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_2[$_k];
        }
        return $result;
    }
    public function getsockopt(int $_0, int $_1, int $_2, iQuiche_ptr | null | array $_3, void_ptr | unsigned_int_ptr | null | array $_4): int {
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("void[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("void*", $_3);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("unsigned int*", $_4);
            }
        }
        $result = $this->ffi->getsockopt($_0, $_1, $_2, $_3, $_4);
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_3[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_4[$_k];
        }
        return $result;
    }
    public function listen(int $_0, int $_1): int {
        $result = $this->ffi->listen($_0, $_1);
        return $result;
    }
    public function recv(int $_0, iQuiche_ptr | null | array $_1, int $_2, int $_3): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $result = $this->ffi->recv($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function recvfrom(int $_0, iQuiche_ptr | null | array $_1, int $_2, int $_3, void_ptr | struct_sockaddr_ptr | null | array $_4, void_ptr | unsigned_int_ptr | null | array $_5): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("struct sockaddr*", $_4);
            }
        }
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("unsigned int*", $_5);
            }
        }
        $result = $this->ffi->recvfrom($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_4[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_5[$_k];
        }
        return $result;
    }
    public function recvmsg(int $_0, void_ptr | struct_msghdr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct msghdr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct msghdr*", $_1);
            }
        }
        $result = $this->ffi->recvmsg($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct msghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_msghdr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function send(int $_0, iQuiche_ptr | null | array $_1, int $_2, int $_3): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $result = $this->ffi->send($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function sendmsg(int $_0, void_ptr | struct_msghdr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct msghdr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct msghdr*", $_1);
            }
        }
        $result = $this->ffi->sendmsg($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct msghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_msghdr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function sendto(int $_0, iQuiche_ptr | null | array $_1, int $_2, int $_3, void_ptr | struct_sockaddr_ptr | null | array $_4, int $_5): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("struct sockaddr*", $_4);
            }
        }
        $result = $this->ffi->sendto($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_4[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function setsockopt(int $_0, int $_1, int $_2, iQuiche_ptr | null | array $_3, int $_4): int {
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("void[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("void*", $_3);
            }
        }
        $result = $this->ffi->setsockopt($_0, $_1, $_2, $_3, $_4);
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_3[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function shutdown(int $_0, int $_1): int {
        $result = $this->ffi->shutdown($_0, $_1);
        return $result;
    }
    public function sockatmark(int $_0): int {
        $result = $this->ffi->sockatmark($_0);
        return $result;
    }
    public function socket(int $_0, int $_1, int $_2): int {
        $result = $this->ffi->socket($_0, $_1, $_2);
        return $result;
    }
    public function socketpair(int $_0, int $_1, int $_2, void_ptr | int_ptr | null | array $_3): int {
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("int[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("int*", $_3);
            }
        }
        $result = $this->ffi->socketpair($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_3[$_k];
        }
        return $result;
    }
    public function sendfile(int $_0, int $_1, int $_2, void_ptr | long_long_ptr | null | array $_3, void_ptr | struct_sf_hdtr_ptr | null | array $_4, int $_5): int {
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("long long[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("long long*", $_3);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("struct sf_hdtr[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("struct sf_hdtr*", $_4);
            }
        }
        $result = $this->ffi->sendfile($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_3[$_k];
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sf_hdtr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_4[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sf_hdtr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function connectx(int $_0, void_ptr | struct_sa_endpoints_ptr | null | array $_1, int $_2, int $_3, void_ptr | struct_iovec_ptr | null | array $_4, int $_5, void_ptr | size_t_ptr | null | array $_6, void_ptr | unsigned_int_ptr | null | array $_7): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sa_endpoints[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sa_endpoints*", $_1);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("struct iovec[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("struct iovec*", $_4);
            }
        }
        $__ffi_internal_refs_6 = [];
        if (\is_array($_6)) {
            $_ = $this->ffi->new("size_t[" . \count($_6) . "]");
            $_i = 0;
            if ($_6) {
                if ($_ref = \ReflectionReference::fromArrayElement($_6, \key($_6))) {
                    foreach ($_6 as $_k => $_v) {
                        $__ffi_internal_refs_6[$_i] = &$_6[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_6 = $_6 = $_;
                } else {
                    foreach ($_6 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_6 = $_;
                }
            }
        } else {
            $_6 = $_6?->getData();
            if ($_6 !== null) {
                $_6 = $this->ffi->cast("size_t*", $_6);
            }
        }
        $__ffi_internal_refs_7 = [];
        if (\is_array($_7)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_7) . "]");
            $_i = 0;
            if ($_7) {
                if ($_ref = \ReflectionReference::fromArrayElement($_7, \key($_7))) {
                    foreach ($_7 as $_k => $_v) {
                        $__ffi_internal_refs_7[$_i] = &$_7[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_7 = $_7 = $_;
                } else {
                    foreach ($_7 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_7 = $_;
                }
            }
        } else {
            $_7 = $_7?->getData();
            if ($_7 !== null) {
                $_7 = $this->ffi->cast("unsigned int*", $_7);
            }
        }
        $result = $this->ffi->connectx($_0, $_1, $_2, $_3, $_4, $_5, $_6, $_7);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sa_endpoints");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sa_endpoints($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct iovec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_4[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_iovec($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_6 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_6[$_k];
        }
        foreach ($__ffi_internal_refs_7 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_7[$_k];
        }
        return $result;
    }
    public function disconnectx(int $_0, int $_1, int $_2): int {
        $result = $this->ffi->disconnectx($_0, $_1, $_2);
        return $result;
    }
    public function asctime(void_ptr | struct_tm_ptr | null | array $_0): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct tm[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct tm*", $_0);
            }
        }
        $result = $this->ffi->asctime($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new string_($result);
    }
    public function clock(): int {
        $result = $this->ffi->clock();
        return $result;
    }
    public function ctime(void_ptr | long_ptr | null | array $_0): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $result = $this->ffi->ctime($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        return $result === null ? null : new string_($result);
    }
    public function difftime(int $_0, int $_1): float {
        $result = $this->ffi->difftime($_0, $_1);
        return $result;
    }
    public function getdate(void_ptr | string_ | null | string | array $_0): ?struct_tm_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("char*", $_0);
            }
        }
        $result = $this->ffi->getdate($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result === null ? null : new struct_tm_ptr($result);
    }
    public function gmtime(void_ptr | long_ptr | null | array $_0): ?struct_tm_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $result = $this->ffi->gmtime($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        return $result === null ? null : new struct_tm_ptr($result);
    }
    public function localtime(void_ptr | long_ptr | null | array $_0): ?struct_tm_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $result = $this->ffi->localtime($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        return $result === null ? null : new struct_tm_ptr($result);
    }
    public function mktime(void_ptr | struct_tm_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct tm[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct tm*", $_0);
            }
        }
        $result = $this->ffi->mktime($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function strftime(void_ptr | string_ | null | string | array $_0, int $_1, void_ptr | string_ | null | string | array $_2, void_ptr | struct_tm_ptr | null | array $_3): int {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("char*", $_0);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_string($_2)) {
            $_2 = string_::ownedZero($_2)->getData();
        } elseif (\is_array($_2)) {
            $_ = $this->ffi->new("char[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("char*", $_2);
            }
        }
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("struct tm[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("struct tm*", $_3);
            }
        }
        $result = $this->ffi->strftime($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_2[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_3[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function strptime(void_ptr | string_ | null | string | array $_0, void_ptr | string_ | null | string | array $_1, void_ptr | struct_tm_ptr | null | array $_2): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("char*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_string($_1)) {
            $_1 = string_::ownedZero($_1)->getData();
        } elseif (\is_array($_1)) {
            $_ = $this->ffi->new("char[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("char*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("struct tm[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("struct tm*", $_2);
            }
        }
        $result = $this->ffi->strptime($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new string_($result);
    }
    public function time(void_ptr | long_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $result = $this->ffi->time($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        return $result;
    }
    public function tzset(): void {
        $this->ffi->tzset();
    }
    public function asctime_r(void_ptr | struct_tm_ptr | null | array $_0, void_ptr | string_ | null | string | array $_1): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct tm[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct tm*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_string($_1)) {
            $_1 = string_::ownedZero($_1)->getData();
        } elseif (\is_array($_1)) {
            $_ = $this->ffi->new("char[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("char*", $_1);
            }
        }
        $result = $this->ffi->asctime_r($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result === null ? null : new string_($result);
    }
    public function ctime_r(void_ptr | long_ptr | null | array $_0, void_ptr | string_ | null | string | array $_1): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_string($_1)) {
            $_1 = string_::ownedZero($_1)->getData();
        } elseif (\is_array($_1)) {
            $_ = $this->ffi->new("char[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("char*", $_1);
            }
        }
        $result = $this->ffi->ctime_r($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result === null ? null : new string_($result);
    }
    public function gmtime_r(void_ptr | long_ptr | null | array $_0, void_ptr | struct_tm_ptr | null | array $_1): ?struct_tm_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct tm[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct tm*", $_1);
            }
        }
        $result = $this->ffi->gmtime_r($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_tm_ptr($result);
    }
    public function localtime_r(void_ptr | long_ptr | null | array $_0, void_ptr | struct_tm_ptr | null | array $_1): ?struct_tm_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("long[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("long*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct tm[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct tm*", $_1);
            }
        }
        $result = $this->ffi->localtime_r($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_tm_ptr($result);
    }
    public function posix2time(int $_0): int {
        $result = $this->ffi->posix2time($_0);
        return $result;
    }
    public function tzsetwall(): void {
        $this->ffi->tzsetwall();
    }
    public function time2posix(int $_0): int {
        $result = $this->ffi->time2posix($_0);
        return $result;
    }
    public function timelocal(void_ptr | struct_tm_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct tm[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct tm*", $_0);
            }
        }
        $result = $this->ffi->timelocal($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function timegm(void_ptr | struct_tm_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct tm[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct tm*", $_0);
            }
        }
        $result = $this->ffi->timegm($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct tm");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_tm($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function nanosleep(void_ptr | struct_timespec_ptr | null | array $__rqtp, void_ptr | struct_timespec_ptr | null | array $__rmtp): int {
        $__ffi_internal_refs__rqtp = [];
        if (\is_array($__rqtp)) {
            $_ = $this->ffi->new("struct timespec[" . \count($__rqtp) . "]");
            $_i = 0;
            if ($__rqtp) {
                if ($_ref = \ReflectionReference::fromArrayElement($__rqtp, \key($__rqtp))) {
                    foreach ($__rqtp as $_k => $_v) {
                        $__ffi_internal_refs__rqtp[$_i] = &$__rqtp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original__rqtp = $__rqtp = $_;
                } else {
                    foreach ($__rqtp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $__rqtp = $_;
                }
            }
        } else {
            $__rqtp = $__rqtp?->getData();
            if ($__rqtp !== null) {
                $__rqtp = $this->ffi->cast("struct timespec*", $__rqtp);
            }
        }
        $__ffi_internal_refs__rmtp = [];
        if (\is_array($__rmtp)) {
            $_ = $this->ffi->new("struct timespec[" . \count($__rmtp) . "]");
            $_i = 0;
            if ($__rmtp) {
                if ($_ref = \ReflectionReference::fromArrayElement($__rmtp, \key($__rmtp))) {
                    foreach ($__rmtp as $_k => $_v) {
                        $__ffi_internal_refs__rmtp[$_i] = &$__rmtp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original__rmtp = $__rmtp = $_;
                } else {
                    foreach ($__rmtp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $__rmtp = $_;
                }
            }
        } else {
            $__rmtp = $__rmtp?->getData();
            if ($__rmtp !== null) {
                $__rmtp = $this->ffi->cast("struct timespec*", $__rmtp);
            }
        }
        $result = $this->ffi->nanosleep($__rqtp, $__rmtp);
        foreach ($__ffi_internal_refs__rqtp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original__rqtp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs__rmtp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original__rmtp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function clock_getres(int $__clock_id, void_ptr | struct_timespec_ptr | null | array $__res): int {
        $__ffi_internal_refs__res = [];
        if (\is_array($__res)) {
            $_ = $this->ffi->new("struct timespec[" . \count($__res) . "]");
            $_i = 0;
            if ($__res) {
                if ($_ref = \ReflectionReference::fromArrayElement($__res, \key($__res))) {
                    foreach ($__res as $_k => $_v) {
                        $__ffi_internal_refs__res[$_i] = &$__res[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original__res = $__res = $_;
                } else {
                    foreach ($__res as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $__res = $_;
                }
            }
        } else {
            $__res = $__res?->getData();
            if ($__res !== null) {
                $__res = $this->ffi->cast("struct timespec*", $__res);
            }
        }
        $result = $this->ffi->clock_getres($__clock_id, $__res);
        foreach ($__ffi_internal_refs__res as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original__res[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function clock_gettime(int $__clock_id, void_ptr | struct_timespec_ptr | null | array $__tp): int {
        $__ffi_internal_refs__tp = [];
        if (\is_array($__tp)) {
            $_ = $this->ffi->new("struct timespec[" . \count($__tp) . "]");
            $_i = 0;
            if ($__tp) {
                if ($_ref = \ReflectionReference::fromArrayElement($__tp, \key($__tp))) {
                    foreach ($__tp as $_k => $_v) {
                        $__ffi_internal_refs__tp[$_i] = &$__tp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original__tp = $__tp = $_;
                } else {
                    foreach ($__tp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $__tp = $_;
                }
            }
        } else {
            $__tp = $__tp?->getData();
            if ($__tp !== null) {
                $__tp = $this->ffi->cast("struct timespec*", $__tp);
            }
        }
        $result = $this->ffi->clock_gettime($__clock_id, $__tp);
        foreach ($__ffi_internal_refs__tp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original__tp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function clock_gettime_nsec_np(int $__clock_id): int {
        $result = $this->ffi->clock_gettime_nsec_np($__clock_id);
        return $result;
    }
    public function clock_settime(int $__clock_id, void_ptr | struct_timespec_ptr | null | array $__tp): int {
        $__ffi_internal_refs__tp = [];
        if (\is_array($__tp)) {
            $_ = $this->ffi->new("struct timespec[" . \count($__tp) . "]");
            $_i = 0;
            if ($__tp) {
                if ($_ref = \ReflectionReference::fromArrayElement($__tp, \key($__tp))) {
                    foreach ($__tp as $_k => $_v) {
                        $__ffi_internal_refs__tp[$_i] = &$__tp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original__tp = $__tp = $_;
                } else {
                    foreach ($__tp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $__tp = $_;
                }
            }
        } else {
            $__tp = $__tp?->getData();
            if ($__tp !== null) {
                $__tp = $this->ffi->cast("struct timespec*", $__tp);
            }
        }
        $result = $this->ffi->clock_settime($__clock_id, $__tp);
        foreach ($__ffi_internal_refs__tp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original__tp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function timespec_get(void_ptr | struct_timespec_ptr | null | array $ts, int $base): int {
        $__ffi_internal_refsts = [];
        if (\is_array($ts)) {
            $_ = $this->ffi->new("struct timespec[" . \count($ts) . "]");
            $_i = 0;
            if ($ts) {
                if ($_ref = \ReflectionReference::fromArrayElement($ts, \key($ts))) {
                    foreach ($ts as $_k => $_v) {
                        $__ffi_internal_refsts[$_i] = &$ts[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalts = $ts = $_;
                } else {
                    foreach ($ts as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ts = $_;
                }
            }
        } else {
            $ts = $ts?->getData();
            if ($ts !== null) {
                $ts = $this->ffi->cast("struct timespec*", $ts);
            }
        }
        $result = $this->ffi->timespec_get($ts, $base);
        foreach ($__ffi_internal_refsts as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timespec");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalts[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timespec($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function adjtime(void_ptr | struct_timeval_ptr | null | array $_0, void_ptr | struct_timeval_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct timeval*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct timeval*", $_1);
            }
        }
        $result = $this->ffi->adjtime($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function futimes(int $_0, void_ptr | struct_timeval_ptr | null | array $_1): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct timeval*", $_1);
            }
        }
        $result = $this->ffi->futimes($_0, $_1);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function lutimes(void_ptr | string_ | null | string | array $_0, void_ptr | struct_timeval_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("char*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct timeval*", $_1);
            }
        }
        $result = $this->ffi->lutimes($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function settimeofday(void_ptr | struct_timeval_ptr | null | array $_0, void_ptr | struct_timezone_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct timeval*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct timezone[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct timezone*", $_1);
            }
        }
        $result = $this->ffi->settimeofday($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timezone");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timezone($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function getitimer(int $_0, void_ptr | struct_itimerval_ptr | null | array $_1): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct itimerval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct itimerval*", $_1);
            }
        }
        $result = $this->ffi->getitimer($_0, $_1);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct itimerval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_itimerval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function gettimeofday(void_ptr | struct_timeval_ptr | null | array $_0, iQuiche_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct timeval*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $result = $this->ffi->gettimeofday($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function select(int $_0, void_ptr | struct_fd_set_ptr | null | array $_1, void_ptr | struct_fd_set_ptr | null | array $_2, void_ptr | struct_fd_set_ptr | null | array $_3, void_ptr | struct_timeval_ptr | null | array $_4): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct fd_set*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("struct fd_set*", $_2);
            }
        }
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("struct fd_set*", $_3);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("struct timeval*", $_4);
            }
        }
        $result = $this->ffi->select($_0, $_1, $_2, $_3, $_4);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_3[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_4[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function setitimer(int $_0, void_ptr | struct_itimerval_ptr | null | array $_1, void_ptr | struct_itimerval_ptr | null | array $_2): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct itimerval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct itimerval*", $_1);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("struct itimerval[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("struct itimerval*", $_2);
            }
        }
        $result = $this->ffi->setitimer($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct itimerval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_itimerval($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct itimerval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_itimerval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function utimes(void_ptr | string_ | null | string | array $_0, void_ptr | struct_timeval_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("char*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct timeval[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct timeval*", $_1);
            }
        }
        $result = $this->ffi->utimes($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct timeval");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_timeval($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_version(): ?string_ {
        $result = $this->ffi->quiche_version();
        return $result === null ? null : new string_($result);
    }
    public function quiche_enable_debug_logging(void_ptr | function_type_ptr | null | array $cb, iQuiche_ptr | null | array $argp): int {
        $__ffi_internal_refscb = [];
        if (\is_array($cb)) {
            $_ = $this->ffi->new("function type[" . \count($cb) . "]");
            $_i = 0;
            if ($cb) {
                if ($_ref = \ReflectionReference::fromArrayElement($cb, \key($cb))) {
                    foreach ($cb as $_k => $_v) {
                        $__ffi_internal_refscb[$_i] = &$cb[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalcb = $cb = $_;
                } else {
                    foreach ($cb as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $cb = $_;
                }
            }
        } else {
            $cb = $cb?->getData();
            if ($cb !== null) {
                $cb = $this->ffi->cast("void(*)(char*, void*)", $cb);
            }
        }
        $__ffi_internal_refsargp = [];
        if (\is_array($argp)) {
            $_ = $this->ffi->new("void[" . \count($argp) . "]");
            $_i = 0;
            if ($argp) {
                if ($_ref = \ReflectionReference::fromArrayElement($argp, \key($argp))) {
                    foreach ($argp as $_k => $_v) {
                        $__ffi_internal_refsargp[$_i] = &$argp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalargp = $argp = $_;
                } else {
                    foreach ($argp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $argp = $_;
                }
            }
        } else {
            $argp = $argp?->getData();
            if ($argp !== null) {
                $argp = $this->ffi->cast("void*", $argp);
            }
        }
        $result = $this->ffi->quiche_enable_debug_logging($cb, $argp);
        foreach ($__ffi_internal_refscb as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("function type");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalcb[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new function_type($__ffi_internal_ref_v, [NULL, 'string_', 'void_ptr']);
            }
        }
        foreach ($__ffi_internal_refsargp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalargp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_config_new(int $version): ?struct_quiche_config_ptr {
        $result = $this->ffi->quiche_config_new($version);
        return $result === null ? null : new struct_quiche_config_ptr($result);
    }
    public function quiche_config_load_cert_chain_from_pem_file(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | string_ | null | string | array $path): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $result = $this->ffi->quiche_config_load_cert_chain_from_pem_file($config, $path);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_config_load_priv_key_from_pem_file(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | string_ | null | string | array $path): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $result = $this->ffi->quiche_config_load_priv_key_from_pem_file($config, $path);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_config_load_verify_locations_from_file(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | string_ | null | string | array $path): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $result = $this->ffi->quiche_config_load_verify_locations_from_file($config, $path);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_config_load_verify_locations_from_directory(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | string_ | null | string | array $path): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $result = $this->ffi->quiche_config_load_verify_locations_from_directory($config, $path);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_config_verify_peer(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_verify_peer($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_grease(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_grease($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_log_keys(void_ptr | struct_quiche_config_ptr | null | array $config): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_log_keys($config);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_enable_early_data(void_ptr | struct_quiche_config_ptr | null | array $config): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_enable_early_data($config);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_application_protos(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | uint8_t_ptr | null | string | array $protos, int $protos_len): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refsprotos = [];
        if (\is_string($protos)) {
            $__ffi_str_protos = string_::ownedZero($protos)->getData();
            $protos = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_protos));
        } elseif (\is_array($protos)) {
            $_ = $this->ffi->new("uint8_t[" . \count($protos) . "]");
            $_i = 0;
            if ($protos) {
                if ($_ref = \ReflectionReference::fromArrayElement($protos, \key($protos))) {
                    foreach ($protos as $_k => $_v) {
                        $__ffi_internal_refsprotos[$_i] = &$protos[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalprotos = $protos = $_;
                } else {
                    foreach ($protos as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $protos = $_;
                }
            }
        } else {
            $protos = $protos?->getData();
            if ($protos !== null) {
                $protos = $this->ffi->cast("uint8_t*", $protos);
            }
        }
        $result = $this->ffi->quiche_config_set_application_protos($config, $protos, $protos_len);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsprotos as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalprotos[$_k];
        }
        return $result;
    }
    public function quiche_config_set_max_idle_timeout(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_idle_timeout($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_recv_udp_payload_size(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_recv_udp_payload_size($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_send_udp_payload_size(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_send_udp_payload_size($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_data(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_data($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_stream_data_bidi_local(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_stream_data_bidi_local($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_stream_data_bidi_remote(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_stream_data_bidi_remote($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_stream_data_uni(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_stream_data_uni($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_streams_bidi(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_streams_bidi($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_initial_max_streams_uni(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_max_streams_uni($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_ack_delay_exponent(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_ack_delay_exponent($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_ack_delay(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_ack_delay($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_disable_active_migration(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_disable_active_migration($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_cc_algorithm_name(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | string_ | null | string | array $algo): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refsalgo = [];
        if (\is_string($algo)) {
            $algo = string_::ownedZero($algo)->getData();
        } elseif (\is_array($algo)) {
            $_ = $this->ffi->new("char[" . \count($algo) . "]");
            $_i = 0;
            if ($algo) {
                if ($_ref = \ReflectionReference::fromArrayElement($algo, \key($algo))) {
                    foreach ($algo as $_k => $_v) {
                        $__ffi_internal_refsalgo[$_i] = &$algo[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalalgo = $algo = $_;
                } else {
                    foreach ($algo as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $algo = $_;
                }
            }
        } else {
            $algo = $algo?->getData();
            if ($algo !== null) {
                $algo = $this->ffi->cast("char*", $algo);
            }
        }
        $result = $this->ffi->quiche_config_set_cc_algorithm_name($config, $algo);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsalgo as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalalgo[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_config_set_initial_congestion_window_packets(void_ptr | struct_quiche_config_ptr | null | array $config, int $packets): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_initial_congestion_window_packets($config, $packets);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_cc_algorithm(void_ptr | struct_quiche_config_ptr | null | array $config, int $algo): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_cc_algorithm($config, $algo);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_enable_hystart(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_enable_hystart($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_enable_pacing(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_enable_pacing($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_pacing_rate(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_pacing_rate($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_enable_dgram(void_ptr | struct_quiche_config_ptr | null | array $config, int $enabled, int $recv_queue_len, int $send_queue_len): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_enable_dgram($config, $enabled, $recv_queue_len, $send_queue_len);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_connection_window(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_connection_window($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_max_stream_window(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_max_stream_window($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_active_connection_id_limit(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_active_connection_id_limit($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_stateless_reset_token(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | uint8_t_ptr | null | string | array $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refsv = [];
        if (\is_string($v)) {
            $__ffi_str_v = string_::ownedZero($v)->getData();
            $v = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_v));
        } elseif (\is_array($v)) {
            $_ = $this->ffi->new("uint8_t[" . \count($v) . "]");
            $_i = 0;
            if ($v) {
                if ($_ref = \ReflectionReference::fromArrayElement($v, \key($v))) {
                    foreach ($v as $_k => $_v) {
                        $__ffi_internal_refsv[$_i] = &$v[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalv = $v = $_;
                } else {
                    foreach ($v as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $v = $_;
                }
            }
        } else {
            $v = $v?->getData();
            if ($v !== null) {
                $v = $this->ffi->cast("uint8_t*", $v);
            }
        }
        $this->ffi->quiche_config_set_stateless_reset_token($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsv as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalv[$_k];
        }
    }
    public function quiche_config_set_disable_dcid_reuse(void_ptr | struct_quiche_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_set_disable_dcid_reuse($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_config_set_ticket_key(void_ptr | struct_quiche_config_ptr | null | array $config, void_ptr | uint8_t_ptr | null | string | array $key, int $key_len): int {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refskey = [];
        if (\is_string($key)) {
            $__ffi_str_key = string_::ownedZero($key)->getData();
            $key = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_key));
        } elseif (\is_array($key)) {
            $_ = $this->ffi->new("uint8_t[" . \count($key) . "]");
            $_i = 0;
            if ($key) {
                if ($_ref = \ReflectionReference::fromArrayElement($key, \key($key))) {
                    foreach ($key as $_k => $_v) {
                        $__ffi_internal_refskey[$_i] = &$key[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalkey = $key = $_;
                } else {
                    foreach ($key as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $key = $_;
                }
            }
        } else {
            $key = $key?->getData();
            if ($key !== null) {
                $key = $this->ffi->cast("uint8_t*", $key);
            }
        }
        $result = $this->ffi->quiche_config_set_ticket_key($config, $key, $key_len);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refskey as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalkey[$_k];
        }
        return $result;
    }
    public function quiche_config_free(void_ptr | struct_quiche_config_ptr | null | array $config): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $this->ffi->quiche_config_free($config);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_header_info(void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len, int $dcil, void_ptr | uint32_t_ptr | null | array $version, void_ptr | uint8_t_ptr | null | string | array $type, void_ptr | uint8_t_ptr | null | string | array $scid, void_ptr | size_t_ptr | null | array $scid_len, void_ptr | uint8_t_ptr | null | string | array $dcid, void_ptr | size_t_ptr | null | array $dcid_len, void_ptr | uint8_t_ptr | null | string | array $token, void_ptr | size_t_ptr | null | array $token_len): int {
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $__ffi_internal_refsversion = [];
        if (\is_array($version)) {
            $_ = $this->ffi->new("uint32_t[" . \count($version) . "]");
            $_i = 0;
            if ($version) {
                if ($_ref = \ReflectionReference::fromArrayElement($version, \key($version))) {
                    foreach ($version as $_k => $_v) {
                        $__ffi_internal_refsversion[$_i] = &$version[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalversion = $version = $_;
                } else {
                    foreach ($version as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $version = $_;
                }
            }
        } else {
            $version = $version?->getData();
            if ($version !== null) {
                $version = $this->ffi->cast("uint32_t*", $version);
            }
        }
        $__ffi_internal_refstype = [];
        if (\is_string($type)) {
            $__ffi_str_type = string_::ownedZero($type)->getData();
            $type = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_type));
        } elseif (\is_array($type)) {
            $_ = $this->ffi->new("uint8_t[" . \count($type) . "]");
            $_i = 0;
            if ($type) {
                if ($_ref = \ReflectionReference::fromArrayElement($type, \key($type))) {
                    foreach ($type as $_k => $_v) {
                        $__ffi_internal_refstype[$_i] = &$type[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaltype = $type = $_;
                } else {
                    foreach ($type as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $type = $_;
                }
            }
        } else {
            $type = $type?->getData();
            if ($type !== null) {
                $type = $this->ffi->cast("uint8_t*", $type);
            }
        }
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsscid_len = [];
        if (\is_array($scid_len)) {
            $_ = $this->ffi->new("size_t[" . \count($scid_len) . "]");
            $_i = 0;
            if ($scid_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid_len, \key($scid_len))) {
                    foreach ($scid_len as $_k => $_v) {
                        $__ffi_internal_refsscid_len[$_i] = &$scid_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid_len = $scid_len = $_;
                } else {
                    foreach ($scid_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid_len = $_;
                }
            }
        } else {
            $scid_len = $scid_len?->getData();
            if ($scid_len !== null) {
                $scid_len = $this->ffi->cast("size_t*", $scid_len);
            }
        }
        $__ffi_internal_refsdcid = [];
        if (\is_string($dcid)) {
            $__ffi_str_dcid = string_::ownedZero($dcid)->getData();
            $dcid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_dcid));
        } elseif (\is_array($dcid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($dcid) . "]");
            $_i = 0;
            if ($dcid) {
                if ($_ref = \ReflectionReference::fromArrayElement($dcid, \key($dcid))) {
                    foreach ($dcid as $_k => $_v) {
                        $__ffi_internal_refsdcid[$_i] = &$dcid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaldcid = $dcid = $_;
                } else {
                    foreach ($dcid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $dcid = $_;
                }
            }
        } else {
            $dcid = $dcid?->getData();
            if ($dcid !== null) {
                $dcid = $this->ffi->cast("uint8_t*", $dcid);
            }
        }
        $__ffi_internal_refsdcid_len = [];
        if (\is_array($dcid_len)) {
            $_ = $this->ffi->new("size_t[" . \count($dcid_len) . "]");
            $_i = 0;
            if ($dcid_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($dcid_len, \key($dcid_len))) {
                    foreach ($dcid_len as $_k => $_v) {
                        $__ffi_internal_refsdcid_len[$_i] = &$dcid_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaldcid_len = $dcid_len = $_;
                } else {
                    foreach ($dcid_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $dcid_len = $_;
                }
            }
        } else {
            $dcid_len = $dcid_len?->getData();
            if ($dcid_len !== null) {
                $dcid_len = $this->ffi->cast("size_t*", $dcid_len);
            }
        }
        $__ffi_internal_refstoken = [];
        if (\is_string($token)) {
            $__ffi_str_token = string_::ownedZero($token)->getData();
            $token = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_token));
        } elseif (\is_array($token)) {
            $_ = $this->ffi->new("uint8_t[" . \count($token) . "]");
            $_i = 0;
            if ($token) {
                if ($_ref = \ReflectionReference::fromArrayElement($token, \key($token))) {
                    foreach ($token as $_k => $_v) {
                        $__ffi_internal_refstoken[$_i] = &$token[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaltoken = $token = $_;
                } else {
                    foreach ($token as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $token = $_;
                }
            }
        } else {
            $token = $token?->getData();
            if ($token !== null) {
                $token = $this->ffi->cast("uint8_t*", $token);
            }
        }
        $__ffi_internal_refstoken_len = [];
        if (\is_array($token_len)) {
            $_ = $this->ffi->new("size_t[" . \count($token_len) . "]");
            $_i = 0;
            if ($token_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($token_len, \key($token_len))) {
                    foreach ($token_len as $_k => $_v) {
                        $__ffi_internal_refstoken_len[$_i] = &$token_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaltoken_len = $token_len = $_;
                } else {
                    foreach ($token_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $token_len = $_;
                }
            }
        } else {
            $token_len = $token_len?->getData();
            if ($token_len !== null) {
                $token_len = $this->ffi->cast("size_t*", $token_len);
            }
        }
        $result = $this->ffi->quiche_header_info($buf, $buf_len, $dcil, $version, $type, $scid, $scid_len, $dcid, $dcid_len, $token, $token_len);
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        foreach ($__ffi_internal_refsversion as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalversion[$_k];
        }
        foreach ($__ffi_internal_refstype as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaltype[$_k];
        }
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsscid_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid_len[$_k];
        }
        foreach ($__ffi_internal_refsdcid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaldcid[$_k];
        }
        foreach ($__ffi_internal_refsdcid_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaldcid_len[$_k];
        }
        foreach ($__ffi_internal_refstoken as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaltoken[$_k];
        }
        foreach ($__ffi_internal_refstoken_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaltoken_len[$_k];
        }
        return $result;
    }
    public function quiche_accept(void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | uint8_t_ptr | null | string | array $odcid, int $odcid_len, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len, void_ptr | struct_quiche_config_ptr | null | array $config): ?struct_quiche_conn_ptr {
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsodcid = [];
        if (\is_string($odcid)) {
            $__ffi_str_odcid = string_::ownedZero($odcid)->getData();
            $odcid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_odcid));
        } elseif (\is_array($odcid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($odcid) . "]");
            $_i = 0;
            if ($odcid) {
                if ($_ref = \ReflectionReference::fromArrayElement($odcid, \key($odcid))) {
                    foreach ($odcid as $_k => $_v) {
                        $__ffi_internal_refsodcid[$_i] = &$odcid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalodcid = $odcid = $_;
                } else {
                    foreach ($odcid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $odcid = $_;
                }
            }
        } else {
            $odcid = $odcid?->getData();
            if ($odcid !== null) {
                $odcid = $this->ffi->cast("uint8_t*", $odcid);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $result = $this->ffi->quiche_accept($scid, $scid_len, $odcid, $odcid_len, $local, $local_len, $peer, $peer_len, $config);
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsodcid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalodcid[$_k];
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_conn_ptr($result);
    }
    public function quiche_connect(void_ptr | string_ | null | string | array $server_name, void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len, void_ptr | struct_quiche_config_ptr | null | array $config): ?struct_quiche_conn_ptr {
        $__ffi_internal_refsserver_name = [];
        if (\is_string($server_name)) {
            $server_name = string_::ownedZero($server_name)->getData();
        } elseif (\is_array($server_name)) {
            $_ = $this->ffi->new("char[" . \count($server_name) . "]");
            $_i = 0;
            if ($server_name) {
                if ($_ref = \ReflectionReference::fromArrayElement($server_name, \key($server_name))) {
                    foreach ($server_name as $_k => $_v) {
                        $__ffi_internal_refsserver_name[$_i] = &$server_name[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalserver_name = $server_name = $_;
                } else {
                    foreach ($server_name as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $server_name = $_;
                }
            }
        } else {
            $server_name = $server_name?->getData();
            if ($server_name !== null) {
                $server_name = $this->ffi->cast("char*", $server_name);
            }
        }
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $result = $this->ffi->quiche_connect($server_name, $scid, $scid_len, $local, $local_len, $peer, $peer_len, $config);
        foreach ($__ffi_internal_refsserver_name as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalserver_name[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_conn_ptr($result);
    }
    public function quiche_negotiate_version(void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | uint8_t_ptr | null | string | array $dcid, int $dcid_len, void_ptr | uint8_t_ptr | null | string | array $out, int $out_len): int {
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsdcid = [];
        if (\is_string($dcid)) {
            $__ffi_str_dcid = string_::ownedZero($dcid)->getData();
            $dcid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_dcid));
        } elseif (\is_array($dcid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($dcid) . "]");
            $_i = 0;
            if ($dcid) {
                if ($_ref = \ReflectionReference::fromArrayElement($dcid, \key($dcid))) {
                    foreach ($dcid as $_k => $_v) {
                        $__ffi_internal_refsdcid[$_i] = &$dcid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaldcid = $dcid = $_;
                } else {
                    foreach ($dcid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $dcid = $_;
                }
            }
        } else {
            $dcid = $dcid?->getData();
            if ($dcid !== null) {
                $dcid = $this->ffi->cast("uint8_t*", $dcid);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $result = $this->ffi->quiche_negotiate_version($scid, $scid_len, $dcid, $dcid_len, $out, $out_len);
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsdcid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaldcid[$_k];
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        return $result;
    }
    public function quiche_retry(void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | uint8_t_ptr | null | string | array $dcid, int $dcid_len, void_ptr | uint8_t_ptr | null | string | array $new_scid, int $new_scid_len, void_ptr | uint8_t_ptr | null | string | array $token, int $token_len, int $version, void_ptr | uint8_t_ptr | null | string | array $out, int $out_len): int {
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsdcid = [];
        if (\is_string($dcid)) {
            $__ffi_str_dcid = string_::ownedZero($dcid)->getData();
            $dcid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_dcid));
        } elseif (\is_array($dcid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($dcid) . "]");
            $_i = 0;
            if ($dcid) {
                if ($_ref = \ReflectionReference::fromArrayElement($dcid, \key($dcid))) {
                    foreach ($dcid as $_k => $_v) {
                        $__ffi_internal_refsdcid[$_i] = &$dcid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaldcid = $dcid = $_;
                } else {
                    foreach ($dcid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $dcid = $_;
                }
            }
        } else {
            $dcid = $dcid?->getData();
            if ($dcid !== null) {
                $dcid = $this->ffi->cast("uint8_t*", $dcid);
            }
        }
        $__ffi_internal_refsnew_scid = [];
        if (\is_string($new_scid)) {
            $__ffi_str_new_scid = string_::ownedZero($new_scid)->getData();
            $new_scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_new_scid));
        } elseif (\is_array($new_scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($new_scid) . "]");
            $_i = 0;
            if ($new_scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($new_scid, \key($new_scid))) {
                    foreach ($new_scid as $_k => $_v) {
                        $__ffi_internal_refsnew_scid[$_i] = &$new_scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalnew_scid = $new_scid = $_;
                } else {
                    foreach ($new_scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $new_scid = $_;
                }
            }
        } else {
            $new_scid = $new_scid?->getData();
            if ($new_scid !== null) {
                $new_scid = $this->ffi->cast("uint8_t*", $new_scid);
            }
        }
        $__ffi_internal_refstoken = [];
        if (\is_string($token)) {
            $__ffi_str_token = string_::ownedZero($token)->getData();
            $token = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_token));
        } elseif (\is_array($token)) {
            $_ = $this->ffi->new("uint8_t[" . \count($token) . "]");
            $_i = 0;
            if ($token) {
                if ($_ref = \ReflectionReference::fromArrayElement($token, \key($token))) {
                    foreach ($token as $_k => $_v) {
                        $__ffi_internal_refstoken[$_i] = &$token[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originaltoken = $token = $_;
                } else {
                    foreach ($token as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $token = $_;
                }
            }
        } else {
            $token = $token?->getData();
            if ($token !== null) {
                $token = $this->ffi->cast("uint8_t*", $token);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $result = $this->ffi->quiche_retry($scid, $scid_len, $dcid, $dcid_len, $new_scid, $new_scid_len, $token, $token_len, $version, $out, $out_len);
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsdcid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaldcid[$_k];
        }
        foreach ($__ffi_internal_refsnew_scid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalnew_scid[$_k];
        }
        foreach ($__ffi_internal_refstoken as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaltoken[$_k];
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        return $result;
    }
    public function quiche_version_is_supported(int $version): int {
        $result = $this->ffi->quiche_version_is_supported($version);
        return $result;
    }
    public function quiche_conn_new_with_tls(void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | uint8_t_ptr | null | string | array $odcid, int $odcid_len, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len, void_ptr | struct_quiche_config_ptr | null | array $config, iQuiche_ptr | null | array $ssl, int $is_server): ?struct_quiche_conn_ptr {
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsodcid = [];
        if (\is_string($odcid)) {
            $__ffi_str_odcid = string_::ownedZero($odcid)->getData();
            $odcid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_odcid));
        } elseif (\is_array($odcid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($odcid) . "]");
            $_i = 0;
            if ($odcid) {
                if ($_ref = \ReflectionReference::fromArrayElement($odcid, \key($odcid))) {
                    foreach ($odcid as $_k => $_v) {
                        $__ffi_internal_refsodcid[$_i] = &$odcid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalodcid = $odcid = $_;
                } else {
                    foreach ($odcid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $odcid = $_;
                }
            }
        } else {
            $odcid = $odcid?->getData();
            if ($odcid !== null) {
                $odcid = $this->ffi->cast("uint8_t*", $odcid);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_config*", $config);
            }
        }
        $__ffi_internal_refsssl = [];
        if (\is_array($ssl)) {
            $_ = $this->ffi->new("void[" . \count($ssl) . "]");
            $_i = 0;
            if ($ssl) {
                if ($_ref = \ReflectionReference::fromArrayElement($ssl, \key($ssl))) {
                    foreach ($ssl as $_k => $_v) {
                        $__ffi_internal_refsssl[$_i] = &$ssl[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalssl = $ssl = $_;
                } else {
                    foreach ($ssl as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ssl = $_;
                }
            }
        } else {
            $ssl = $ssl?->getData();
            if ($ssl !== null) {
                $ssl = $this->ffi->cast("void*", $ssl);
            }
        }
        $result = $this->ffi->quiche_conn_new_with_tls($scid, $scid_len, $odcid, $odcid_len, $local, $local_len, $peer, $peer_len, $config, $ssl, $is_server);
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsodcid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalodcid[$_k];
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_config($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsssl as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalssl[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_conn_ptr($result);
    }
    public function quiche_conn_set_keylog_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | string_ | null | string | array $path): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $result = $this->ffi->quiche_conn_set_keylog_path($conn, $path);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_conn_set_keylog_fd(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $fd): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $this->ffi->quiche_conn_set_keylog_fd($conn, $fd);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_set_qlog_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | string_ | null | string | array $path, void_ptr | string_ | null | string | array $log_title, void_ptr | string_ | null | string | array $log_desc): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refspath = [];
        if (\is_string($path)) {
            $path = string_::ownedZero($path)->getData();
        } elseif (\is_array($path)) {
            $_ = $this->ffi->new("char[" . \count($path) . "]");
            $_i = 0;
            if ($path) {
                if ($_ref = \ReflectionReference::fromArrayElement($path, \key($path))) {
                    foreach ($path as $_k => $_v) {
                        $__ffi_internal_refspath[$_i] = &$path[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpath = $path = $_;
                } else {
                    foreach ($path as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $path = $_;
                }
            }
        } else {
            $path = $path?->getData();
            if ($path !== null) {
                $path = $this->ffi->cast("char*", $path);
            }
        }
        $__ffi_internal_refslog_title = [];
        if (\is_string($log_title)) {
            $log_title = string_::ownedZero($log_title)->getData();
        } elseif (\is_array($log_title)) {
            $_ = $this->ffi->new("char[" . \count($log_title) . "]");
            $_i = 0;
            if ($log_title) {
                if ($_ref = \ReflectionReference::fromArrayElement($log_title, \key($log_title))) {
                    foreach ($log_title as $_k => $_v) {
                        $__ffi_internal_refslog_title[$_i] = &$log_title[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallog_title = $log_title = $_;
                } else {
                    foreach ($log_title as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $log_title = $_;
                }
            }
        } else {
            $log_title = $log_title?->getData();
            if ($log_title !== null) {
                $log_title = $this->ffi->cast("char*", $log_title);
            }
        }
        $__ffi_internal_refslog_desc = [];
        if (\is_string($log_desc)) {
            $log_desc = string_::ownedZero($log_desc)->getData();
        } elseif (\is_array($log_desc)) {
            $_ = $this->ffi->new("char[" . \count($log_desc) . "]");
            $_i = 0;
            if ($log_desc) {
                if ($_ref = \ReflectionReference::fromArrayElement($log_desc, \key($log_desc))) {
                    foreach ($log_desc as $_k => $_v) {
                        $__ffi_internal_refslog_desc[$_i] = &$log_desc[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallog_desc = $log_desc = $_;
                } else {
                    foreach ($log_desc as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $log_desc = $_;
                }
            }
        } else {
            $log_desc = $log_desc?->getData();
            if ($log_desc !== null) {
                $log_desc = $this->ffi->cast("char*", $log_desc);
            }
        }
        $result = $this->ffi->quiche_conn_set_qlog_path($conn, $path, $log_title, $log_desc);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspath as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpath[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refslog_title as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallog_title[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refslog_desc as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallog_desc[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        return $result;
    }
    public function quiche_conn_set_qlog_fd(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $fd, void_ptr | string_ | null | string | array $log_title, void_ptr | string_ | null | string | array $log_desc): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslog_title = [];
        if (\is_string($log_title)) {
            $log_title = string_::ownedZero($log_title)->getData();
        } elseif (\is_array($log_title)) {
            $_ = $this->ffi->new("char[" . \count($log_title) . "]");
            $_i = 0;
            if ($log_title) {
                if ($_ref = \ReflectionReference::fromArrayElement($log_title, \key($log_title))) {
                    foreach ($log_title as $_k => $_v) {
                        $__ffi_internal_refslog_title[$_i] = &$log_title[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallog_title = $log_title = $_;
                } else {
                    foreach ($log_title as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $log_title = $_;
                }
            }
        } else {
            $log_title = $log_title?->getData();
            if ($log_title !== null) {
                $log_title = $this->ffi->cast("char*", $log_title);
            }
        }
        $__ffi_internal_refslog_desc = [];
        if (\is_string($log_desc)) {
            $log_desc = string_::ownedZero($log_desc)->getData();
        } elseif (\is_array($log_desc)) {
            $_ = $this->ffi->new("char[" . \count($log_desc) . "]");
            $_i = 0;
            if ($log_desc) {
                if ($_ref = \ReflectionReference::fromArrayElement($log_desc, \key($log_desc))) {
                    foreach ($log_desc as $_k => $_v) {
                        $__ffi_internal_refslog_desc[$_i] = &$log_desc[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallog_desc = $log_desc = $_;
                } else {
                    foreach ($log_desc as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $log_desc = $_;
                }
            }
        } else {
            $log_desc = $log_desc?->getData();
            if ($log_desc !== null) {
                $log_desc = $this->ffi->cast("char*", $log_desc);
            }
        }
        $this->ffi->quiche_conn_set_qlog_fd($conn, $fd, $log_title, $log_desc);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslog_title as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallog_title[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
        foreach ($__ffi_internal_refslog_desc as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallog_desc[$_k];
                $__ffi_internal_ref_v = \ord($__ffi_internal_ref_v);
        }
    }
    public function quiche_conn_set_session(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $result = $this->ffi->quiche_conn_set_session($conn, $buf, $buf_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        return $result;
    }
    public function quiche_conn_recv(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len, void_ptr | quiche_recv_info_ptr | null | array $info): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $__ffi_internal_refsinfo = [];
        if (\is_array($info)) {
            $_ = $this->ffi->new("quiche_recv_info[" . \count($info) . "]");
            $_i = 0;
            if ($info) {
                if ($_ref = \ReflectionReference::fromArrayElement($info, \key($info))) {
                    foreach ($info as $_k => $_v) {
                        $__ffi_internal_refsinfo[$_i] = &$info[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalinfo = $info = $_;
                } else {
                    foreach ($info as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $info = $_;
                }
            }
        } else {
            $info = $info?->getData();
            if ($info !== null) {
                $info = $this->ffi->cast("quiche_recv_info*", $info);
            }
        }
        $result = $this->ffi->quiche_conn_recv($conn, $buf, $buf_len, $info);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        foreach ($__ffi_internal_refsinfo as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_recv_info");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalinfo[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_recv_info($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $out, int $out_len, void_ptr | quiche_send_info_ptr | null | array $out_info): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $__ffi_internal_refsout_info = [];
        if (\is_array($out_info)) {
            $_ = $this->ffi->new("quiche_send_info[" . \count($out_info) . "]");
            $_i = 0;
            if ($out_info) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_info, \key($out_info))) {
                    foreach ($out_info as $_k => $_v) {
                        $__ffi_internal_refsout_info[$_i] = &$out_info[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalout_info = $out_info = $_;
                } else {
                    foreach ($out_info as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out_info = $_;
                }
            }
        } else {
            $out_info = $out_info?->getData();
            if ($out_info !== null) {
                $out_info = $this->ffi->cast("quiche_send_info*", $out_info);
            }
        }
        $result = $this->ffi->quiche_conn_send($conn, $out, $out_len, $out_info);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        foreach ($__ffi_internal_refsout_info as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_send_info");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalout_info[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_send_info($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send_quantum(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_send_quantum($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send_on_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $out, int $out_len, void_ptr | struct_sockaddr_ptr | null | array $from, int $from_len, void_ptr | struct_sockaddr_ptr | null | array $to, int $to_len, void_ptr | quiche_send_info_ptr | null | array $out_info): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $__ffi_internal_refsfrom = [];
        if (\is_array($from)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($from) . "]");
            $_i = 0;
            if ($from) {
                if ($_ref = \ReflectionReference::fromArrayElement($from, \key($from))) {
                    foreach ($from as $_k => $_v) {
                        $__ffi_internal_refsfrom[$_i] = &$from[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalfrom = $from = $_;
                } else {
                    foreach ($from as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $from = $_;
                }
            }
        } else {
            $from = $from?->getData();
            if ($from !== null) {
                $from = $this->ffi->cast("struct sockaddr*", $from);
            }
        }
        $__ffi_internal_refsto = [];
        if (\is_array($to)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($to) . "]");
            $_i = 0;
            if ($to) {
                if ($_ref = \ReflectionReference::fromArrayElement($to, \key($to))) {
                    foreach ($to as $_k => $_v) {
                        $__ffi_internal_refsto[$_i] = &$to[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalto = $to = $_;
                } else {
                    foreach ($to as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $to = $_;
                }
            }
        } else {
            $to = $to?->getData();
            if ($to !== null) {
                $to = $this->ffi->cast("struct sockaddr*", $to);
            }
        }
        $__ffi_internal_refsout_info = [];
        if (\is_array($out_info)) {
            $_ = $this->ffi->new("quiche_send_info[" . \count($out_info) . "]");
            $_i = 0;
            if ($out_info) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_info, \key($out_info))) {
                    foreach ($out_info as $_k => $_v) {
                        $__ffi_internal_refsout_info[$_i] = &$out_info[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalout_info = $out_info = $_;
                } else {
                    foreach ($out_info as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out_info = $_;
                }
            }
        } else {
            $out_info = $out_info?->getData();
            if ($out_info !== null) {
                $out_info = $this->ffi->cast("quiche_send_info*", $out_info);
            }
        }
        $result = $this->ffi->quiche_conn_send_on_path($conn, $out, $out_len, $from, $from_len, $to, $to_len, $out_info);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        foreach ($__ffi_internal_refsfrom as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalfrom[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsto as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalto[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_info as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_send_info");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalout_info[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_send_info($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send_quantum_on_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $local_addr, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer_addr, int $peer_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslocal_addr = [];
        if (\is_array($local_addr)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local_addr) . "]");
            $_i = 0;
            if ($local_addr) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_addr, \key($local_addr))) {
                    foreach ($local_addr as $_k => $_v) {
                        $__ffi_internal_refslocal_addr[$_i] = &$local_addr[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal_addr = $local_addr = $_;
                } else {
                    foreach ($local_addr as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local_addr = $_;
                }
            }
        } else {
            $local_addr = $local_addr?->getData();
            if ($local_addr !== null) {
                $local_addr = $this->ffi->cast("struct sockaddr*", $local_addr);
            }
        }
        $__ffi_internal_refspeer_addr = [];
        if (\is_array($peer_addr)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer_addr) . "]");
            $_i = 0;
            if ($peer_addr) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_addr, \key($peer_addr))) {
                    foreach ($peer_addr as $_k => $_v) {
                        $__ffi_internal_refspeer_addr[$_i] = &$peer_addr[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer_addr = $peer_addr = $_;
                } else {
                    foreach ($peer_addr as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer_addr = $_;
                }
            }
        } else {
            $peer_addr = $peer_addr?->getData();
            if ($peer_addr !== null) {
                $peer_addr = $this->ffi->cast("struct sockaddr*", $peer_addr);
            }
        }
        $result = $this->ffi->quiche_conn_send_quantum_on_path($conn, $local_addr, $local_len, $peer_addr, $peer_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_addr as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal_addr[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_addr as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer_addr[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_recv(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id, void_ptr | uint8_t_ptr | null | string | array $out, int $buf_len, void_ptr | _Bool_ptr | null | array $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $__ffi_internal_refsfin = [];
        if (\is_array($fin)) {
            $_ = $this->ffi->new("_Bool[" . \count($fin) . "]");
            $_i = 0;
            if ($fin) {
                if ($_ref = \ReflectionReference::fromArrayElement($fin, \key($fin))) {
                    foreach ($fin as $_k => $_v) {
                        $__ffi_internal_refsfin[$_i] = &$fin[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalfin = $fin = $_;
                } else {
                    foreach ($fin as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $fin = $_;
                }
            }
        } else {
            $fin = $fin?->getData();
            if ($fin !== null) {
                $fin = $this->ffi->cast("_Bool*", $fin);
            }
        }
        $result = $this->ffi->quiche_conn_stream_recv($conn, $stream_id, $out, $buf_len, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        foreach ($__ffi_internal_refsfin as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalfin[$_k];
        }
        return $result;
    }
    public function quiche_conn_stream_send(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id, void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len, int $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $result = $this->ffi->quiche_conn_stream_send($conn, $stream_id, $buf, $buf_len, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        return $result;
    }
    public function quiche_conn_stream_priority(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id, int $urgency, int $incremental): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_priority($conn, $stream_id, $urgency, $incremental);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_shutdown(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id, int $direction, int $err): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_shutdown($conn, $stream_id, $direction, $err);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_capacity(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_capacity($conn, $stream_id);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_readable(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_readable($conn, $stream_id);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_readable_next(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_readable_next($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_writable(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id, int $len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_writable($conn, $stream_id, $len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_writable_next(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_writable_next($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_stream_finished(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $stream_id): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_stream_finished($conn, $stream_id);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_readable(void_ptr | struct_quiche_conn_ptr | null | array $conn): ?struct_quiche_stream_iter_ptr {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_readable($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_stream_iter_ptr($result);
    }
    public function quiche_conn_writable(void_ptr | struct_quiche_conn_ptr | null | array $conn): ?struct_quiche_stream_iter_ptr {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_writable($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_stream_iter_ptr($result);
    }
    public function quiche_conn_max_send_udp_payload_size(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_max_send_udp_payload_size($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_timeout_as_nanos(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_timeout_as_nanos($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_timeout_as_millis(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_timeout_as_millis($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_on_timeout(void_ptr | struct_quiche_conn_ptr | null | array $conn): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $this->ffi->quiche_conn_on_timeout($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_close(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $app, int $err, void_ptr | uint8_t_ptr | null | string | array $reason, int $reason_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsreason = [];
        if (\is_string($reason)) {
            $__ffi_str_reason = string_::ownedZero($reason)->getData();
            $reason = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_reason));
        } elseif (\is_array($reason)) {
            $_ = $this->ffi->new("uint8_t[" . \count($reason) . "]");
            $_i = 0;
            if ($reason) {
                if ($_ref = \ReflectionReference::fromArrayElement($reason, \key($reason))) {
                    foreach ($reason as $_k => $_v) {
                        $__ffi_internal_refsreason[$_i] = &$reason[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalreason = $reason = $_;
                } else {
                    foreach ($reason as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $reason = $_;
                }
            }
        } else {
            $reason = $reason?->getData();
            if ($reason !== null) {
                $reason = $this->ffi->cast("uint8_t*", $reason);
            }
        }
        $result = $this->ffi->quiche_conn_close($conn, $app, $err, $reason, $reason_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsreason as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreason[$_k];
        }
        return $result;
    }
    public function quiche_conn_trace_id(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_trace_id($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_source_id(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_source_id($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_source_ids(void_ptr | struct_quiche_conn_ptr | null | array $conn): ?struct_quiche_connection_id_iter_ptr {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_source_ids($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_connection_id_iter_ptr($result);
    }
    public function quiche_connection_id_iter_next(void_ptr | struct_quiche_connection_id_iter_ptr | null | array $iter, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): int {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_connection_id_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_connection_id_iter*", $iter);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $result = $this->ffi->quiche_connection_id_iter_next($iter, $out, $out_len);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_connection_id_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_connection_id_iter($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
        return $result;
    }
    public function quiche_connection_id_iter_free(void_ptr | struct_quiche_connection_id_iter_ptr | null | array $iter): void {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_connection_id_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_connection_id_iter*", $iter);
            }
        }
        $this->ffi->quiche_connection_id_iter_free($iter);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_connection_id_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_connection_id_iter($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_destination_id(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_destination_id($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_application_proto(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_application_proto($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_peer_cert(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_peer_cert($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_session(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $this->ffi->quiche_conn_session($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
    }
    public function quiche_conn_is_established(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_established($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_resumed(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_resumed($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_in_early_data(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_in_early_data($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_readable(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_readable($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_draining(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_draining($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_peer_streams_left_bidi(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_peer_streams_left_bidi($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_peer_streams_left_uni(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_peer_streams_left_uni($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_closed(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_closed($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_timed_out(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_timed_out($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_peer_error(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | _Bool_ptr | null | array $is_app, void_ptr | uint64_t_ptr | null | array $error_code, void_ptr | uint8_t_ptr_ptr | null | array $reason, void_ptr | size_t_ptr | null | array $reason_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsis_app = [];
        if (\is_array($is_app)) {
            $_ = $this->ffi->new("_Bool[" . \count($is_app) . "]");
            $_i = 0;
            if ($is_app) {
                if ($_ref = \ReflectionReference::fromArrayElement($is_app, \key($is_app))) {
                    foreach ($is_app as $_k => $_v) {
                        $__ffi_internal_refsis_app[$_i] = &$is_app[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalis_app = $is_app = $_;
                } else {
                    foreach ($is_app as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $is_app = $_;
                }
            }
        } else {
            $is_app = $is_app?->getData();
            if ($is_app !== null) {
                $is_app = $this->ffi->cast("_Bool*", $is_app);
            }
        }
        $__ffi_internal_refserror_code = [];
        if (\is_array($error_code)) {
            $_ = $this->ffi->new("uint64_t[" . \count($error_code) . "]");
            $_i = 0;
            if ($error_code) {
                if ($_ref = \ReflectionReference::fromArrayElement($error_code, \key($error_code))) {
                    foreach ($error_code as $_k => $_v) {
                        $__ffi_internal_refserror_code[$_i] = &$error_code[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalerror_code = $error_code = $_;
                } else {
                    foreach ($error_code as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $error_code = $_;
                }
            }
        } else {
            $error_code = $error_code?->getData();
            if ($error_code !== null) {
                $error_code = $this->ffi->cast("uint64_t*", $error_code);
            }
        }
        $__ffi_internal_refsreason = [];
        if (\is_array($reason)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($reason) . "]");
            $_i = 0;
            if ($reason) {
                if ($_ref = \ReflectionReference::fromArrayElement($reason, \key($reason))) {
                    foreach ($reason as $_k => $_v) {
                        $__ffi_internal_refsreason[$_i] = &$reason[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalreason = $reason = $_;
                } else {
                    foreach ($reason as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $reason = $_;
                }
            }
        } else {
            $reason = $reason?->getData();
            if ($reason !== null) {
                $reason = $this->ffi->cast("uint8_t**", $reason);
            }
        }
        $__ffi_internal_refsreason_len = [];
        if (\is_array($reason_len)) {
            $_ = $this->ffi->new("size_t[" . \count($reason_len) . "]");
            $_i = 0;
            if ($reason_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($reason_len, \key($reason_len))) {
                    foreach ($reason_len as $_k => $_v) {
                        $__ffi_internal_refsreason_len[$_i] = &$reason_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalreason_len = $reason_len = $_;
                } else {
                    foreach ($reason_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $reason_len = $_;
                }
            }
        } else {
            $reason_len = $reason_len?->getData();
            if ($reason_len !== null) {
                $reason_len = $this->ffi->cast("size_t*", $reason_len);
            }
        }
        $result = $this->ffi->quiche_conn_peer_error($conn, $is_app, $error_code, $reason, $reason_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsis_app as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalis_app[$_k];
        }
        foreach ($__ffi_internal_refserror_code as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalerror_code[$_k];
        }
        foreach ($__ffi_internal_refsreason as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreason[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsreason_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreason_len[$_k];
        }
        return $result;
    }
    public function quiche_conn_local_error(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | _Bool_ptr | null | array $is_app, void_ptr | uint64_t_ptr | null | array $error_code, void_ptr | uint8_t_ptr_ptr | null | array $reason, void_ptr | size_t_ptr | null | array $reason_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsis_app = [];
        if (\is_array($is_app)) {
            $_ = $this->ffi->new("_Bool[" . \count($is_app) . "]");
            $_i = 0;
            if ($is_app) {
                if ($_ref = \ReflectionReference::fromArrayElement($is_app, \key($is_app))) {
                    foreach ($is_app as $_k => $_v) {
                        $__ffi_internal_refsis_app[$_i] = &$is_app[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalis_app = $is_app = $_;
                } else {
                    foreach ($is_app as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $is_app = $_;
                }
            }
        } else {
            $is_app = $is_app?->getData();
            if ($is_app !== null) {
                $is_app = $this->ffi->cast("_Bool*", $is_app);
            }
        }
        $__ffi_internal_refserror_code = [];
        if (\is_array($error_code)) {
            $_ = $this->ffi->new("uint64_t[" . \count($error_code) . "]");
            $_i = 0;
            if ($error_code) {
                if ($_ref = \ReflectionReference::fromArrayElement($error_code, \key($error_code))) {
                    foreach ($error_code as $_k => $_v) {
                        $__ffi_internal_refserror_code[$_i] = &$error_code[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalerror_code = $error_code = $_;
                } else {
                    foreach ($error_code as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $error_code = $_;
                }
            }
        } else {
            $error_code = $error_code?->getData();
            if ($error_code !== null) {
                $error_code = $this->ffi->cast("uint64_t*", $error_code);
            }
        }
        $__ffi_internal_refsreason = [];
        if (\is_array($reason)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($reason) . "]");
            $_i = 0;
            if ($reason) {
                if ($_ref = \ReflectionReference::fromArrayElement($reason, \key($reason))) {
                    foreach ($reason as $_k => $_v) {
                        $__ffi_internal_refsreason[$_i] = &$reason[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalreason = $reason = $_;
                } else {
                    foreach ($reason as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $reason = $_;
                }
            }
        } else {
            $reason = $reason?->getData();
            if ($reason !== null) {
                $reason = $this->ffi->cast("uint8_t**", $reason);
            }
        }
        $__ffi_internal_refsreason_len = [];
        if (\is_array($reason_len)) {
            $_ = $this->ffi->new("size_t[" . \count($reason_len) . "]");
            $_i = 0;
            if ($reason_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($reason_len, \key($reason_len))) {
                    foreach ($reason_len as $_k => $_v) {
                        $__ffi_internal_refsreason_len[$_i] = &$reason_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalreason_len = $reason_len = $_;
                } else {
                    foreach ($reason_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $reason_len = $_;
                }
            }
        } else {
            $reason_len = $reason_len?->getData();
            if ($reason_len !== null) {
                $reason_len = $this->ffi->cast("size_t*", $reason_len);
            }
        }
        $result = $this->ffi->quiche_conn_local_error($conn, $is_app, $error_code, $reason, $reason_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsis_app as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalis_app[$_k];
        }
        foreach ($__ffi_internal_refserror_code as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalerror_code[$_k];
        }
        foreach ($__ffi_internal_refsreason as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreason[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsreason_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreason_len[$_k];
        }
        return $result;
    }
    public function quiche_stream_iter_next(void_ptr | struct_quiche_stream_iter_ptr | null | array $iter, void_ptr | uint64_t_ptr | null | array $stream_id): int {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_stream_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_stream_iter*", $iter);
            }
        }
        $__ffi_internal_refsstream_id = [];
        if (\is_array($stream_id)) {
            $_ = $this->ffi->new("uint64_t[" . \count($stream_id) . "]");
            $_i = 0;
            if ($stream_id) {
                if ($_ref = \ReflectionReference::fromArrayElement($stream_id, \key($stream_id))) {
                    foreach ($stream_id as $_k => $_v) {
                        $__ffi_internal_refsstream_id[$_i] = &$stream_id[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalstream_id = $stream_id = $_;
                } else {
                    foreach ($stream_id as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $stream_id = $_;
                }
            }
        } else {
            $stream_id = $stream_id?->getData();
            if ($stream_id !== null) {
                $stream_id = $this->ffi->cast("uint64_t*", $stream_id);
            }
        }
        $result = $this->ffi->quiche_stream_iter_next($iter, $stream_id);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_stream_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_stream_iter($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsstream_id as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalstream_id[$_k];
        }
        return $result;
    }
    public function quiche_stream_iter_free(void_ptr | struct_quiche_stream_iter_ptr | null | array $iter): void {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_stream_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_stream_iter*", $iter);
            }
        }
        $this->ffi->quiche_stream_iter_free($iter);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_stream_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_stream_iter($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_stats(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | quiche_stats_ptr | null | array $out): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("quiche_stats[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("quiche_stats*", $out);
            }
        }
        $this->ffi->quiche_conn_stats($conn, $out);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_stats");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_stats($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_peer_transport_params(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | quiche_transport_params_ptr | null | array $out): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("quiche_transport_params[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("quiche_transport_params*", $out);
            }
        }
        $result = $this->ffi->quiche_conn_peer_transport_params($conn, $out);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_transport_params");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_transport_params($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_path_stats(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $idx, void_ptr | quiche_path_stats_ptr | null | array $out): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("quiche_path_stats[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("quiche_path_stats*", $out);
            }
        }
        $result = $this->ffi->quiche_conn_path_stats($conn, $idx, $out);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_path_stats");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_path_stats($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_server(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_server($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_max_writable_len(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_max_writable_len($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_recv_front_len(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_recv_front_len($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_recv_queue_len(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_recv_queue_len($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_recv_queue_byte_size(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_recv_queue_byte_size($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_send_queue_len(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_send_queue_len($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_send_queue_byte_size(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_send_queue_byte_size($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_dgram_recv(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_recv($conn, $buf, $buf_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        return $result;
    }
    public function quiche_conn_dgram_send(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $result = $this->ffi->quiche_conn_dgram_send($conn, $buf, $buf_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        return $result;
    }
    public function quiche_conn_dgram_purge_outgoing(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | function_type_ptr | null | array $f): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsf = [];
        if (\is_array($f)) {
            $_ = $this->ffi->new("function type[" . \count($f) . "]");
            $_i = 0;
            if ($f) {
                if ($_ref = \ReflectionReference::fromArrayElement($f, \key($f))) {
                    foreach ($f as $_k => $_v) {
                        $__ffi_internal_refsf[$_i] = &$f[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalf = $f = $_;
                } else {
                    foreach ($f as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $f = $_;
                }
            }
        } else {
            $f = $f?->getData();
            if ($f !== null) {
                $f = $this->ffi->cast("_Bool(*)(uint8_t*, size_t)", $f);
            }
        }
        $this->ffi->quiche_conn_dgram_purge_outgoing($conn, $f);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("function type");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalf[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new function_type($__ffi_internal_ref_v, ['function_type', 'uint8_t_ptr', 'int']);
            }
        }
    }
    public function quiche_conn_is_dgram_send_queue_full(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_dgram_send_queue_full($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_is_dgram_recv_queue_full(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_is_dgram_recv_queue_full($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send_ack_eliciting(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_send_ack_eliciting($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_send_ack_eliciting_on_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $result = $this->ffi->quiche_conn_send_ack_eliciting_on_path($conn, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_retired_scid_next(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr_ptr | null | array $out, void_ptr | size_t_ptr | null | array $out_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t*[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t**", $out);
            }
        }
        $__ffi_internal_refsout_len = [];
        if (\is_array($out_len)) {
            $_ = $this->ffi->new("size_t[" . \count($out_len) . "]");
            $_i = 0;
            if ($out_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($out_len, \key($out_len))) {
                    foreach ($out_len as $_k => $_v) {
                        $__ffi_internal_refsout_len[$_i] = &$out_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout_len = $out_len = $_;
                } else {
                    foreach ($out_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out_len = $_;
                }
            }
        } else {
            $out_len = $out_len?->getData();
            if ($out_len !== null) {
                $out_len = $this->ffi->cast("size_t*", $out_len);
            }
        }
        $result = $this->ffi->quiche_conn_retired_scid_next($conn, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new uint8_t_ptr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout_len[$_k];
        }
        return $result;
    }
    public function quiche_conn_retired_scids(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_retired_scids($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_available_dcids(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_available_dcids($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_scids_left(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_scids_left($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_active_scids(void_ptr | struct_quiche_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_active_scids($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_new_scid(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | uint8_t_ptr | null | string | array $scid, int $scid_len, void_ptr | uint8_t_ptr | null | string | array $reset_token, int $retire_if_needed, void_ptr | uint64_t_ptr | null | array $scid_seq): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsscid = [];
        if (\is_string($scid)) {
            $__ffi_str_scid = string_::ownedZero($scid)->getData();
            $scid = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_scid));
        } elseif (\is_array($scid)) {
            $_ = $this->ffi->new("uint8_t[" . \count($scid) . "]");
            $_i = 0;
            if ($scid) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid, \key($scid))) {
                    foreach ($scid as $_k => $_v) {
                        $__ffi_internal_refsscid[$_i] = &$scid[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid = $scid = $_;
                } else {
                    foreach ($scid as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid = $_;
                }
            }
        } else {
            $scid = $scid?->getData();
            if ($scid !== null) {
                $scid = $this->ffi->cast("uint8_t*", $scid);
            }
        }
        $__ffi_internal_refsreset_token = [];
        if (\is_string($reset_token)) {
            $__ffi_str_reset_token = string_::ownedZero($reset_token)->getData();
            $reset_token = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_reset_token));
        } elseif (\is_array($reset_token)) {
            $_ = $this->ffi->new("uint8_t[" . \count($reset_token) . "]");
            $_i = 0;
            if ($reset_token) {
                if ($_ref = \ReflectionReference::fromArrayElement($reset_token, \key($reset_token))) {
                    foreach ($reset_token as $_k => $_v) {
                        $__ffi_internal_refsreset_token[$_i] = &$reset_token[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalreset_token = $reset_token = $_;
                } else {
                    foreach ($reset_token as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $reset_token = $_;
                }
            }
        } else {
            $reset_token = $reset_token?->getData();
            if ($reset_token !== null) {
                $reset_token = $this->ffi->cast("uint8_t*", $reset_token);
            }
        }
        $__ffi_internal_refsscid_seq = [];
        if (\is_array($scid_seq)) {
            $_ = $this->ffi->new("uint64_t[" . \count($scid_seq) . "]");
            $_i = 0;
            if ($scid_seq) {
                if ($_ref = \ReflectionReference::fromArrayElement($scid_seq, \key($scid_seq))) {
                    foreach ($scid_seq as $_k => $_v) {
                        $__ffi_internal_refsscid_seq[$_i] = &$scid_seq[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalscid_seq = $scid_seq = $_;
                } else {
                    foreach ($scid_seq as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $scid_seq = $_;
                }
            }
        } else {
            $scid_seq = $scid_seq?->getData();
            if ($scid_seq !== null) {
                $scid_seq = $this->ffi->cast("uint64_t*", $scid_seq);
            }
        }
        $result = $this->ffi->quiche_conn_new_scid($conn, $scid, $scid_len, $reset_token, $retire_if_needed, $scid_seq);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsscid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid[$_k];
        }
        foreach ($__ffi_internal_refsreset_token as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalreset_token[$_k];
        }
        foreach ($__ffi_internal_refsscid_seq as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalscid_seq[$_k];
        }
        return $result;
    }
    public function quiche_conn_probe_path(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len, void_ptr | uint64_t_ptr | null | array $seq): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $__ffi_internal_refsseq = [];
        if (\is_array($seq)) {
            $_ = $this->ffi->new("uint64_t[" . \count($seq) . "]");
            $_i = 0;
            if ($seq) {
                if ($_ref = \ReflectionReference::fromArrayElement($seq, \key($seq))) {
                    foreach ($seq as $_k => $_v) {
                        $__ffi_internal_refsseq[$_i] = &$seq[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalseq = $seq = $_;
                } else {
                    foreach ($seq as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $seq = $_;
                }
            }
        } else {
            $seq = $seq?->getData();
            if ($seq !== null) {
                $seq = $this->ffi->cast("uint64_t*", $seq);
            }
        }
        $result = $this->ffi->quiche_conn_probe_path($conn, $local, $local_len, $peer, $peer_len, $seq);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsseq as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalseq[$_k];
        }
        return $result;
    }
    public function quiche_conn_migrate_source(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | uint64_t_ptr | null | array $seq): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refsseq = [];
        if (\is_array($seq)) {
            $_ = $this->ffi->new("uint64_t[" . \count($seq) . "]");
            $_i = 0;
            if ($seq) {
                if ($_ref = \ReflectionReference::fromArrayElement($seq, \key($seq))) {
                    foreach ($seq as $_k => $_v) {
                        $__ffi_internal_refsseq[$_i] = &$seq[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalseq = $seq = $_;
                } else {
                    foreach ($seq as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $seq = $_;
                }
            }
        } else {
            $seq = $seq?->getData();
            if ($seq !== null) {
                $seq = $this->ffi->cast("uint64_t*", $seq);
            }
        }
        $result = $this->ffi->quiche_conn_migrate_source($conn, $local, $local_len, $seq);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsseq as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalseq[$_k];
        }
        return $result;
    }
    public function quiche_conn_migrate(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $local, int $local_len, void_ptr | struct_sockaddr_ptr | null | array $peer, int $peer_len, void_ptr | uint64_t_ptr | null | array $seq): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr*", $local);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr*", $peer);
            }
        }
        $__ffi_internal_refsseq = [];
        if (\is_array($seq)) {
            $_ = $this->ffi->new("uint64_t[" . \count($seq) . "]");
            $_i = 0;
            if ($seq) {
                if ($_ref = \ReflectionReference::fromArrayElement($seq, \key($seq))) {
                    foreach ($seq as $_k => $_v) {
                        $__ffi_internal_refsseq[$_i] = &$seq[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalseq = $seq = $_;
                } else {
                    foreach ($seq as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $seq = $_;
                }
            }
        } else {
            $seq = $seq?->getData();
            if ($seq !== null) {
                $seq = $this->ffi->cast("uint64_t*", $seq);
            }
        }
        $result = $this->ffi->quiche_conn_migrate($conn, $local, $local_len, $peer, $peer_len, $seq);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsseq as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalseq[$_k];
        }
        return $result;
    }
    public function quiche_conn_path_event_next(void_ptr | struct_quiche_conn_ptr | null | array $conn): ?struct_quiche_path_event_ptr {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_path_event_next($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_path_event_ptr($result);
    }
    public function quiche_path_event_type(void_ptr | struct_quiche_path_event_ptr | null | array $ev): int {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $result = $this->ffi->quiche_path_event_type($ev);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_path_event_new(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_new($ev, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_validated(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_validated($ev, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_failed_validation(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_failed_validation($ev, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_closed(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_closed($ev, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_reused_source_connection_id(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | uint64_t_ptr | null | array $id, void_ptr | struct_sockaddr_storage_ptr | null | array $old_local, void_ptr | unsigned_int_ptr | null | array $old_local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $old_peer, void_ptr | unsigned_int_ptr | null | array $old_peer_len, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refsid = [];
        if (\is_array($id)) {
            $_ = $this->ffi->new("uint64_t[" . \count($id) . "]");
            $_i = 0;
            if ($id) {
                if ($_ref = \ReflectionReference::fromArrayElement($id, \key($id))) {
                    foreach ($id as $_k => $_v) {
                        $__ffi_internal_refsid[$_i] = &$id[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalid = $id = $_;
                } else {
                    foreach ($id as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $id = $_;
                }
            }
        } else {
            $id = $id?->getData();
            if ($id !== null) {
                $id = $this->ffi->cast("uint64_t*", $id);
            }
        }
        $__ffi_internal_refsold_local = [];
        if (\is_array($old_local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($old_local) . "]");
            $_i = 0;
            if ($old_local) {
                if ($_ref = \ReflectionReference::fromArrayElement($old_local, \key($old_local))) {
                    foreach ($old_local as $_k => $_v) {
                        $__ffi_internal_refsold_local[$_i] = &$old_local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalold_local = $old_local = $_;
                } else {
                    foreach ($old_local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $old_local = $_;
                }
            }
        } else {
            $old_local = $old_local?->getData();
            if ($old_local !== null) {
                $old_local = $this->ffi->cast("struct sockaddr_storage*", $old_local);
            }
        }
        $__ffi_internal_refsold_local_len = [];
        if (\is_array($old_local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($old_local_len) . "]");
            $_i = 0;
            if ($old_local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($old_local_len, \key($old_local_len))) {
                    foreach ($old_local_len as $_k => $_v) {
                        $__ffi_internal_refsold_local_len[$_i] = &$old_local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalold_local_len = $old_local_len = $_;
                } else {
                    foreach ($old_local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $old_local_len = $_;
                }
            }
        } else {
            $old_local_len = $old_local_len?->getData();
            if ($old_local_len !== null) {
                $old_local_len = $this->ffi->cast("unsigned int*", $old_local_len);
            }
        }
        $__ffi_internal_refsold_peer = [];
        if (\is_array($old_peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($old_peer) . "]");
            $_i = 0;
            if ($old_peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($old_peer, \key($old_peer))) {
                    foreach ($old_peer as $_k => $_v) {
                        $__ffi_internal_refsold_peer[$_i] = &$old_peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalold_peer = $old_peer = $_;
                } else {
                    foreach ($old_peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $old_peer = $_;
                }
            }
        } else {
            $old_peer = $old_peer?->getData();
            if ($old_peer !== null) {
                $old_peer = $this->ffi->cast("struct sockaddr_storage*", $old_peer);
            }
        }
        $__ffi_internal_refsold_peer_len = [];
        if (\is_array($old_peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($old_peer_len) . "]");
            $_i = 0;
            if ($old_peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($old_peer_len, \key($old_peer_len))) {
                    foreach ($old_peer_len as $_k => $_v) {
                        $__ffi_internal_refsold_peer_len[$_i] = &$old_peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalold_peer_len = $old_peer_len = $_;
                } else {
                    foreach ($old_peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $old_peer_len = $_;
                }
            }
        } else {
            $old_peer_len = $old_peer_len?->getData();
            if ($old_peer_len !== null) {
                $old_peer_len = $this->ffi->cast("unsigned int*", $old_peer_len);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_reused_source_connection_id($ev, $id, $old_local, $old_local_len, $old_peer, $old_peer_len, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsid as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalid[$_k];
        }
        foreach ($__ffi_internal_refsold_local as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalold_local[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsold_local_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalold_local_len[$_k];
        }
        foreach ($__ffi_internal_refsold_peer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalold_peer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsold_peer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalold_peer_len[$_k];
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_peer_migrated(void_ptr | struct_quiche_path_event_ptr | null | array $ev, void_ptr | struct_sockaddr_storage_ptr | null | array $local, void_ptr | unsigned_int_ptr | null | array $local_len, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | unsigned_int_ptr | null | array $peer_len): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $__ffi_internal_refslocal = [];
        if (\is_array($local)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($local) . "]");
            $_i = 0;
            if ($local) {
                if ($_ref = \ReflectionReference::fromArrayElement($local, \key($local))) {
                    foreach ($local as $_k => $_v) {
                        $__ffi_internal_refslocal[$_i] = &$local[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originallocal = $local = $_;
                } else {
                    foreach ($local as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $local = $_;
                }
            }
        } else {
            $local = $local?->getData();
            if ($local !== null) {
                $local = $this->ffi->cast("struct sockaddr_storage*", $local);
            }
        }
        $__ffi_internal_refslocal_len = [];
        if (\is_array($local_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($local_len) . "]");
            $_i = 0;
            if ($local_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($local_len, \key($local_len))) {
                    foreach ($local_len as $_k => $_v) {
                        $__ffi_internal_refslocal_len[$_i] = &$local_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originallocal_len = $local_len = $_;
                } else {
                    foreach ($local_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $local_len = $_;
                }
            }
        } else {
            $local_len = $local_len?->getData();
            if ($local_len !== null) {
                $local_len = $this->ffi->cast("unsigned int*", $local_len);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("unsigned int[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("unsigned int*", $peer_len);
            }
        }
        $this->ffi->quiche_path_event_peer_migrated($ev, $local, $local_len, $peer, $peer_len);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originallocal[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refslocal_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallocal_len[$_k];
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
    }
    public function quiche_path_event_free(void_ptr | struct_quiche_path_event_ptr | null | array $ev): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_path_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_path_event*", $ev);
            }
        }
        $this->ffi->quiche_path_event_free($ev);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_path_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_path_event($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_retire_dcid(void_ptr | struct_quiche_conn_ptr | null | array $conn, int $dcid_seq): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_conn_retire_dcid($conn, $dcid_seq);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_paths_iter(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $from, int $from_len): ?struct_quiche_socket_addr_iter_ptr {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsfrom = [];
        if (\is_array($from)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($from) . "]");
            $_i = 0;
            if ($from) {
                if ($_ref = \ReflectionReference::fromArrayElement($from, \key($from))) {
                    foreach ($from as $_k => $_v) {
                        $__ffi_internal_refsfrom[$_i] = &$from[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalfrom = $from = $_;
                } else {
                    foreach ($from as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $from = $_;
                }
            }
        } else {
            $from = $from?->getData();
            if ($from !== null) {
                $from = $this->ffi->cast("struct sockaddr*", $from);
            }
        }
        $result = $this->ffi->quiche_conn_paths_iter($conn, $from, $from_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsfrom as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalfrom[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_socket_addr_iter_ptr($result);
    }
    public function quiche_socket_addr_iter_next(void_ptr | struct_quiche_socket_addr_iter_ptr | null | array $iter, void_ptr | struct_sockaddr_storage_ptr | null | array $peer, void_ptr | size_t_ptr | null | array $peer_len): int {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_socket_addr_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_socket_addr_iter*", $iter);
            }
        }
        $__ffi_internal_refspeer = [];
        if (\is_array($peer)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($peer) . "]");
            $_i = 0;
            if ($peer) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer, \key($peer))) {
                    foreach ($peer as $_k => $_v) {
                        $__ffi_internal_refspeer[$_i] = &$peer[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpeer = $peer = $_;
                } else {
                    foreach ($peer as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $peer = $_;
                }
            }
        } else {
            $peer = $peer?->getData();
            if ($peer !== null) {
                $peer = $this->ffi->cast("struct sockaddr_storage*", $peer);
            }
        }
        $__ffi_internal_refspeer_len = [];
        if (\is_array($peer_len)) {
            $_ = $this->ffi->new("size_t[" . \count($peer_len) . "]");
            $_i = 0;
            if ($peer_len) {
                if ($_ref = \ReflectionReference::fromArrayElement($peer_len, \key($peer_len))) {
                    foreach ($peer_len as $_k => $_v) {
                        $__ffi_internal_refspeer_len[$_i] = &$peer_len[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpeer_len = $peer_len = $_;
                } else {
                    foreach ($peer_len as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $peer_len = $_;
                }
            }
        } else {
            $peer_len = $peer_len?->getData();
            if ($peer_len !== null) {
                $peer_len = $this->ffi->cast("size_t*", $peer_len);
            }
        }
        $result = $this->ffi->quiche_socket_addr_iter_next($iter, $peer, $peer_len);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_socket_addr_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_socket_addr_iter($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpeer[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspeer_len as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpeer_len[$_k];
        }
        return $result;
    }
    public function quiche_socket_addr_iter_free(void_ptr | struct_quiche_socket_addr_iter_ptr | null | array $iter): void {
        $__ffi_internal_refsiter = [];
        if (\is_array($iter)) {
            $_ = $this->ffi->new("struct quiche_socket_addr_iter[" . \count($iter) . "]");
            $_i = 0;
            if ($iter) {
                if ($_ref = \ReflectionReference::fromArrayElement($iter, \key($iter))) {
                    foreach ($iter as $_k => $_v) {
                        $__ffi_internal_refsiter[$_i] = &$iter[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originaliter = $iter = $_;
                } else {
                    foreach ($iter as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $iter = $_;
                }
            }
        } else {
            $iter = $iter?->getData();
            if ($iter !== null) {
                $iter = $this->ffi->cast("struct quiche_socket_addr_iter*", $iter);
            }
        }
        $this->ffi->quiche_socket_addr_iter_free($iter);
        foreach ($__ffi_internal_refsiter as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_socket_addr_iter");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originaliter[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_socket_addr_iter($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_conn_is_path_validated(void_ptr | struct_quiche_conn_ptr | null | array $conn, void_ptr | struct_sockaddr_ptr | null | array $from, int $from_len, void_ptr | struct_sockaddr_ptr | null | array $to, int $to_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $__ffi_internal_refsfrom = [];
        if (\is_array($from)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($from) . "]");
            $_i = 0;
            if ($from) {
                if ($_ref = \ReflectionReference::fromArrayElement($from, \key($from))) {
                    foreach ($from as $_k => $_v) {
                        $__ffi_internal_refsfrom[$_i] = &$from[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalfrom = $from = $_;
                } else {
                    foreach ($from as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $from = $_;
                }
            }
        } else {
            $from = $from?->getData();
            if ($from !== null) {
                $from = $this->ffi->cast("struct sockaddr*", $from);
            }
        }
        $__ffi_internal_refsto = [];
        if (\is_array($to)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($to) . "]");
            $_i = 0;
            if ($to) {
                if ($_ref = \ReflectionReference::fromArrayElement($to, \key($to))) {
                    foreach ($to as $_k => $_v) {
                        $__ffi_internal_refsto[$_i] = &$to[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalto = $to = $_;
                } else {
                    foreach ($to as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $to = $_;
                }
            }
        } else {
            $to = $to?->getData();
            if ($to !== null) {
                $to = $this->ffi->cast("struct sockaddr*", $to);
            }
        }
        $result = $this->ffi->quiche_conn_is_path_validated($conn, $from, $from_len, $to, $to_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsfrom as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalfrom[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsto as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalto[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_conn_free(void_ptr | struct_quiche_conn_ptr | null | array $conn): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_conn*", $conn);
            }
        }
        $this->ffi->quiche_conn_free($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_put_varint(void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len, int $val): int {
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $result = $this->ffi->quiche_put_varint($buf, $buf_len, $val);
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        return $result;
    }
    public function quiche_get_varint(void_ptr | uint8_t_ptr | null | string | array $buf, int $buf_len, void_ptr | uint64_t_ptr | null | array $val): int {
        $__ffi_internal_refsbuf = [];
        if (\is_string($buf)) {
            $__ffi_str_buf = string_::ownedZero($buf)->getData();
            $buf = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_buf));
        } elseif (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            if ($buf) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, \key($buf))) {
                    foreach ($buf as $_k => $_v) {
                        $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbuf = $buf = $_;
                } else {
                    foreach ($buf as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $buf = $_;
                }
            }
        } else {
            $buf = $buf?->getData();
            if ($buf !== null) {
                $buf = $this->ffi->cast("uint8_t*", $buf);
            }
        }
        $__ffi_internal_refsval = [];
        if (\is_array($val)) {
            $_ = $this->ffi->new("uint64_t[" . \count($val) . "]");
            $_i = 0;
            if ($val) {
                if ($_ref = \ReflectionReference::fromArrayElement($val, \key($val))) {
                    foreach ($val as $_k => $_v) {
                        $__ffi_internal_refsval[$_i] = &$val[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalval = $val = $_;
                } else {
                    foreach ($val as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $val = $_;
                }
            }
        } else {
            $val = $val?->getData();
            if ($val !== null) {
                $val = $this->ffi->cast("uint64_t*", $val);
            }
        }
        $result = $this->ffi->quiche_get_varint($buf, $buf_len, $val);
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
        foreach ($__ffi_internal_refsval as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalval[$_k];
        }
        return $result;
    }
    public function quiche_h3_config_new(): ?struct_quiche_h3_config_ptr {
        $result = $this->ffi->quiche_h3_config_new();
        return $result === null ? null : new struct_quiche_h3_config_ptr($result);
    }
    public function quiche_h3_config_set_max_field_section_size(void_ptr | struct_quiche_h3_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $this->ffi->quiche_h3_config_set_max_field_section_size($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_config_set_qpack_max_table_capacity(void_ptr | struct_quiche_h3_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $this->ffi->quiche_h3_config_set_qpack_max_table_capacity($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_config_set_qpack_blocked_streams(void_ptr | struct_quiche_h3_config_ptr | null | array $config, int $v): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $this->ffi->quiche_h3_config_set_qpack_blocked_streams($config, $v);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_config_enable_extended_connect(void_ptr | struct_quiche_h3_config_ptr | null | array $config, int $enabled): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $this->ffi->quiche_h3_config_enable_extended_connect($config, $enabled);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_config_free(void_ptr | struct_quiche_h3_config_ptr | null | array $config): void {
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $this->ffi->quiche_h3_config_free($config);
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_conn_new_with_transport(void_ptr | struct_quiche_conn_ptr | null | array $quiche_conn, void_ptr | struct_quiche_h3_config_ptr | null | array $config): ?struct_quiche_h3_conn_ptr {
        $__ffi_internal_refsquiche_conn = [];
        if (\is_array($quiche_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quiche_conn) . "]");
            $_i = 0;
            if ($quiche_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quiche_conn, \key($quiche_conn))) {
                    foreach ($quiche_conn as $_k => $_v) {
                        $__ffi_internal_refsquiche_conn[$_i] = &$quiche_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquiche_conn = $quiche_conn = $_;
                } else {
                    foreach ($quiche_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quiche_conn = $_;
                }
            }
        } else {
            $quiche_conn = $quiche_conn?->getData();
            if ($quiche_conn !== null) {
                $quiche_conn = $this->ffi->cast("struct quiche_conn*", $quiche_conn);
            }
        }
        $__ffi_internal_refsconfig = [];
        if (\is_array($config)) {
            $_ = $this->ffi->new("struct quiche_h3_config[" . \count($config) . "]");
            $_i = 0;
            if ($config) {
                if ($_ref = \ReflectionReference::fromArrayElement($config, \key($config))) {
                    foreach ($config as $_k => $_v) {
                        $__ffi_internal_refsconfig[$_i] = &$config[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconfig = $config = $_;
                } else {
                    foreach ($config as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $config = $_;
                }
            }
        } else {
            $config = $config?->getData();
            if ($config !== null) {
                $config = $this->ffi->cast("struct quiche_h3_config*", $config);
            }
        }
        $result = $this->ffi->quiche_h3_conn_new_with_transport($quiche_conn, $config);
        foreach ($__ffi_internal_refsquiche_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquiche_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsconfig as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_config");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconfig[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_config($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_quiche_h3_conn_ptr($result);
    }
    public function quiche_h3_conn_poll(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, void_ptr | struct_quiche_h3_event_ptr_ptr | null | array $ev): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_h3_event*[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_h3_event**", $ev);
            }
        }
        $result = $this->ffi->quiche_h3_conn_poll($conn, $quic_conn, $ev);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_event_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_event_type(void_ptr | struct_quiche_h3_event_ptr | null | array $ev): int {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_h3_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_h3_event*", $ev);
            }
        }
        $result = $this->ffi->quiche_h3_event_type($ev);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_event($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_event_for_each_header(void_ptr | struct_quiche_h3_event_ptr | null | array $ev, void_ptr | function_type_ptr | null | array $cb, iQuiche_ptr | null | array $argp): int {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_h3_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_h3_event*", $ev);
            }
        }
        $__ffi_internal_refscb = [];
        if (\is_array($cb)) {
            $_ = $this->ffi->new("function type[" . \count($cb) . "]");
            $_i = 0;
            if ($cb) {
                if ($_ref = \ReflectionReference::fromArrayElement($cb, \key($cb))) {
                    foreach ($cb as $_k => $_v) {
                        $__ffi_internal_refscb[$_i] = &$cb[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalcb = $cb = $_;
                } else {
                    foreach ($cb as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $cb = $_;
                }
            }
        } else {
            $cb = $cb?->getData();
            if ($cb !== null) {
                $cb = $this->ffi->cast("int(*)(uint8_t*, size_t, uint8_t*, size_t, void*)", $cb);
            }
        }
        $__ffi_internal_refsargp = [];
        if (\is_array($argp)) {
            $_ = $this->ffi->new("void[" . \count($argp) . "]");
            $_i = 0;
            if ($argp) {
                if ($_ref = \ReflectionReference::fromArrayElement($argp, \key($argp))) {
                    foreach ($argp as $_k => $_v) {
                        $__ffi_internal_refsargp[$_i] = &$argp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalargp = $argp = $_;
                } else {
                    foreach ($argp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $argp = $_;
                }
            }
        } else {
            $argp = $argp?->getData();
            if ($argp !== null) {
                $argp = $this->ffi->cast("void*", $argp);
            }
        }
        $result = $this->ffi->quiche_h3_event_for_each_header($ev, $cb, $argp);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_event($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refscb as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("function type");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalcb[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new function_type($__ffi_internal_ref_v, ['function_type', 'uint8_t_ptr', 'int', 'uint8_t_ptr', 'int', 'void_ptr']);
            }
        }
        foreach ($__ffi_internal_refsargp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalargp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_for_each_setting(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | function_type_ptr | null | array $cb, iQuiche_ptr | null | array $argp): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refscb = [];
        if (\is_array($cb)) {
            $_ = $this->ffi->new("function type[" . \count($cb) . "]");
            $_i = 0;
            if ($cb) {
                if ($_ref = \ReflectionReference::fromArrayElement($cb, \key($cb))) {
                    foreach ($cb as $_k => $_v) {
                        $__ffi_internal_refscb[$_i] = &$cb[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalcb = $cb = $_;
                } else {
                    foreach ($cb as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $cb = $_;
                }
            }
        } else {
            $cb = $cb?->getData();
            if ($cb !== null) {
                $cb = $this->ffi->cast("int(*)(uint64_t, uint64_t, void*)", $cb);
            }
        }
        $__ffi_internal_refsargp = [];
        if (\is_array($argp)) {
            $_ = $this->ffi->new("void[" . \count($argp) . "]");
            $_i = 0;
            if ($argp) {
                if ($_ref = \ReflectionReference::fromArrayElement($argp, \key($argp))) {
                    foreach ($argp as $_k => $_v) {
                        $__ffi_internal_refsargp[$_i] = &$argp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalargp = $argp = $_;
                } else {
                    foreach ($argp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $argp = $_;
                }
            }
        } else {
            $argp = $argp?->getData();
            if ($argp !== null) {
                $argp = $this->ffi->cast("void*", $argp);
            }
        }
        $result = $this->ffi->quiche_h3_for_each_setting($conn, $cb, $argp);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refscb as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("function type");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalcb[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new function_type($__ffi_internal_ref_v, ['function_type', 'int', 'int', 'void_ptr']);
            }
        }
        foreach ($__ffi_internal_refsargp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalargp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_event_headers_has_body(void_ptr | struct_quiche_h3_event_ptr | null | array $ev): int {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_h3_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_h3_event*", $ev);
            }
        }
        $result = $this->ffi->quiche_h3_event_headers_has_body($ev);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_event($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_extended_connect_enabled_by_peer(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $result = $this->ffi->quiche_h3_extended_connect_enabled_by_peer($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_event_free(void_ptr | struct_quiche_h3_event_ptr | null | array $ev): void {
        $__ffi_internal_refsev = [];
        if (\is_array($ev)) {
            $_ = $this->ffi->new("struct quiche_h3_event[" . \count($ev) . "]");
            $_i = 0;
            if ($ev) {
                if ($_ref = \ReflectionReference::fromArrayElement($ev, \key($ev))) {
                    foreach ($ev as $_k => $_v) {
                        $__ffi_internal_refsev[$_i] = &$ev[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalev = $ev = $_;
                } else {
                    foreach ($ev as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $ev = $_;
                }
            }
        } else {
            $ev = $ev?->getData();
            if ($ev !== null) {
                $ev = $this->ffi->cast("struct quiche_h3_event*", $ev);
            }
        }
        $this->ffi->quiche_h3_event_free($ev);
        foreach ($__ffi_internal_refsev as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_event");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalev[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_event($__ffi_internal_ref_v);
            }
        }
    }
    public function quiche_h3_send_request(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, void_ptr | quiche_h3_header_ptr | null | array $headers, int $headers_len, int $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsheaders = [];
        if (\is_array($headers)) {
            $_ = $this->ffi->new("quiche_h3_header[" . \count($headers) . "]");
            $_i = 0;
            if ($headers) {
                if ($_ref = \ReflectionReference::fromArrayElement($headers, \key($headers))) {
                    foreach ($headers as $_k => $_v) {
                        $__ffi_internal_refsheaders[$_i] = &$headers[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalheaders = $headers = $_;
                } else {
                    foreach ($headers as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $headers = $_;
                }
            }
        } else {
            $headers = $headers?->getData();
            if ($headers !== null) {
                $headers = $this->ffi->cast("quiche_h3_header*", $headers);
            }
        }
        $result = $this->ffi->quiche_h3_send_request($conn, $quic_conn, $headers, $headers_len, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsheaders as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_header");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalheaders[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_header($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_send_response(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $stream_id, void_ptr | quiche_h3_header_ptr | null | array $headers, int $headers_len, int $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsheaders = [];
        if (\is_array($headers)) {
            $_ = $this->ffi->new("quiche_h3_header[" . \count($headers) . "]");
            $_i = 0;
            if ($headers) {
                if ($_ref = \ReflectionReference::fromArrayElement($headers, \key($headers))) {
                    foreach ($headers as $_k => $_v) {
                        $__ffi_internal_refsheaders[$_i] = &$headers[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalheaders = $headers = $_;
                } else {
                    foreach ($headers as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $headers = $_;
                }
            }
        } else {
            $headers = $headers?->getData();
            if ($headers !== null) {
                $headers = $this->ffi->cast("quiche_h3_header*", $headers);
            }
        }
        $result = $this->ffi->quiche_h3_send_response($conn, $quic_conn, $stream_id, $headers, $headers_len, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsheaders as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_header");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalheaders[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_header($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_send_response_with_priority(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $stream_id, void_ptr | quiche_h3_header_ptr | null | array $headers, int $headers_len, void_ptr | quiche_h3_priority_ptr | null | array $priority, int $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsheaders = [];
        if (\is_array($headers)) {
            $_ = $this->ffi->new("quiche_h3_header[" . \count($headers) . "]");
            $_i = 0;
            if ($headers) {
                if ($_ref = \ReflectionReference::fromArrayElement($headers, \key($headers))) {
                    foreach ($headers as $_k => $_v) {
                        $__ffi_internal_refsheaders[$_i] = &$headers[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalheaders = $headers = $_;
                } else {
                    foreach ($headers as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $headers = $_;
                }
            }
        } else {
            $headers = $headers?->getData();
            if ($headers !== null) {
                $headers = $this->ffi->cast("quiche_h3_header*", $headers);
            }
        }
        $__ffi_internal_refspriority = [];
        if (\is_array($priority)) {
            $_ = $this->ffi->new("quiche_h3_priority[" . \count($priority) . "]");
            $_i = 0;
            if ($priority) {
                if ($_ref = \ReflectionReference::fromArrayElement($priority, \key($priority))) {
                    foreach ($priority as $_k => $_v) {
                        $__ffi_internal_refspriority[$_i] = &$priority[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpriority = $priority = $_;
                } else {
                    foreach ($priority as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $priority = $_;
                }
            }
        } else {
            $priority = $priority?->getData();
            if ($priority !== null) {
                $priority = $this->ffi->cast("quiche_h3_priority*", $priority);
            }
        }
        $result = $this->ffi->quiche_h3_send_response_with_priority($conn, $quic_conn, $stream_id, $headers, $headers_len, $priority, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsheaders as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_header");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalheaders[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_header($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspriority as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_priority");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpriority[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_priority($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_send_body(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $stream_id, void_ptr | uint8_t_ptr | null | string | array $body, int $body_len, int $fin): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsbody = [];
        if (\is_string($body)) {
            $__ffi_str_body = string_::ownedZero($body)->getData();
            $body = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_body));
        } elseif (\is_array($body)) {
            $_ = $this->ffi->new("uint8_t[" . \count($body) . "]");
            $_i = 0;
            if ($body) {
                if ($_ref = \ReflectionReference::fromArrayElement($body, \key($body))) {
                    foreach ($body as $_k => $_v) {
                        $__ffi_internal_refsbody[$_i] = &$body[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalbody = $body = $_;
                } else {
                    foreach ($body as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $body = $_;
                }
            }
        } else {
            $body = $body?->getData();
            if ($body !== null) {
                $body = $this->ffi->cast("uint8_t*", $body);
            }
        }
        $result = $this->ffi->quiche_h3_send_body($conn, $quic_conn, $stream_id, $body, $body_len, $fin);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsbody as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbody[$_k];
        }
        return $result;
    }
    public function quiche_h3_recv_body(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $stream_id, void_ptr | uint8_t_ptr | null | string | array $out, int $out_len): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refsout = [];
        if (\is_string($out)) {
            $__ffi_str_out = string_::ownedZero($out)->getData();
            $out = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_out));
        } elseif (\is_array($out)) {
            $_ = $this->ffi->new("uint8_t[" . \count($out) . "]");
            $_i = 0;
            if ($out) {
                if ($_ref = \ReflectionReference::fromArrayElement($out, \key($out))) {
                    foreach ($out as $_k => $_v) {
                        $__ffi_internal_refsout[$_i] = &$out[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalout = $out = $_;
                } else {
                    foreach ($out as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $out = $_;
                }
            }
        } else {
            $out = $out?->getData();
            if ($out !== null) {
                $out = $this->ffi->cast("uint8_t*", $out);
            }
        }
        $result = $this->ffi->quiche_h3_recv_body($conn, $quic_conn, $stream_id, $out, $out_len);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsout as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalout[$_k];
        }
        return $result;
    }
    public function quiche_h3_send_goaway(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $id): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $result = $this->ffi->quiche_h3_send_goaway($conn, $quic_conn, $id);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_parse_extensible_priority(void_ptr | uint8_t_ptr | null | string | array $priority, int $priority_len, void_ptr | quiche_h3_priority_ptr | null | array $parsed): int {
        $__ffi_internal_refspriority = [];
        if (\is_string($priority)) {
            $__ffi_str_priority = string_::ownedZero($priority)->getData();
            $priority = $this->ffi->cast("uint8_t*", \FFI::addr($__ffi_str_priority));
        } elseif (\is_array($priority)) {
            $_ = $this->ffi->new("uint8_t[" . \count($priority) . "]");
            $_i = 0;
            if ($priority) {
                if ($_ref = \ReflectionReference::fromArrayElement($priority, \key($priority))) {
                    foreach ($priority as $_k => $_v) {
                        $__ffi_internal_refspriority[$_i] = &$priority[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_originalpriority = $priority = $_;
                } else {
                    foreach ($priority as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $priority = $_;
                }
            }
        } else {
            $priority = $priority?->getData();
            if ($priority !== null) {
                $priority = $this->ffi->cast("uint8_t*", $priority);
            }
        }
        $__ffi_internal_refsparsed = [];
        if (\is_array($parsed)) {
            $_ = $this->ffi->new("quiche_h3_priority[" . \count($parsed) . "]");
            $_i = 0;
            if ($parsed) {
                if ($_ref = \ReflectionReference::fromArrayElement($parsed, \key($parsed))) {
                    foreach ($parsed as $_k => $_v) {
                        $__ffi_internal_refsparsed[$_i] = &$parsed[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalparsed = $parsed = $_;
                } else {
                    foreach ($parsed as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $parsed = $_;
                }
            }
        } else {
            $parsed = $parsed?->getData();
            if ($parsed !== null) {
                $parsed = $this->ffi->cast("quiche_h3_priority*", $parsed);
            }
        }
        $result = $this->ffi->quiche_h3_parse_extensible_priority($priority, $priority_len, $parsed);
        foreach ($__ffi_internal_refspriority as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalpriority[$_k];
        }
        foreach ($__ffi_internal_refsparsed as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_priority");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalparsed[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_priority($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_send_priority_update_for_request(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn, int $stream_id, void_ptr | quiche_h3_priority_ptr | null | array $priority): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $__ffi_internal_refspriority = [];
        if (\is_array($priority)) {
            $_ = $this->ffi->new("quiche_h3_priority[" . \count($priority) . "]");
            $_i = 0;
            if ($priority) {
                if ($_ref = \ReflectionReference::fromArrayElement($priority, \key($priority))) {
                    foreach ($priority as $_k => $_v) {
                        $__ffi_internal_refspriority[$_i] = &$priority[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalpriority = $priority = $_;
                } else {
                    foreach ($priority as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $priority = $_;
                }
            }
        } else {
            $priority = $priority?->getData();
            if ($priority !== null) {
                $priority = $this->ffi->cast("quiche_h3_priority*", $priority);
            }
        }
        $result = $this->ffi->quiche_h3_send_priority_update_for_request($conn, $quic_conn, $stream_id, $priority);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refspriority as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("quiche_h3_priority");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalpriority[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new quiche_h3_priority($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_take_last_priority_update(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, int $prioritized_element_id, void_ptr | function_type_ptr | null | array $cb, iQuiche_ptr | null | array $argp): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refscb = [];
        if (\is_array($cb)) {
            $_ = $this->ffi->new("function type[" . \count($cb) . "]");
            $_i = 0;
            if ($cb) {
                if ($_ref = \ReflectionReference::fromArrayElement($cb, \key($cb))) {
                    foreach ($cb as $_k => $_v) {
                        $__ffi_internal_refscb[$_i] = &$cb[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalcb = $cb = $_;
                } else {
                    foreach ($cb as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $cb = $_;
                }
            }
        } else {
            $cb = $cb?->getData();
            if ($cb !== null) {
                $cb = $this->ffi->cast("int(*)(uint8_t*, uint64_t, void*)", $cb);
            }
        }
        $__ffi_internal_refsargp = [];
        if (\is_array($argp)) {
            $_ = $this->ffi->new("void[" . \count($argp) . "]");
            $_i = 0;
            if ($argp) {
                if ($_ref = \ReflectionReference::fromArrayElement($argp, \key($argp))) {
                    foreach ($argp as $_k => $_v) {
                        $__ffi_internal_refsargp[$_i] = &$argp[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalargp = $argp = $_;
                } else {
                    foreach ($argp as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $argp = $_;
                }
            }
        } else {
            $argp = $argp?->getData();
            if ($argp !== null) {
                $argp = $this->ffi->cast("void*", $argp);
            }
        }
        $result = $this->ffi->quiche_h3_take_last_priority_update($conn, $prioritized_element_id, $cb, $argp);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refscb as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("function type");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalcb[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new function_type($__ffi_internal_ref_v, ['function_type', 'uint8_t_ptr', 'int', 'void_ptr']);
            }
        }
        foreach ($__ffi_internal_refsargp as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalargp[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_dgram_enabled_by_peer(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn, void_ptr | struct_quiche_conn_ptr | null | array $quic_conn): int {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $__ffi_internal_refsquic_conn = [];
        if (\is_array($quic_conn)) {
            $_ = $this->ffi->new("struct quiche_conn[" . \count($quic_conn) . "]");
            $_i = 0;
            if ($quic_conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($quic_conn, \key($quic_conn))) {
                    foreach ($quic_conn as $_k => $_v) {
                        $__ffi_internal_refsquic_conn[$_i] = &$quic_conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalquic_conn = $quic_conn = $_;
                } else {
                    foreach ($quic_conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $quic_conn = $_;
                }
            }
        } else {
            $quic_conn = $quic_conn?->getData();
            if ($quic_conn !== null) {
                $quic_conn = $this->ffi->cast("struct quiche_conn*", $quic_conn);
            }
        }
        $result = $this->ffi->quiche_h3_dgram_enabled_by_peer($conn, $quic_conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refsquic_conn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalquic_conn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_conn($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function quiche_h3_conn_free(void_ptr | struct_quiche_h3_conn_ptr | null | array $conn): void {
        $__ffi_internal_refsconn = [];
        if (\is_array($conn)) {
            $_ = $this->ffi->new("struct quiche_h3_conn[" . \count($conn) . "]");
            $_i = 0;
            if ($conn) {
                if ($_ref = \ReflectionReference::fromArrayElement($conn, \key($conn))) {
                    foreach ($conn as $_k => $_v) {
                        $__ffi_internal_refsconn[$_i] = &$conn[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_originalconn = $conn = $_;
                } else {
                    foreach ($conn as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $conn = $_;
                }
            }
        } else {
            $conn = $conn?->getData();
            if ($conn !== null) {
                $conn = $this->ffi->cast("struct quiche_h3_conn*", $conn);
            }
        }
        $this->ffi->quiche_h3_conn_free($conn);
        foreach ($__ffi_internal_refsconn as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct quiche_h3_conn");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_originalconn[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_quiche_h3_conn($__ffi_internal_ref_v);
            }
        }
    }
    public function setipv4sourcefilter(int $_0, struct_in_addr | null $_1, struct_in_addr | null $_2, int $_3, int $_4, void_ptr | struct_in_addr_ptr | null | array $_5): int {
        $_1 = $_1?->getData();
        $_2 = $_2?->getData();
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("struct in_addr[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("struct in_addr*", $_5);
            }
        }
        $result = $this->ffi->setipv4sourcefilter($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct in_addr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_5[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_in_addr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function getipv4sourcefilter(int $_0, struct_in_addr | null $_1, struct_in_addr | null $_2, void_ptr | uint32_t_ptr | null | array $_3, void_ptr | uint32_t_ptr | null | array $_4, void_ptr | struct_in_addr_ptr | null | array $_5): int {
        $_1 = $_1?->getData();
        $_2 = $_2?->getData();
        $__ffi_internal_refs_3 = [];
        if (\is_array($_3)) {
            $_ = $this->ffi->new("uint32_t[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("uint32_t*", $_3);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("uint32_t[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("uint32_t*", $_4);
            }
        }
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("struct in_addr[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("struct in_addr*", $_5);
            }
        }
        $result = $this->ffi->getipv4sourcefilter($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_3[$_k];
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_4[$_k];
        }
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct in_addr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_5[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_in_addr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function setsourcefilter(int $_0, int $_1, void_ptr | struct_sockaddr_ptr | null | array $_2, int $_3, int $_4, int $_5, void_ptr | struct_sockaddr_storage_ptr | null | array $_6): int {
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("struct sockaddr*", $_2);
            }
        }
        $__ffi_internal_refs_6 = [];
        if (\is_array($_6)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($_6) . "]");
            $_i = 0;
            if ($_6) {
                if ($_ref = \ReflectionReference::fromArrayElement($_6, \key($_6))) {
                    foreach ($_6 as $_k => $_v) {
                        $__ffi_internal_refs_6[$_i] = &$_6[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_6 = $_6 = $_;
                } else {
                    foreach ($_6 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_6 = $_;
                }
            }
        } else {
            $_6 = $_6?->getData();
            if ($_6 !== null) {
                $_6 = $this->ffi->cast("struct sockaddr_storage*", $_6);
            }
        }
        $result = $this->ffi->setsourcefilter($_0, $_1, $_2, $_3, $_4, $_5, $_6);
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_6 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_6[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function getsourcefilter(int $_0, int $_1, void_ptr | struct_sockaddr_ptr | null | array $_2, int $_3, void_ptr | uint32_t_ptr | null | array $_4, void_ptr | uint32_t_ptr | null | array $_5, void_ptr | struct_sockaddr_storage_ptr | null | array $_6): int {
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("struct sockaddr*", $_2);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("uint32_t[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("uint32_t*", $_4);
            }
        }
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("uint32_t[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("uint32_t*", $_5);
            }
        }
        $__ffi_internal_refs_6 = [];
        if (\is_array($_6)) {
            $_ = $this->ffi->new("struct sockaddr_storage[" . \count($_6) . "]");
            $_i = 0;
            if ($_6) {
                if ($_ref = \ReflectionReference::fromArrayElement($_6, \key($_6))) {
                    foreach ($_6 as $_k => $_v) {
                        $__ffi_internal_refs_6[$_i] = &$_6[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_6 = $_6 = $_;
                } else {
                    foreach ($_6 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_6 = $_;
                }
            }
        } else {
            $_6 = $_6?->getData();
            if ($_6 !== null) {
                $_6 = $this->ffi->cast("struct sockaddr_storage*", $_6);
            }
        }
        $result = $this->ffi->getsourcefilter($_0, $_1, $_2, $_3, $_4, $_5, $_6);
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_4[$_k];
        }
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_5[$_k];
        }
        foreach ($__ffi_internal_refs_6 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_storage");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_6[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_storage($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_option_space(int $_0): int {
        $result = $this->ffi->inet6_option_space($_0);
        return $result;
    }
    public function inet6_option_init(iQuiche_ptr | null | array $_0, void_ptr | struct_cmsghdr_ptr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct cmsghdr*[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct cmsghdr**", $_1);
            }
        }
        $result = $this->ffi->inet6_option_init($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_option_append(void_ptr | struct_cmsghdr_ptr | null | array $_0, void_ptr | unsigned_char_ptr | null | string | array $_1, int $_2, int $_3): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_string($_1)) {
            $_1 = string_::ownedZero($_1)->getData();
        } elseif (\is_array($_1)) {
            $_ = $this->ffi->new("unsigned char[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("unsigned char*", $_1);
            }
        }
        $result = $this->ffi->inet6_option_append($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
        }
        return $result;
    }
    public function inet6_option_alloc(void_ptr | struct_cmsghdr_ptr | null | array $_0, int $_1, int $_2, int $_3): ?unsigned_char_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $result = $this->ffi->inet6_option_alloc($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new unsigned_char_ptr($result);
    }
    public function inet6_option_next(void_ptr | struct_cmsghdr_ptr | null | array $_0, void_ptr | unsigned_char_ptr_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("unsigned char*[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("unsigned char**", $_1);
            }
        }
        $result = $this->ffi->inet6_option_next($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new unsigned_char_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_option_find(void_ptr | struct_cmsghdr_ptr | null | array $_0, void_ptr | unsigned_char_ptr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("unsigned char*[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("unsigned char**", $_1);
            }
        }
        $result = $this->ffi->inet6_option_find($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new unsigned_char_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rthdr_space(int $_0, int $_1): int {
        $result = $this->ffi->inet6_rthdr_space($_0, $_1);
        return $result;
    }
    public function inet6_rthdr_init(iQuiche_ptr | null | array $_0, int $_1): ?struct_cmsghdr_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_rthdr_init($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_cmsghdr_ptr($result);
    }
    public function inet6_rthdr_add(void_ptr | struct_cmsghdr_ptr | null | array $_0, void_ptr | struct_in6_addr_ptr | null | array $_1, int $_2): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct in6_addr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct in6_addr*", $_1);
            }
        }
        $result = $this->ffi->inet6_rthdr_add($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct in6_addr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_in6_addr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rthdr_lasthop(void_ptr | struct_cmsghdr_ptr | null | array $_0, int $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $result = $this->ffi->inet6_rthdr_lasthop($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rthdr_segments(void_ptr | struct_cmsghdr_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $result = $this->ffi->inet6_rthdr_segments($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rthdr_getaddr(void_ptr | struct_cmsghdr_ptr | null | array $_0, int $_1): ?struct_in6_addr_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $result = $this->ffi->inet6_rthdr_getaddr($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_in6_addr_ptr($result);
    }
    public function inet6_rthdr_getflags(void_ptr | struct_cmsghdr_ptr | null | array $_0, int $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("struct cmsghdr[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("struct cmsghdr*", $_0);
            }
        }
        $result = $this->ffi->inet6_rthdr_getflags($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct cmsghdr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_cmsghdr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_init(iQuiche_ptr | null | array $_0, int $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_opt_init($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_append(iQuiche_ptr | null | array $_0, int $_1, int $_2, int $_3, int $_4, int $_5, void_ptr | void_ptr_ptr | null | array $_6): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_6 = [];
        if (\is_array($_6)) {
            $_ = $this->ffi->new("void*[" . \count($_6) . "]");
            $_i = 0;
            if ($_6) {
                if ($_ref = \ReflectionReference::fromArrayElement($_6, \key($_6))) {
                    foreach ($_6 as $_k => $_v) {
                        $__ffi_internal_refs_6[$_i] = &$_6[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_6 = $_6 = $_;
                } else {
                    foreach ($_6 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_6 = $_;
                }
            }
        } else {
            $_6 = $_6?->getData();
            if ($_6 !== null) {
                $_6 = $this->ffi->cast("void**", $_6);
            }
        }
        $result = $this->ffi->inet6_opt_append($_0, $_1, $_2, $_3, $_4, $_5, $_6);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_6 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_6[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_finish(iQuiche_ptr | null | array $_0, int $_1, int $_2): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_opt_finish($_0, $_1, $_2);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_set_val(iQuiche_ptr | null | array $_0, int $_1, iQuiche_ptr | null | array $_2, int $_3): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("void[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("void*", $_2);
            }
        }
        $result = $this->ffi->inet6_opt_set_val($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_next(iQuiche_ptr | null | array $_0, int $_1, int $_2, void_ptr | unsigned_char_ptr | null | string | array $_3, void_ptr | unsigned_int_ptr | null | array $_4, void_ptr | void_ptr_ptr | null | array $_5): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_3 = [];
        if (\is_string($_3)) {
            $_3 = string_::ownedZero($_3)->getData();
        } elseif (\is_array($_3)) {
            $_ = $this->ffi->new("unsigned char[" . \count($_3) . "]");
            $_i = 0;
            if ($_3) {
                if ($_ref = \ReflectionReference::fromArrayElement($_3, \key($_3))) {
                    foreach ($_3 as $_k => $_v) {
                        $__ffi_internal_refs_3[$_i] = &$_3[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_3 = $_3 = $_;
                } else {
                    foreach ($_3 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_3 = $_;
                }
            }
        } else {
            $_3 = $_3?->getData();
            if ($_3 !== null) {
                $_3 = $this->ffi->cast("unsigned char*", $_3);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("unsigned int*", $_4);
            }
        }
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("void*[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("void**", $_5);
            }
        }
        $result = $this->ffi->inet6_opt_next($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_3 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_3[$_k];
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_4[$_k];
        }
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_5[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_find(iQuiche_ptr | null | array $_0, int $_1, int $_2, int $_3, void_ptr | unsigned_int_ptr | null | array $_4, void_ptr | void_ptr_ptr | null | array $_5): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_4 = [];
        if (\is_array($_4)) {
            $_ = $this->ffi->new("unsigned int[" . \count($_4) . "]");
            $_i = 0;
            if ($_4) {
                if ($_ref = \ReflectionReference::fromArrayElement($_4, \key($_4))) {
                    foreach ($_4 as $_k => $_v) {
                        $__ffi_internal_refs_4[$_i] = &$_4[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v;
                        }
                    }
                    $__ffi_internal_original_4 = $_4 = $_;
                } else {
                    foreach ($_4 as $_v) {
                        $_[$_i++] = $_v ?? 0;
                    }
                    $_4 = $_;
                }
            }
        } else {
            $_4 = $_4?->getData();
            if ($_4 !== null) {
                $_4 = $this->ffi->cast("unsigned int*", $_4);
            }
        }
        $__ffi_internal_refs_5 = [];
        if (\is_array($_5)) {
            $_ = $this->ffi->new("void*[" . \count($_5) . "]");
            $_i = 0;
            if ($_5) {
                if ($_ref = \ReflectionReference::fromArrayElement($_5, \key($_5))) {
                    foreach ($_5 as $_k => $_v) {
                        $__ffi_internal_refs_5[$_i] = &$_5[$_k];
                        $_[$_i++] = $_v?->getData();
                    }
                    $__ffi_internal_original_5 = $_5 = $_;
                } else {
                    foreach ($_5 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_5 = $_;
                }
            }
        } else {
            $_5 = $_5?->getData();
            if ($_5 !== null) {
                $_5 = $this->ffi->cast("void**", $_5);
            }
        }
        $result = $this->ffi->inet6_opt_find($_0, $_1, $_2, $_3, $_4, $_5);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_4 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_4[$_k];
        }
        foreach ($__ffi_internal_refs_5 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_5[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void_ptr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_opt_get_val(iQuiche_ptr | null | array $_0, int $_1, iQuiche_ptr | null | array $_2, int $_3): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_2 = [];
        if (\is_array($_2)) {
            $_ = $this->ffi->new("void[" . \count($_2) . "]");
            $_i = 0;
            if ($_2) {
                if ($_ref = \ReflectionReference::fromArrayElement($_2, \key($_2))) {
                    foreach ($_2 as $_k => $_v) {
                        $__ffi_internal_refs_2[$_i] = &$_2[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_2 = $_2 = $_;
                } else {
                    foreach ($_2 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_2 = $_;
                }
            }
        } else {
            $_2 = $_2?->getData();
            if ($_2 !== null) {
                $_2 = $this->ffi->cast("void*", $_2);
            }
        }
        $result = $this->ffi->inet6_opt_get_val($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_2 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_2[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rth_space(int $_0, int $_1): int {
        $result = $this->ffi->inet6_rth_space($_0, $_1);
        return $result;
    }
    public function inet6_rth_init(iQuiche_ptr | null | array $_0, int $_1, int $_2, int $_3): ?void_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_rth_init($_0, $_1, $_2, $_3);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new void_ptr($result);
    }
    public function inet6_rth_add(iQuiche_ptr | null | array $_0, void_ptr | struct_in6_addr_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct in6_addr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct in6_addr*", $_1);
            }
        }
        $result = $this->ffi->inet6_rth_add($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct in6_addr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_in6_addr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rth_reverse(iQuiche_ptr | null | array $_0, iQuiche_ptr | null | array $_1): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("void[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("void*", $_1);
            }
        }
        $result = $this->ffi->inet6_rth_reverse($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rth_segments(iQuiche_ptr | null | array $_0): int {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_rth_segments($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function inet6_rth_getaddr(iQuiche_ptr | null | array $_0, int $_1): ?struct_in6_addr_ptr {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            if ($_0) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, \key($_0))) {
                    foreach ($_0 as $_k => $_v) {
                        $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_0 = $_0 = $_;
                } else {
                    foreach ($_0 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_0 = $_;
                }
            }
        } else {
            $_0 = $_0?->getData();
            if ($_0 !== null) {
                $_0 = $this->ffi->cast("void*", $_0);
            }
        }
        $result = $this->ffi->inet6_rth_getaddr($_0, $_1);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_0[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result === null ? null : new struct_in6_addr_ptr($result);
    }
    public function bindresvport(int $_0, void_ptr | struct_sockaddr_in_ptr | null | array $_1): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr_in[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr_in*", $_1);
            }
        }
        $result = $this->ffi->bindresvport($_0, $_1);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr_in");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr_in($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function bindresvport_sa(int $_0, void_ptr | struct_sockaddr_ptr | null | array $_1): int {
        $__ffi_internal_refs_1 = [];
        if (\is_array($_1)) {
            $_ = $this->ffi->new("struct sockaddr[" . \count($_1) . "]");
            $_i = 0;
            if ($_1) {
                if ($_ref = \ReflectionReference::fromArrayElement($_1, \key($_1))) {
                    foreach ($_1 as $_k => $_v) {
                        $__ffi_internal_refs_1[$_i] = &$_1[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_1 = $_1 = $_;
                } else {
                    foreach ($_1 as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_1 = $_;
                }
            }
        } else {
            $_1 = $_1?->getData();
            if ($_1 !== null) {
                $_1 = $this->ffi->cast("struct sockaddr*", $_1);
            }
        }
        $result = $this->ffi->bindresvport_sa($_0, $_1);
        foreach ($__ffi_internal_refs_1 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct sockaddr");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_1[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_sockaddr($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    public function _OSSwapInt16(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt16($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt16(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        return ((int) ((($_data)->cdata << 8) | (($_data)->cdata >> 8)));
    }
    public function _OSSwapInt32(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt32($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt32(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        throw new \LogicException("Unsupported assembly statement");
        return ($_data)->cdata;
    }
    public function _OSSwapInt64(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt64($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt64(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        throw new \LogicException("Unsupported assembly statement");
        return ($_data)->cdata;
    }
    public function __darwin_check_fd_set(int $_a, iQuiche_ptr | null | array $_b): int {
        $__ffi_internal_refs_b = [];
        if (\is_array($_b)) {
            $_ = $this->ffi->new("void[" . \count($_b) . "]");
            $_i = 0;
            if ($_b) {
                if ($_ref = \ReflectionReference::fromArrayElement($_b, \key($_b))) {
                    foreach ($_b as $_k => $_v) {
                        $__ffi_internal_refs_b[$_i] = &$_b[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_b = $_b = $_;
                } else {
                    foreach ($_b as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_b = $_;
                }
            }
        } else {
            $_b = $_b?->getData();
            if ($_b !== null) {
                $_b = $this->ffi->cast("void*", $_b);
            }
        }
        $result = $this->_ffi_internal___darwin_check_fd_set($_a, $_b);
        foreach ($__ffi_internal_refs_b as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("void");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_b[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new void($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    private function _ffi_internal___darwin_check_fd_set(int $_a, FFI\CData $_b): int {
        $_a = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_a);
        if ((((int) [$this->ffi, "__darwin_check_fd_set_overflow"]) != ((int) 0))) {
            return $this->ffi->__darwin_check_fd_set_overflow(($_a)->cdata, $_b, 0);
        } else {
            return 1;
        }
    }
    public function __darwin_fd_isset(int $_fd, void_ptr | struct_fd_set_ptr | null | array $_p): int {
        $__ffi_internal_refs_p = [];
        if (\is_array($_p)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_p) . "]");
            $_i = 0;
            if ($_p) {
                if ($_ref = \ReflectionReference::fromArrayElement($_p, \key($_p))) {
                    foreach ($_p as $_k => $_v) {
                        $__ffi_internal_refs_p[$_i] = &$_p[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_p = $_p = $_;
                } else {
                    foreach ($_p as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_p = $_;
                }
            }
        } else {
            $_p = $_p?->getData();
            if ($_p !== null) {
                $_p = $this->ffi->cast("struct fd_set*", $_p);
            }
        }
        $result = $this->_ffi_internal___darwin_fd_isset($_fd, $_p);
        foreach ($__ffi_internal_refs_p as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_p[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
        return $result;
    }
    private function _ffi_internal___darwin_fd_isset(int $_fd, FFI\CData $_p): int {
        $_fd = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_fd);
        if ($this->_ffi_internal___darwin_check_fd_set(($_fd)->cdata, $this->ffi->cast("void*", $_p))) {
            return (($_p)[0]->fds_bits[(((int) ($_fd)->cdata) / (FFI::sizeof($this->ffi->type("int")) * 8))] & ((int) (((int) 1) << (((int) ($_fd)->cdata) % (FFI::sizeof($this->ffi->type("int")) * 8)))));
        }
        return 0;
    }
    public function __darwin_fd_set(int $_fd, void_ptr | struct_fd_set_ptr | null | array $_p): void {
        $__ffi_internal_refs_p = [];
        if (\is_array($_p)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_p) . "]");
            $_i = 0;
            if ($_p) {
                if ($_ref = \ReflectionReference::fromArrayElement($_p, \key($_p))) {
                    foreach ($_p as $_k => $_v) {
                        $__ffi_internal_refs_p[$_i] = &$_p[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_p = $_p = $_;
                } else {
                    foreach ($_p as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_p = $_;
                }
            }
        } else {
            $_p = $_p?->getData();
            if ($_p !== null) {
                $_p = $this->ffi->cast("struct fd_set*", $_p);
            }
        }
        $this->_ffi_internal___darwin_fd_set($_fd, $_p);
        foreach ($__ffi_internal_refs_p as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_p[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
    }
    private function _ffi_internal___darwin_fd_set(int $_fd, FFI\CData $_p): void {
        $_fd = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_fd);
        if ($this->_ffi_internal___darwin_check_fd_set(($_fd)->cdata, $this->ffi->cast("void*", $_p))) {
            (($_p)[0]->fds_bits[(((int) ($_fd)->cdata) / (FFI::sizeof($this->ffi->type("int")) * 8))] |= ((int) (((int) 1) << (((int) ($_fd)->cdata) % (FFI::sizeof($this->ffi->type("int")) * 8)))));
        }
    }
    public function __darwin_fd_clr(int $_fd, void_ptr | struct_fd_set_ptr | null | array $_p): void {
        $__ffi_internal_refs_p = [];
        if (\is_array($_p)) {
            $_ = $this->ffi->new("struct fd_set[" . \count($_p) . "]");
            $_i = 0;
            if ($_p) {
                if ($_ref = \ReflectionReference::fromArrayElement($_p, \key($_p))) {
                    foreach ($_p as $_k => $_v) {
                        $__ffi_internal_refs_p[$_i] = &$_p[$_k];
                        if ($_v !== null) {
                            $_[$_i++] = $_v->getData();
                        }
                    }
                    $__ffi_internal_original_p = $_p = $_;
                } else {
                    foreach ($_p as $_v) {
                        $_[$_i++] = $_v?->getData();
                    }
                    $_p = $_;
                }
            }
        } else {
            $_p = $_p?->getData();
            if ($_p !== null) {
                $_p = $this->ffi->cast("struct fd_set*", $_p);
            }
        }
        $this->_ffi_internal___darwin_fd_clr($_fd, $_p);
        foreach ($__ffi_internal_refs_p as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $this->ffi->new("struct fd_set");
            \FFI::addr($__ffi_internal_ref_v)[0] = $__ffi_internal_original_p[$_k];
            if ($__ffi_internal_ref_v !== null) {
                $__ffi_internal_ref_v = new struct_fd_set($__ffi_internal_ref_v);
            }
        }
    }
    private function _ffi_internal___darwin_fd_clr(int $_fd, FFI\CData $_p): void {
        $_fd = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_fd);
        if ($this->_ffi_internal___darwin_check_fd_set(($_fd)->cdata, $this->ffi->cast("void*", $_p))) {
            (($_p)[0]->fds_bits[(((int) ($_fd)->cdata) / (FFI::sizeof($this->ffi->type("int")) * 8))] &= (~((int) (((int) 1) << (((int) ($_fd)->cdata) % (FFI::sizeof($this->ffi->type("int")) * 8))))));
        }
    }
}

class string_ implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr { return new string_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return \ord($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = \chr($value); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while ("\0" !== $cur = $this->data[$i++]) { $ret[] = \ord($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = \ord($this->data[$i]); } } return $ret; }
    public function toString(?int $length = null): string { return $length === null ? FFI::string($this->data) : FFI::string($this->data, $length); }
    public static function persistent(string $string): self { $str = new self(FFI::cdef()->new("char[" . \strlen($string) . "]", false)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function owned(string $string): self { $str = new self(FFI::cdef()->new("char[" . \strlen($string) . "]", true)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function persistentZero(string $string): self { return self::persistent("$string\0"); }
    public static function ownedZero(string $string): self { return self::owned("$string\0"); }
    public function set(int | void_ptr | string_ $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = \chr($value);
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'char*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr { return new string_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): string_ { return new string_($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return string_[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr_ptr { return new string_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): string_ptr { return new string_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return string_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr_ptr_ptr { return new string_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): string_ptr_ptr { return new string_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return string_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr implements iQuiche, iQuiche_ptr {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr { return new void_ptr_ptr(FFI::addr($this->data)); }
    public function set(iQuiche_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr { return new void_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): void_ptr { return new void_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return void_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr_ptr { return new void_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): void_ptr_ptr { return new void_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return void_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr_ptr_ptr { return new void_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): void_ptr_ptr_ptr { return new void_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return void_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class function_type_ptr implements iQuiche, iQuiche_ptr {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr { return new function_type_ptr_ptr(FFI::addr($this->data)); }
    public function set(callable | void_ptr | function_type_ptr $value): void {
        if ($value instanceof void_ptr) {
            $value = $value->getData();
        } elseif ($value instanceof function_type_ptr) {
            if ($value->types != $this->types) {
                throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
            }
            $value = $value->getData();
        } else {
            $types = $this->types;
            $value = static function (...$args) use ($value, $types) {
                foreach ($args as $i => $arg) {
                    $type = $types[$i + 1];
                    if ($type === "char") {
                        $args[$i] = \chr($arg);
                    } elseif (\is_array($type)) {
                        $args[$i] = new (__NAMESPACE__ . "\\" . $type[0])($arg, array_slice($type, 1));
                    } elseif ($type !== "int" && $type !== "float") {
                        $args[$i] = new (__NAMESPACE__ . "\\" . $type)($arg);
                    }
                }
                $ret = $value(...$args);
                if ($types[0] === "int" || $types === "float") {
                    return $ret;
                } elseif ($types[0] === "char") {
                    return \chr($ret);
                } elseif ($types[0] !== null) {
                    return $ret->getData();
                }
            };
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(*)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(*)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr { return new function_type_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(**)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(**)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr_ptr { return new function_type_ptr_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(***)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(***)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr_ptr_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr_ptr_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(****)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(****)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class __builtin_va_list implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr { return new __builtin_va_list_ptr(FFI::addr($this->data)); }
    public function set(__builtin_va_list $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr { return new __builtin_va_list_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __builtin_va_list { return new __builtin_va_list($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __builtin_va_list[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list($this->data[$i]); } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __builtin_va_list_ptr { return new __builtin_va_list_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __builtin_va_list_ptr_ptr { return new __builtin_va_list_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __builtin_va_list_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mbstate8
 * @property int $_mbstateL
 */
class __mbstate_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr { return new __mbstate_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__mbstate8": return new string_($this->data->__mbstate8);
            case "_mbstateL": return $this->data->_mbstateL;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mbstate8":
                (new string_($_ = &$this->data->__mbstate8))->set($value);
                return;
            case "_mbstateL":
                $this->data->_mbstateL = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(__mbstate_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mbstate8
 * @property int $_mbstateL
 */
class __mbstate_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr { return new __mbstate_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __mbstate_t { return new __mbstate_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __mbstate_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__mbstate8": return new string_($this->data[0]->__mbstate8);
            case "_mbstateL": return $this->data[0]->_mbstateL;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mbstate8":
                (new string_($_ = &$this->data[0]->__mbstate8))->set($value);
                return;
            case "_mbstateL":
                $this->data[0]->_mbstateL = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | __mbstate_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __mbstate_t_ptr { return new __mbstate_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __mbstate_t_ptr_ptr { return new __mbstate_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): __mbstate_t_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__routine
 * @property void_ptr $__arg
 * @property struct___darwin_pthread_handler_rec_ptr $__next
 */
class struct___darwin_pthread_handler_rec implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr { return new struct___darwin_pthread_handler_rec_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__routine": return new function_type_ptr($this->data->__routine, [NULL, 'void_ptr']);
            case "__arg": return new void_ptr($this->data->__arg);
            case "__next": return new struct___darwin_pthread_handler_rec_ptr($this->data->__next);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__routine":
                (new function_type_ptr($_ = &$this->data->__routine, [NULL, 'void_ptr']))->set($value);
                return;
            case "__arg":
                (new void_ptr($_ = &$this->data->__arg))->set($value);
                return;
            case "__next":
                (new struct___darwin_pthread_handler_rec_ptr($_ = &$this->data->__next))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_pthread_handler_rec $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__routine
 * @property void_ptr $__arg
 * @property struct___darwin_pthread_handler_rec_ptr $__next
 */
class struct___darwin_pthread_handler_rec_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec { return new struct___darwin_pthread_handler_rec($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__routine": return new function_type_ptr($this->data[0]->__routine, [NULL, 'void_ptr']);
            case "__arg": return new void_ptr($this->data[0]->__arg);
            case "__next": return new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__next);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__routine":
                (new function_type_ptr($_ = &$this->data[0]->__routine, [NULL, 'void_ptr']))->set($value);
                return;
            case "__arg":
                (new void_ptr($_ = &$this->data[0]->__arg))->set($value);
                return;
            case "__next":
                (new struct___darwin_pthread_handler_rec_ptr($_ = &$this->data[0]->__next))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr { return new struct___darwin_pthread_handler_rec_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_attr_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr { return new struct__opaque_pthread_attr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_attr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_attr_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t { return new struct__opaque_pthread_attr_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr { return new struct__opaque_pthread_attr_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_cond_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr { return new struct__opaque_pthread_cond_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_cond_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_cond_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t { return new struct__opaque_pthread_cond_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr { return new struct__opaque_pthread_cond_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_condattr_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr { return new struct__opaque_pthread_condattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_condattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_condattr_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t { return new struct__opaque_pthread_condattr_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr { return new struct__opaque_pthread_condattr_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutex_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr { return new struct__opaque_pthread_mutex_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_mutex_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutex_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t { return new struct__opaque_pthread_mutex_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr { return new struct__opaque_pthread_mutex_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutexattr_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr { return new struct__opaque_pthread_mutexattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_mutexattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutexattr_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t { return new struct__opaque_pthread_mutexattr_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr { return new struct__opaque_pthread_mutexattr_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_once_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr { return new struct__opaque_pthread_once_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_once_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_once_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t { return new struct__opaque_pthread_once_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr { return new struct__opaque_pthread_once_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlock_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr { return new struct__opaque_pthread_rwlock_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_rwlock_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlock_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t { return new struct__opaque_pthread_rwlock_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr { return new struct__opaque_pthread_rwlock_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlockattr_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_rwlockattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlockattr_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t { return new struct__opaque_pthread_rwlockattr_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property struct___darwin_pthread_handler_rec_ptr $__cleanup_stack
 * @property string_ $__opaque
 */
class struct__opaque_pthread_t implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr { return new struct__opaque_pthread_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__cleanup_stack": return new struct___darwin_pthread_handler_rec_ptr($this->data->__cleanup_stack);
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                return;
            case "__cleanup_stack":
                (new struct___darwin_pthread_handler_rec_ptr($_ = &$this->data->__cleanup_stack))->set($value);
                return;
            case "__opaque":
                (new string_($_ = &$this->data->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property struct___darwin_pthread_handler_rec_ptr $__cleanup_stack
 * @property string_ $__opaque
 */
class struct__opaque_pthread_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_t { return new struct__opaque_pthread_t($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__cleanup_stack": return new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__cleanup_stack);
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                return;
            case "__cleanup_stack":
                (new struct___darwin_pthread_handler_rec_ptr($_ = &$this->data[0]->__cleanup_stack))->set($value);
                return;
            case "__opaque":
                (new string_($_ = &$this->data[0]->__opaque))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr { return new struct__opaque_pthread_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $fds_bits
 */
class struct_fd_set implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_fd_set $other): bool { return $this->data == $other->data; }
    public function addr(): struct_fd_set_ptr { return new struct_fd_set_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "fds_bits": return new int_ptr($this->data->fds_bits);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "fds_bits":
                (new int_ptr($_ = &$this->data->fds_bits))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_fd_set $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct fd_set'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $fds_bits
 */
class struct_fd_set_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_fd_set_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_fd_set_ptr_ptr { return new struct_fd_set_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_fd_set { return new struct_fd_set($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_fd_set { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_fd_set[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_fd_set($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "fds_bits": return new int_ptr($this->data[0]->fds_bits);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "fds_bits":
                (new int_ptr($_ = &$this->data[0]->fds_bits))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_fd_set_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct fd_set*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_fd_set_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_fd_set_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_fd_set_ptr_ptr_ptr { return new struct_fd_set_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_fd_set_ptr { return new struct_fd_set_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_fd_set_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_fd_set_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_fd_set_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_fd_set_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_fd_set_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct fd_set**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_fd_set_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_fd_set_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_fd_set_ptr_ptr_ptr_ptr { return new struct_fd_set_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_fd_set_ptr_ptr { return new struct_fd_set_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_fd_set_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_fd_set_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_fd_set_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_fd_set_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_fd_set_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct fd_set***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_fd_set_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_fd_set_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_fd_set_ptr_ptr_ptr_ptr_ptr { return new struct_fd_set_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_fd_set_ptr_ptr_ptr { return new struct_fd_set_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_fd_set_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_fd_set_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_fd_set_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_fd_set_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_fd_set_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct fd_set****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $iov_base
 * @property int $iov_len
 */
class struct_iovec implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_iovec $other): bool { return $this->data == $other->data; }
    public function addr(): struct_iovec_ptr { return new struct_iovec_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "iov_base": return new void_ptr($this->data->iov_base);
            case "iov_len": return $this->data->iov_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "iov_base":
                (new void_ptr($_ = &$this->data->iov_base))->set($value);
                return;
            case "iov_len":
                $this->data->iov_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_iovec $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct iovec'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $iov_base
 * @property int $iov_len
 */
class struct_iovec_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_iovec_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_iovec_ptr_ptr { return new struct_iovec_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_iovec { return new struct_iovec($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_iovec { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_iovec[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_iovec($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "iov_base": return new void_ptr($this->data[0]->iov_base);
            case "iov_len": return $this->data[0]->iov_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "iov_base":
                (new void_ptr($_ = &$this->data[0]->iov_base))->set($value);
                return;
            case "iov_len":
                $this->data[0]->iov_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_iovec_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct iovec*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_iovec_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_iovec_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_iovec_ptr_ptr_ptr { return new struct_iovec_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_iovec_ptr { return new struct_iovec_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_iovec_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_iovec_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_iovec_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_iovec_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_iovec_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct iovec**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_iovec_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_iovec_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_iovec_ptr_ptr_ptr_ptr { return new struct_iovec_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_iovec_ptr_ptr { return new struct_iovec_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_iovec_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_iovec_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_iovec_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_iovec_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_iovec_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct iovec***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_iovec_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_iovec_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_iovec_ptr_ptr_ptr_ptr_ptr { return new struct_iovec_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_iovec_ptr_ptr_ptr { return new struct_iovec_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_iovec_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_iovec_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_iovec_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_iovec_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_iovec_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct iovec****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sae_srcif
 * @property struct_sockaddr_ptr $sae_srcaddr
 * @property int $sae_srcaddrlen
 * @property struct_sockaddr_ptr $sae_dstaddr
 * @property int $sae_dstaddrlen
 */
class struct_sa_endpoints implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sa_endpoints $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sa_endpoints_ptr { return new struct_sa_endpoints_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sae_srcif": return $this->data->sae_srcif;
            case "sae_srcaddr": return new struct_sockaddr_ptr($this->data->sae_srcaddr);
            case "sae_srcaddrlen": return $this->data->sae_srcaddrlen;
            case "sae_dstaddr": return new struct_sockaddr_ptr($this->data->sae_dstaddr);
            case "sae_dstaddrlen": return $this->data->sae_dstaddrlen;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sae_srcif":
                $this->data->sae_srcif = $value;
                return;
            case "sae_srcaddr":
                (new struct_sockaddr_ptr($_ = &$this->data->sae_srcaddr))->set($value);
                return;
            case "sae_srcaddrlen":
                $this->data->sae_srcaddrlen = $value;
                return;
            case "sae_dstaddr":
                (new struct_sockaddr_ptr($_ = &$this->data->sae_dstaddr))->set($value);
                return;
            case "sae_dstaddrlen":
                $this->data->sae_dstaddrlen = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sa_endpoints $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sa_endpoints'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sae_srcif
 * @property struct_sockaddr_ptr $sae_srcaddr
 * @property int $sae_srcaddrlen
 * @property struct_sockaddr_ptr $sae_dstaddr
 * @property int $sae_dstaddrlen
 */
class struct_sa_endpoints_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sa_endpoints_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sa_endpoints_ptr_ptr { return new struct_sa_endpoints_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sa_endpoints { return new struct_sa_endpoints($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sa_endpoints { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sa_endpoints[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sa_endpoints($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sae_srcif": return $this->data[0]->sae_srcif;
            case "sae_srcaddr": return new struct_sockaddr_ptr($this->data[0]->sae_srcaddr);
            case "sae_srcaddrlen": return $this->data[0]->sae_srcaddrlen;
            case "sae_dstaddr": return new struct_sockaddr_ptr($this->data[0]->sae_dstaddr);
            case "sae_dstaddrlen": return $this->data[0]->sae_dstaddrlen;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sae_srcif":
                $this->data[0]->sae_srcif = $value;
                return;
            case "sae_srcaddr":
                (new struct_sockaddr_ptr($_ = &$this->data[0]->sae_srcaddr))->set($value);
                return;
            case "sae_srcaddrlen":
                $this->data[0]->sae_srcaddrlen = $value;
                return;
            case "sae_dstaddr":
                (new struct_sockaddr_ptr($_ = &$this->data[0]->sae_dstaddr))->set($value);
                return;
            case "sae_dstaddrlen":
                $this->data[0]->sae_dstaddrlen = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sa_endpoints_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sa_endpoints*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sa_endpoints_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sa_endpoints_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sa_endpoints_ptr_ptr_ptr { return new struct_sa_endpoints_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sa_endpoints_ptr { return new struct_sa_endpoints_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sa_endpoints_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sa_endpoints_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sa_endpoints_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sa_endpoints_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sa_endpoints_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sa_endpoints**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sa_endpoints_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sa_endpoints_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sa_endpoints_ptr_ptr_ptr_ptr { return new struct_sa_endpoints_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sa_endpoints_ptr_ptr { return new struct_sa_endpoints_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sa_endpoints_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sa_endpoints_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sa_endpoints_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sa_endpoints_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sa_endpoints_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sa_endpoints***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sa_endpoints_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sa_endpoints_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sa_endpoints_ptr_ptr_ptr_ptr_ptr { return new struct_sa_endpoints_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sa_endpoints_ptr_ptr_ptr { return new struct_sa_endpoints_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sa_endpoints_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sa_endpoints_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sa_endpoints_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sa_endpoints_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sa_endpoints_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sa_endpoints****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $l_onoff
 * @property int $l_linger
 */
class struct_linger implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_linger $other): bool { return $this->data == $other->data; }
    public function addr(): struct_linger_ptr { return new struct_linger_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "l_onoff": return $this->data->l_onoff;
            case "l_linger": return $this->data->l_linger;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "l_onoff":
                $this->data->l_onoff = $value;
                return;
            case "l_linger":
                $this->data->l_linger = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_linger $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct linger'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $l_onoff
 * @property int $l_linger
 */
class struct_linger_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_linger_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_linger_ptr_ptr { return new struct_linger_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_linger { return new struct_linger($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_linger { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_linger[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_linger($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "l_onoff": return $this->data[0]->l_onoff;
            case "l_linger": return $this->data[0]->l_linger;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "l_onoff":
                $this->data[0]->l_onoff = $value;
                return;
            case "l_linger":
                $this->data[0]->l_linger = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_linger_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct linger*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_linger_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_linger_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_linger_ptr_ptr_ptr { return new struct_linger_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_linger_ptr { return new struct_linger_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_linger_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_linger_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_linger_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_linger_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_linger_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct linger**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_linger_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_linger_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_linger_ptr_ptr_ptr_ptr { return new struct_linger_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_linger_ptr_ptr { return new struct_linger_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_linger_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_linger_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_linger_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_linger_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_linger_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct linger***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_linger_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_linger_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_linger_ptr_ptr_ptr_ptr_ptr { return new struct_linger_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_linger_ptr_ptr_ptr { return new struct_linger_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_linger_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_linger_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_linger_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_linger_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_linger_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct linger****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $af_name
 * @property string_ $af_arg
 */
class struct_accept_filter_arg implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_accept_filter_arg $other): bool { return $this->data == $other->data; }
    public function addr(): struct_accept_filter_arg_ptr { return new struct_accept_filter_arg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "af_name": return new string_($this->data->af_name);
            case "af_arg": return new string_($this->data->af_arg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "af_name":
                (new string_($_ = &$this->data->af_name))->set($value);
                return;
            case "af_arg":
                (new string_($_ = &$this->data->af_arg))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_accept_filter_arg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct accept_filter_arg'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $af_name
 * @property string_ $af_arg
 */
class struct_accept_filter_arg_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_accept_filter_arg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_accept_filter_arg_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_accept_filter_arg { return new struct_accept_filter_arg($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_accept_filter_arg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_accept_filter_arg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_accept_filter_arg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "af_name": return new string_($this->data[0]->af_name);
            case "af_arg": return new string_($this->data[0]->af_arg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "af_name":
                (new string_($_ = &$this->data[0]->af_name))->set($value);
                return;
            case "af_arg":
                (new string_($_ = &$this->data[0]->af_arg))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_accept_filter_arg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct accept_filter_arg*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_accept_filter_arg_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_accept_filter_arg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_accept_filter_arg_ptr_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_accept_filter_arg_ptr { return new struct_accept_filter_arg_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_accept_filter_arg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_accept_filter_arg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_accept_filter_arg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_accept_filter_arg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_accept_filter_arg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct accept_filter_arg**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_accept_filter_arg_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_accept_filter_arg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_accept_filter_arg_ptr_ptr_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_accept_filter_arg_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_accept_filter_arg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_accept_filter_arg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_accept_filter_arg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_accept_filter_arg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_accept_filter_arg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct accept_filter_arg***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_accept_filter_arg_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_accept_filter_arg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_accept_filter_arg_ptr_ptr_ptr_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_accept_filter_arg_ptr_ptr_ptr { return new struct_accept_filter_arg_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_accept_filter_arg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_accept_filter_arg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_accept_filter_arg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_accept_filter_arg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_accept_filter_arg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct accept_filter_arg****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sa_len
 * @property int $sa_family
 * @property string_ $sa_data
 */
class struct_sockaddr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_ptr { return new struct_sockaddr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sa_len": return $this->data->sa_len;
            case "sa_family": return $this->data->sa_family;
            case "sa_data": return new string_($this->data->sa_data);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sa_len":
                $this->data->sa_len = $value;
                return;
            case "sa_family":
                $this->data->sa_family = $value;
                return;
            case "sa_data":
                (new string_($_ = &$this->data->sa_data))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sockaddr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sa_len
 * @property int $sa_family
 * @property string_ $sa_data
 */
class struct_sockaddr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_ptr_ptr { return new struct_sockaddr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr { return new struct_sockaddr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sa_len": return $this->data[0]->sa_len;
            case "sa_family": return $this->data[0]->sa_family;
            case "sa_data": return new string_($this->data[0]->sa_data);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sa_len":
                $this->data[0]->sa_len = $value;
                return;
            case "sa_family":
                $this->data[0]->sa_family = $value;
                return;
            case "sa_data":
                (new string_($_ = &$this->data[0]->sa_data))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sockaddr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_ptr_ptr_ptr { return new struct_sockaddr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_ptr { return new struct_sockaddr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_ptr_ptr_ptr_ptr { return new struct_sockaddr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_ptr_ptr { return new struct_sockaddr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_ptr_ptr_ptr_ptr_ptr { return new struct_sockaddr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_ptr_ptr_ptr { return new struct_sockaddr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sa_len
 * @property int $sa_family
 */
class struct___sockaddr_header implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sockaddr_header $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sockaddr_header_ptr { return new struct___sockaddr_header_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sa_len": return $this->data->sa_len;
            case "sa_family": return $this->data->sa_family;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sa_len":
                $this->data->sa_len = $value;
                return;
            case "sa_family":
                $this->data->sa_family = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___sockaddr_header $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sockaddr_header'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sa_len
 * @property int $sa_family
 */
class struct___sockaddr_header_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sockaddr_header_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sockaddr_header_ptr_ptr { return new struct___sockaddr_header_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___sockaddr_header { return new struct___sockaddr_header($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sockaddr_header { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___sockaddr_header[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sockaddr_header($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sa_len": return $this->data[0]->sa_len;
            case "sa_family": return $this->data[0]->sa_family;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sa_len":
                $this->data[0]->sa_len = $value;
                return;
            case "sa_family":
                $this->data[0]->sa_family = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___sockaddr_header_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sockaddr_header*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sockaddr_header_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sockaddr_header_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sockaddr_header_ptr_ptr_ptr { return new struct___sockaddr_header_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___sockaddr_header_ptr { return new struct___sockaddr_header_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sockaddr_header_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___sockaddr_header_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sockaddr_header_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sockaddr_header_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sockaddr_header_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sockaddr_header**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sockaddr_header_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sockaddr_header_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sockaddr_header_ptr_ptr_ptr_ptr { return new struct___sockaddr_header_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___sockaddr_header_ptr_ptr { return new struct___sockaddr_header_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sockaddr_header_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___sockaddr_header_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sockaddr_header_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sockaddr_header_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sockaddr_header_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sockaddr_header***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sockaddr_header_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sockaddr_header_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sockaddr_header_ptr_ptr_ptr_ptr_ptr { return new struct___sockaddr_header_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___sockaddr_header_ptr_ptr_ptr { return new struct___sockaddr_header_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sockaddr_header_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___sockaddr_header_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sockaddr_header_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sockaddr_header_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sockaddr_header_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sockaddr_header****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sp_family
 * @property int $sp_protocol
 */
class struct_sockproto implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockproto $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockproto_ptr { return new struct_sockproto_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sp_family": return $this->data->sp_family;
            case "sp_protocol": return $this->data->sp_protocol;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sp_family":
                $this->data->sp_family = $value;
                return;
            case "sp_protocol":
                $this->data->sp_protocol = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sockproto $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockproto'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sp_family
 * @property int $sp_protocol
 */
class struct_sockproto_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockproto_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockproto_ptr_ptr { return new struct_sockproto_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockproto { return new struct_sockproto($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockproto { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockproto[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockproto($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sp_family": return $this->data[0]->sp_family;
            case "sp_protocol": return $this->data[0]->sp_protocol;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sp_family":
                $this->data[0]->sp_family = $value;
                return;
            case "sp_protocol":
                $this->data[0]->sp_protocol = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sockproto_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockproto*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockproto_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockproto_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockproto_ptr_ptr_ptr { return new struct_sockproto_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockproto_ptr { return new struct_sockproto_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockproto_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockproto_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockproto_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockproto_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockproto_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockproto**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockproto_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockproto_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockproto_ptr_ptr_ptr_ptr { return new struct_sockproto_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockproto_ptr_ptr { return new struct_sockproto_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockproto_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockproto_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockproto_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockproto_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockproto_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockproto***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockproto_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockproto_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockproto_ptr_ptr_ptr_ptr_ptr { return new struct_sockproto_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockproto_ptr_ptr_ptr { return new struct_sockproto_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockproto_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockproto_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockproto_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockproto_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockproto_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockproto****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $ss_len
 * @property int $ss_family
 * @property string_ $__ss_pad1
 * @property int $__ss_align
 * @property string_ $__ss_pad2
 */
class struct_sockaddr_storage implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_storage $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_storage_ptr { return new struct_sockaddr_storage_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ss_len": return $this->data->ss_len;
            case "ss_family": return $this->data->ss_family;
            case "__ss_pad1": return new string_($this->data->__ss_pad1);
            case "__ss_align": return $this->data->__ss_align;
            case "__ss_pad2": return new string_($this->data->__ss_pad2);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_len":
                $this->data->ss_len = $value;
                return;
            case "ss_family":
                $this->data->ss_family = $value;
                return;
            case "__ss_pad1":
                (new string_($_ = &$this->data->__ss_pad1))->set($value);
                return;
            case "__ss_align":
                $this->data->__ss_align = $value;
                return;
            case "__ss_pad2":
                (new string_($_ = &$this->data->__ss_pad2))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sockaddr_storage $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_storage'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $ss_len
 * @property int $ss_family
 * @property string_ $__ss_pad1
 * @property int $__ss_align
 * @property string_ $__ss_pad2
 */
class struct_sockaddr_storage_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_storage_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_storage_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_storage { return new struct_sockaddr_storage($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_storage { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_storage[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_storage($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ss_len": return $this->data[0]->ss_len;
            case "ss_family": return $this->data[0]->ss_family;
            case "__ss_pad1": return new string_($this->data[0]->__ss_pad1);
            case "__ss_align": return $this->data[0]->__ss_align;
            case "__ss_pad2": return new string_($this->data[0]->__ss_pad2);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_len":
                $this->data[0]->ss_len = $value;
                return;
            case "ss_family":
                $this->data[0]->ss_family = $value;
                return;
            case "__ss_pad1":
                (new string_($_ = &$this->data[0]->__ss_pad1))->set($value);
                return;
            case "__ss_align":
                $this->data[0]->__ss_align = $value;
                return;
            case "__ss_pad2":
                (new string_($_ = &$this->data[0]->__ss_pad2))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sockaddr_storage_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_storage*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_storage_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_storage_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_storage_ptr_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_storage_ptr { return new struct_sockaddr_storage_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_storage_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_storage_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_storage_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_storage_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_storage_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_storage**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_storage_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_storage_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_storage_ptr_ptr_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_storage_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_storage_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_storage_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_storage_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_storage_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_storage_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_storage***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_storage_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_storage_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_storage_ptr_ptr_ptr_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_storage_ptr_ptr_ptr { return new struct_sockaddr_storage_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_storage_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_storage_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_storage_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_storage_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_storage_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_storage****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $msg_name
 * @property int $msg_namelen
 * @property struct_iovec_ptr $msg_iov
 * @property int $msg_iovlen
 * @property void_ptr $msg_control
 * @property int $msg_controllen
 * @property int $msg_flags
 */
class struct_msghdr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_msghdr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_msghdr_ptr { return new struct_msghdr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "msg_name": return new void_ptr($this->data->msg_name);
            case "msg_namelen": return $this->data->msg_namelen;
            case "msg_iov": return new struct_iovec_ptr($this->data->msg_iov);
            case "msg_iovlen": return $this->data->msg_iovlen;
            case "msg_control": return new void_ptr($this->data->msg_control);
            case "msg_controllen": return $this->data->msg_controllen;
            case "msg_flags": return $this->data->msg_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "msg_name":
                (new void_ptr($_ = &$this->data->msg_name))->set($value);
                return;
            case "msg_namelen":
                $this->data->msg_namelen = $value;
                return;
            case "msg_iov":
                (new struct_iovec_ptr($_ = &$this->data->msg_iov))->set($value);
                return;
            case "msg_iovlen":
                $this->data->msg_iovlen = $value;
                return;
            case "msg_control":
                (new void_ptr($_ = &$this->data->msg_control))->set($value);
                return;
            case "msg_controllen":
                $this->data->msg_controllen = $value;
                return;
            case "msg_flags":
                $this->data->msg_flags = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_msghdr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct msghdr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $msg_name
 * @property int $msg_namelen
 * @property struct_iovec_ptr $msg_iov
 * @property int $msg_iovlen
 * @property void_ptr $msg_control
 * @property int $msg_controllen
 * @property int $msg_flags
 */
class struct_msghdr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_msghdr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_msghdr_ptr_ptr { return new struct_msghdr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_msghdr { return new struct_msghdr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_msghdr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_msghdr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_msghdr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "msg_name": return new void_ptr($this->data[0]->msg_name);
            case "msg_namelen": return $this->data[0]->msg_namelen;
            case "msg_iov": return new struct_iovec_ptr($this->data[0]->msg_iov);
            case "msg_iovlen": return $this->data[0]->msg_iovlen;
            case "msg_control": return new void_ptr($this->data[0]->msg_control);
            case "msg_controllen": return $this->data[0]->msg_controllen;
            case "msg_flags": return $this->data[0]->msg_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "msg_name":
                (new void_ptr($_ = &$this->data[0]->msg_name))->set($value);
                return;
            case "msg_namelen":
                $this->data[0]->msg_namelen = $value;
                return;
            case "msg_iov":
                (new struct_iovec_ptr($_ = &$this->data[0]->msg_iov))->set($value);
                return;
            case "msg_iovlen":
                $this->data[0]->msg_iovlen = $value;
                return;
            case "msg_control":
                (new void_ptr($_ = &$this->data[0]->msg_control))->set($value);
                return;
            case "msg_controllen":
                $this->data[0]->msg_controllen = $value;
                return;
            case "msg_flags":
                $this->data[0]->msg_flags = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_msghdr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct msghdr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_msghdr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_msghdr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_msghdr_ptr_ptr_ptr { return new struct_msghdr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_msghdr_ptr { return new struct_msghdr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_msghdr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_msghdr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_msghdr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_msghdr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_msghdr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct msghdr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_msghdr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_msghdr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_msghdr_ptr_ptr_ptr_ptr { return new struct_msghdr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_msghdr_ptr_ptr { return new struct_msghdr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_msghdr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_msghdr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_msghdr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_msghdr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_msghdr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct msghdr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_msghdr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_msghdr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_msghdr_ptr_ptr_ptr_ptr_ptr { return new struct_msghdr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_msghdr_ptr_ptr_ptr { return new struct_msghdr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_msghdr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_msghdr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_msghdr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_msghdr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_msghdr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct msghdr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $cmsg_len
 * @property int $cmsg_level
 * @property int $cmsg_type
 */
class struct_cmsghdr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsghdr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsghdr_ptr { return new struct_cmsghdr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "cmsg_len": return $this->data->cmsg_len;
            case "cmsg_level": return $this->data->cmsg_level;
            case "cmsg_type": return $this->data->cmsg_type;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "cmsg_len":
                $this->data->cmsg_len = $value;
                return;
            case "cmsg_level":
                $this->data->cmsg_level = $value;
                return;
            case "cmsg_type":
                $this->data->cmsg_type = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_cmsghdr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsghdr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $cmsg_len
 * @property int $cmsg_level
 * @property int $cmsg_type
 */
class struct_cmsghdr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsghdr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsghdr_ptr_ptr { return new struct_cmsghdr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsghdr { return new struct_cmsghdr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsghdr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsghdr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsghdr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "cmsg_len": return $this->data[0]->cmsg_len;
            case "cmsg_level": return $this->data[0]->cmsg_level;
            case "cmsg_type": return $this->data[0]->cmsg_type;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "cmsg_len":
                $this->data[0]->cmsg_len = $value;
                return;
            case "cmsg_level":
                $this->data[0]->cmsg_level = $value;
                return;
            case "cmsg_type":
                $this->data[0]->cmsg_type = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_cmsghdr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsghdr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsghdr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsghdr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsghdr_ptr_ptr_ptr { return new struct_cmsghdr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsghdr_ptr { return new struct_cmsghdr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsghdr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsghdr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsghdr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsghdr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsghdr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsghdr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsghdr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsghdr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsghdr_ptr_ptr_ptr_ptr { return new struct_cmsghdr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsghdr_ptr_ptr { return new struct_cmsghdr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsghdr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsghdr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsghdr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsghdr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsghdr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsghdr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsghdr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsghdr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsghdr_ptr_ptr_ptr_ptr_ptr { return new struct_cmsghdr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsghdr_ptr_ptr_ptr { return new struct_cmsghdr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsghdr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsghdr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsghdr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsghdr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsghdr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsghdr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $cmcred_pid
 * @property int $cmcred_uid
 * @property int $cmcred_euid
 * @property int $cmcred_gid
 * @property int $cmcred_ngroups
 * @property unsigned_int_ptr $cmcred_groups
 */
class struct_cmsgcred implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsgcred $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsgcred_ptr { return new struct_cmsgcred_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "cmcred_pid": return $this->data->cmcred_pid;
            case "cmcred_uid": return $this->data->cmcred_uid;
            case "cmcred_euid": return $this->data->cmcred_euid;
            case "cmcred_gid": return $this->data->cmcred_gid;
            case "cmcred_ngroups": return $this->data->cmcred_ngroups;
            case "cmcred_groups": return new unsigned_int_ptr($this->data->cmcred_groups);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "cmcred_pid":
                $this->data->cmcred_pid = $value;
                return;
            case "cmcred_uid":
                $this->data->cmcred_uid = $value;
                return;
            case "cmcred_euid":
                $this->data->cmcred_euid = $value;
                return;
            case "cmcred_gid":
                $this->data->cmcred_gid = $value;
                return;
            case "cmcred_ngroups":
                $this->data->cmcred_ngroups = $value;
                return;
            case "cmcred_groups":
                (new unsigned_int_ptr($_ = &$this->data->cmcred_groups))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_cmsgcred $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsgcred'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $cmcred_pid
 * @property int $cmcred_uid
 * @property int $cmcred_euid
 * @property int $cmcred_gid
 * @property int $cmcred_ngroups
 * @property unsigned_int_ptr $cmcred_groups
 */
class struct_cmsgcred_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsgcred_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsgcred_ptr_ptr { return new struct_cmsgcred_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsgcred { return new struct_cmsgcred($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsgcred { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsgcred[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsgcred($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "cmcred_pid": return $this->data[0]->cmcred_pid;
            case "cmcred_uid": return $this->data[0]->cmcred_uid;
            case "cmcred_euid": return $this->data[0]->cmcred_euid;
            case "cmcred_gid": return $this->data[0]->cmcred_gid;
            case "cmcred_ngroups": return $this->data[0]->cmcred_ngroups;
            case "cmcred_groups": return new unsigned_int_ptr($this->data[0]->cmcred_groups);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "cmcred_pid":
                $this->data[0]->cmcred_pid = $value;
                return;
            case "cmcred_uid":
                $this->data[0]->cmcred_uid = $value;
                return;
            case "cmcred_euid":
                $this->data[0]->cmcred_euid = $value;
                return;
            case "cmcred_gid":
                $this->data[0]->cmcred_gid = $value;
                return;
            case "cmcred_ngroups":
                $this->data[0]->cmcred_ngroups = $value;
                return;
            case "cmcred_groups":
                (new unsigned_int_ptr($_ = &$this->data[0]->cmcred_groups))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_cmsgcred_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsgcred*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsgcred_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsgcred_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsgcred_ptr_ptr_ptr { return new struct_cmsgcred_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsgcred_ptr { return new struct_cmsgcred_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsgcred_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsgcred_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsgcred_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsgcred_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsgcred_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsgcred**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsgcred_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsgcred_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsgcred_ptr_ptr_ptr_ptr { return new struct_cmsgcred_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsgcred_ptr_ptr { return new struct_cmsgcred_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsgcred_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsgcred_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsgcred_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsgcred_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsgcred_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsgcred***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_cmsgcred_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_cmsgcred_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_cmsgcred_ptr_ptr_ptr_ptr_ptr { return new struct_cmsgcred_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_cmsgcred_ptr_ptr_ptr { return new struct_cmsgcred_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_cmsgcred_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_cmsgcred_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_cmsgcred_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_cmsgcred_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_cmsgcred_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct cmsgcred****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_iovec_ptr $headers
 * @property int $hdr_cnt
 * @property struct_iovec_ptr $trailers
 * @property int $trl_cnt
 */
class struct_sf_hdtr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sf_hdtr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sf_hdtr_ptr { return new struct_sf_hdtr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "headers": return new struct_iovec_ptr($this->data->headers);
            case "hdr_cnt": return $this->data->hdr_cnt;
            case "trailers": return new struct_iovec_ptr($this->data->trailers);
            case "trl_cnt": return $this->data->trl_cnt;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "headers":
                (new struct_iovec_ptr($_ = &$this->data->headers))->set($value);
                return;
            case "hdr_cnt":
                $this->data->hdr_cnt = $value;
                return;
            case "trailers":
                (new struct_iovec_ptr($_ = &$this->data->trailers))->set($value);
                return;
            case "trl_cnt":
                $this->data->trl_cnt = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sf_hdtr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sf_hdtr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_iovec_ptr $headers
 * @property int $hdr_cnt
 * @property struct_iovec_ptr $trailers
 * @property int $trl_cnt
 */
class struct_sf_hdtr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sf_hdtr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sf_hdtr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sf_hdtr { return new struct_sf_hdtr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sf_hdtr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sf_hdtr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sf_hdtr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "headers": return new struct_iovec_ptr($this->data[0]->headers);
            case "hdr_cnt": return $this->data[0]->hdr_cnt;
            case "trailers": return new struct_iovec_ptr($this->data[0]->trailers);
            case "trl_cnt": return $this->data[0]->trl_cnt;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "headers":
                (new struct_iovec_ptr($_ = &$this->data[0]->headers))->set($value);
                return;
            case "hdr_cnt":
                $this->data[0]->hdr_cnt = $value;
                return;
            case "trailers":
                (new struct_iovec_ptr($_ = &$this->data[0]->trailers))->set($value);
                return;
            case "trl_cnt":
                $this->data[0]->trl_cnt = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sf_hdtr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sf_hdtr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sf_hdtr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sf_hdtr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sf_hdtr_ptr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sf_hdtr_ptr { return new struct_sf_hdtr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sf_hdtr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sf_hdtr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sf_hdtr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sf_hdtr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sf_hdtr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sf_hdtr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sf_hdtr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sf_hdtr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sf_hdtr_ptr_ptr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sf_hdtr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sf_hdtr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sf_hdtr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sf_hdtr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sf_hdtr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sf_hdtr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sf_hdtr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sf_hdtr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sf_hdtr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sf_hdtr_ptr_ptr_ptr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sf_hdtr_ptr_ptr_ptr { return new struct_sf_hdtr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sf_hdtr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sf_hdtr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sf_hdtr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sf_hdtr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sf_hdtr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sf_hdtr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_nsec
 */
class struct_timespec implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timespec $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timespec_ptr { return new struct_timespec_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data->tv_sec;
            case "tv_nsec": return $this->data->tv_nsec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data->tv_sec = $value;
                return;
            case "tv_nsec":
                $this->data->tv_nsec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_timespec $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timespec'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_nsec
 */
class struct_timespec_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timespec_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timespec_ptr_ptr { return new struct_timespec_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timespec { return new struct_timespec($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timespec { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timespec[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timespec($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data[0]->tv_sec;
            case "tv_nsec": return $this->data[0]->tv_nsec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data[0]->tv_sec = $value;
                return;
            case "tv_nsec":
                $this->data[0]->tv_nsec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_timespec_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timespec*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timespec_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timespec_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timespec_ptr_ptr_ptr { return new struct_timespec_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timespec_ptr { return new struct_timespec_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timespec_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timespec_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timespec_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timespec_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timespec_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timespec**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timespec_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timespec_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timespec_ptr_ptr_ptr_ptr { return new struct_timespec_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timespec_ptr_ptr { return new struct_timespec_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timespec_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timespec_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timespec_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timespec_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timespec_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timespec***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timespec_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timespec_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timespec_ptr_ptr_ptr_ptr_ptr { return new struct_timespec_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timespec_ptr_ptr_ptr { return new struct_timespec_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timespec_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timespec_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timespec_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timespec_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timespec_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timespec****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr { return new struct_timeval_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data->tv_sec;
            case "tv_usec": return $this->data->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data->tv_sec = $value;
                return;
            case "tv_usec":
                $this->data->tv_usec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_timeval $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr { return new struct_timeval_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval { return new struct_timeval($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data[0]->tv_sec;
            case "tv_usec": return $this->data[0]->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data[0]->tv_sec = $value;
                return;
            case "tv_usec":
                $this->data[0]->tv_usec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_timeval_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval_ptr { return new struct_timeval_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval_ptr_ptr { return new struct_timeval_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval64 implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval64_ptr { return new struct_timeval64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data->tv_sec;
            case "tv_usec": return $this->data->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data->tv_sec = $value;
                return;
            case "tv_usec":
                $this->data->tv_usec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_timeval64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval64'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval64_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval64_ptr_ptr { return new struct_timeval64_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval64 { return new struct_timeval64($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data[0]->tv_sec;
            case "tv_usec": return $this->data[0]->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data[0]->tv_sec = $value;
                return;
            case "tv_usec":
                $this->data[0]->tv_usec = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_timeval64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval64*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval64_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval64_ptr_ptr_ptr { return new struct_timeval64_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval64_ptr { return new struct_timeval64_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval64**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval64_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval64_ptr_ptr_ptr_ptr { return new struct_timeval64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval64_ptr_ptr { return new struct_timeval64_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval64***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval64_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval64_ptr_ptr_ptr_ptr_ptr { return new struct_timeval64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timeval64_ptr_ptr_ptr { return new struct_timeval64_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timeval64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval64****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_timeval $it_interval
 * @property struct_timeval $it_value
 */
class struct_itimerval implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_itimerval $other): bool { return $this->data == $other->data; }
    public function addr(): struct_itimerval_ptr { return new struct_itimerval_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "it_interval": return new struct_timeval($this->data->it_interval);
            case "it_value": return new struct_timeval($this->data->it_value);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "it_interval":
                (new struct_timeval($_ = &$this->data->it_interval))->set($value);
                return;
            case "it_value":
                (new struct_timeval($_ = &$this->data->it_value))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_itimerval $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct itimerval'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_timeval $it_interval
 * @property struct_timeval $it_value
 */
class struct_itimerval_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_itimerval_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_itimerval_ptr_ptr { return new struct_itimerval_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_itimerval { return new struct_itimerval($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_itimerval { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_itimerval[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_itimerval($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "it_interval": return new struct_timeval($this->data[0]->it_interval);
            case "it_value": return new struct_timeval($this->data[0]->it_value);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "it_interval":
                (new struct_timeval($_ = &$this->data[0]->it_interval))->set($value);
                return;
            case "it_value":
                (new struct_timeval($_ = &$this->data[0]->it_value))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_itimerval_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct itimerval*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_itimerval_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_itimerval_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_itimerval_ptr_ptr_ptr { return new struct_itimerval_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_itimerval_ptr { return new struct_itimerval_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_itimerval_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_itimerval_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_itimerval_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_itimerval_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_itimerval_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct itimerval**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_itimerval_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_itimerval_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_itimerval_ptr_ptr_ptr_ptr { return new struct_itimerval_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_itimerval_ptr_ptr { return new struct_itimerval_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_itimerval_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_itimerval_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_itimerval_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_itimerval_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_itimerval_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct itimerval***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_itimerval_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_itimerval_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_itimerval_ptr_ptr_ptr_ptr_ptr { return new struct_itimerval_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_itimerval_ptr_ptr_ptr { return new struct_itimerval_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_itimerval_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_itimerval_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_itimerval_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_itimerval_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_itimerval_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct itimerval****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tz_minuteswest
 * @property int $tz_dsttime
 */
class struct_timezone implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timezone $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timezone_ptr { return new struct_timezone_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tz_minuteswest": return $this->data->tz_minuteswest;
            case "tz_dsttime": return $this->data->tz_dsttime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tz_minuteswest":
                $this->data->tz_minuteswest = $value;
                return;
            case "tz_dsttime":
                $this->data->tz_dsttime = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_timezone $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timezone'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tz_minuteswest
 * @property int $tz_dsttime
 */
class struct_timezone_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timezone_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timezone_ptr_ptr { return new struct_timezone_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timezone { return new struct_timezone($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timezone { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timezone[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timezone($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tz_minuteswest": return $this->data[0]->tz_minuteswest;
            case "tz_dsttime": return $this->data[0]->tz_dsttime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tz_minuteswest":
                $this->data[0]->tz_minuteswest = $value;
                return;
            case "tz_dsttime":
                $this->data[0]->tz_dsttime = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_timezone_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timezone*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timezone_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timezone_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timezone_ptr_ptr_ptr { return new struct_timezone_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timezone_ptr { return new struct_timezone_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timezone_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timezone_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timezone_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timezone_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timezone_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timezone**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timezone_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timezone_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timezone_ptr_ptr_ptr_ptr { return new struct_timezone_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timezone_ptr_ptr { return new struct_timezone_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timezone_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timezone_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timezone_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timezone_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timezone_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timezone***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timezone_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timezone_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timezone_ptr_ptr_ptr_ptr_ptr { return new struct_timezone_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_timezone_ptr_ptr_ptr { return new struct_timezone_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timezone_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_timezone_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timezone_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timezone_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timezone_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timezone****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $hz
 * @property int $tick
 * @property int $tickadj
 * @property int $stathz
 * @property int $profhz
 */
class struct_clockinfo implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_clockinfo $other): bool { return $this->data == $other->data; }
    public function addr(): struct_clockinfo_ptr { return new struct_clockinfo_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "hz": return $this->data->hz;
            case "tick": return $this->data->tick;
            case "tickadj": return $this->data->tickadj;
            case "stathz": return $this->data->stathz;
            case "profhz": return $this->data->profhz;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "hz":
                $this->data->hz = $value;
                return;
            case "tick":
                $this->data->tick = $value;
                return;
            case "tickadj":
                $this->data->tickadj = $value;
                return;
            case "stathz":
                $this->data->stathz = $value;
                return;
            case "profhz":
                $this->data->profhz = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_clockinfo $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct clockinfo'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $hz
 * @property int $tick
 * @property int $tickadj
 * @property int $stathz
 * @property int $profhz
 */
class struct_clockinfo_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_clockinfo_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_clockinfo_ptr_ptr { return new struct_clockinfo_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_clockinfo { return new struct_clockinfo($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_clockinfo { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_clockinfo[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_clockinfo($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "hz": return $this->data[0]->hz;
            case "tick": return $this->data[0]->tick;
            case "tickadj": return $this->data[0]->tickadj;
            case "stathz": return $this->data[0]->stathz;
            case "profhz": return $this->data[0]->profhz;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "hz":
                $this->data[0]->hz = $value;
                return;
            case "tick":
                $this->data[0]->tick = $value;
                return;
            case "tickadj":
                $this->data[0]->tickadj = $value;
                return;
            case "stathz":
                $this->data[0]->stathz = $value;
                return;
            case "profhz":
                $this->data[0]->profhz = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_clockinfo_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct clockinfo*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_clockinfo_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_clockinfo_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_clockinfo_ptr_ptr_ptr { return new struct_clockinfo_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_clockinfo_ptr { return new struct_clockinfo_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_clockinfo_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_clockinfo_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_clockinfo_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_clockinfo_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_clockinfo_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct clockinfo**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_clockinfo_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_clockinfo_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_clockinfo_ptr_ptr_ptr_ptr { return new struct_clockinfo_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_clockinfo_ptr_ptr { return new struct_clockinfo_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_clockinfo_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_clockinfo_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_clockinfo_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_clockinfo_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_clockinfo_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct clockinfo***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_clockinfo_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_clockinfo_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_clockinfo_ptr_ptr_ptr_ptr_ptr { return new struct_clockinfo_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_clockinfo_ptr_ptr_ptr { return new struct_clockinfo_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_clockinfo_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_clockinfo_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_clockinfo_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_clockinfo_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_clockinfo_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct clockinfo****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tm_sec
 * @property int $tm_min
 * @property int $tm_hour
 * @property int $tm_mday
 * @property int $tm_mon
 * @property int $tm_year
 * @property int $tm_wday
 * @property int $tm_yday
 * @property int $tm_isdst
 * @property int $tm_gmtoff
 * @property string_ $tm_zone
 */
class struct_tm implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_tm $other): bool { return $this->data == $other->data; }
    public function addr(): struct_tm_ptr { return new struct_tm_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tm_sec": return $this->data->tm_sec;
            case "tm_min": return $this->data->tm_min;
            case "tm_hour": return $this->data->tm_hour;
            case "tm_mday": return $this->data->tm_mday;
            case "tm_mon": return $this->data->tm_mon;
            case "tm_year": return $this->data->tm_year;
            case "tm_wday": return $this->data->tm_wday;
            case "tm_yday": return $this->data->tm_yday;
            case "tm_isdst": return $this->data->tm_isdst;
            case "tm_gmtoff": return $this->data->tm_gmtoff;
            case "tm_zone": return new string_($this->data->tm_zone);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tm_sec":
                $this->data->tm_sec = $value;
                return;
            case "tm_min":
                $this->data->tm_min = $value;
                return;
            case "tm_hour":
                $this->data->tm_hour = $value;
                return;
            case "tm_mday":
                $this->data->tm_mday = $value;
                return;
            case "tm_mon":
                $this->data->tm_mon = $value;
                return;
            case "tm_year":
                $this->data->tm_year = $value;
                return;
            case "tm_wday":
                $this->data->tm_wday = $value;
                return;
            case "tm_yday":
                $this->data->tm_yday = $value;
                return;
            case "tm_isdst":
                $this->data->tm_isdst = $value;
                return;
            case "tm_gmtoff":
                $this->data->tm_gmtoff = $value;
                return;
            case "tm_zone":
                (new string_($_ = &$this->data->tm_zone))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_tm $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct tm'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tm_sec
 * @property int $tm_min
 * @property int $tm_hour
 * @property int $tm_mday
 * @property int $tm_mon
 * @property int $tm_year
 * @property int $tm_wday
 * @property int $tm_yday
 * @property int $tm_isdst
 * @property int $tm_gmtoff
 * @property string_ $tm_zone
 */
class struct_tm_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_tm_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_tm_ptr_ptr { return new struct_tm_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_tm { return new struct_tm($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_tm { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_tm[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_tm($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tm_sec": return $this->data[0]->tm_sec;
            case "tm_min": return $this->data[0]->tm_min;
            case "tm_hour": return $this->data[0]->tm_hour;
            case "tm_mday": return $this->data[0]->tm_mday;
            case "tm_mon": return $this->data[0]->tm_mon;
            case "tm_year": return $this->data[0]->tm_year;
            case "tm_wday": return $this->data[0]->tm_wday;
            case "tm_yday": return $this->data[0]->tm_yday;
            case "tm_isdst": return $this->data[0]->tm_isdst;
            case "tm_gmtoff": return $this->data[0]->tm_gmtoff;
            case "tm_zone": return new string_($this->data[0]->tm_zone);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tm_sec":
                $this->data[0]->tm_sec = $value;
                return;
            case "tm_min":
                $this->data[0]->tm_min = $value;
                return;
            case "tm_hour":
                $this->data[0]->tm_hour = $value;
                return;
            case "tm_mday":
                $this->data[0]->tm_mday = $value;
                return;
            case "tm_mon":
                $this->data[0]->tm_mon = $value;
                return;
            case "tm_year":
                $this->data[0]->tm_year = $value;
                return;
            case "tm_wday":
                $this->data[0]->tm_wday = $value;
                return;
            case "tm_yday":
                $this->data[0]->tm_yday = $value;
                return;
            case "tm_isdst":
                $this->data[0]->tm_isdst = $value;
                return;
            case "tm_gmtoff":
                $this->data[0]->tm_gmtoff = $value;
                return;
            case "tm_zone":
                (new string_($_ = &$this->data[0]->tm_zone))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_tm_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct tm*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_tm_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_tm_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_tm_ptr_ptr_ptr { return new struct_tm_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_tm_ptr { return new struct_tm_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_tm_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_tm_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_tm_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_tm_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_tm_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct tm**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_tm_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_tm_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_tm_ptr_ptr_ptr_ptr { return new struct_tm_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_tm_ptr_ptr { return new struct_tm_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_tm_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_tm_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_tm_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_tm_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_tm_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct tm***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_tm_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_tm_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_tm_ptr_ptr_ptr_ptr_ptr { return new struct_tm_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_tm_ptr_ptr_ptr { return new struct_tm_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_tm_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_tm_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_tm_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_tm_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_tm_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct tm****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_config implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_config $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_config_ptr { return new struct_quiche_config_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_config $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_config'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_config_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_config_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_config_ptr_ptr { return new struct_quiche_config_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_config { return new struct_quiche_config($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_config { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_config[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_config($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_config_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_config*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_config_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_config_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_config_ptr_ptr_ptr { return new struct_quiche_config_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_config_ptr { return new struct_quiche_config_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_config_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_config_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_config_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_config_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_config_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_config**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_config_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_config_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_config_ptr_ptr_ptr_ptr { return new struct_quiche_config_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_config_ptr_ptr { return new struct_quiche_config_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_config_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_config_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_config_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_config_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_config_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_config***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_config_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_config_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_config_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_config_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_config_ptr_ptr_ptr { return new struct_quiche_config_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_config_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_config_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_config_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_config_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_config_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_config****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_conn implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_conn $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_conn_ptr { return new struct_quiche_conn_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_conn $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_conn'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_conn_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_conn_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_conn_ptr_ptr { return new struct_quiche_conn_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_conn { return new struct_quiche_conn($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_conn { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_conn[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_conn($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_conn_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_conn*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_conn_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_conn_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_conn_ptr_ptr_ptr { return new struct_quiche_conn_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_conn_ptr { return new struct_quiche_conn_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_conn_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_conn_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_conn_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_conn_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_conn_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_conn**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_conn_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_conn_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_conn_ptr_ptr_ptr_ptr { return new struct_quiche_conn_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_conn_ptr_ptr { return new struct_quiche_conn_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_conn_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_conn_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_conn_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_conn_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_conn_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_conn***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_conn_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_conn_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_conn_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_conn_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_conn_ptr_ptr_ptr { return new struct_quiche_conn_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_conn_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_conn_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_conn_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_conn_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_conn_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_conn****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_ptr $from
 * @property int $from_len
 * @property struct_sockaddr_ptr $to
 * @property int $to_len
 */
class quiche_recv_info implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_recv_info $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_recv_info_ptr { return new quiche_recv_info_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "from": return new struct_sockaddr_ptr($this->data->from);
            case "from_len": return $this->data->from_len;
            case "to": return new struct_sockaddr_ptr($this->data->to);
            case "to_len": return $this->data->to_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "from":
                (new struct_sockaddr_ptr($_ = &$this->data->from))->set($value);
                return;
            case "from_len":
                $this->data->from_len = $value;
                return;
            case "to":
                (new struct_sockaddr_ptr($_ = &$this->data->to))->set($value);
                return;
            case "to_len":
                $this->data->to_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_recv_info $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_recv_info'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_ptr $from
 * @property int $from_len
 * @property struct_sockaddr_ptr $to
 * @property int $to_len
 */
class quiche_recv_info_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_recv_info_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_recv_info_ptr_ptr { return new quiche_recv_info_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_recv_info { return new quiche_recv_info($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_recv_info { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_recv_info[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_recv_info($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "from": return new struct_sockaddr_ptr($this->data[0]->from);
            case "from_len": return $this->data[0]->from_len;
            case "to": return new struct_sockaddr_ptr($this->data[0]->to);
            case "to_len": return $this->data[0]->to_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "from":
                (new struct_sockaddr_ptr($_ = &$this->data[0]->from))->set($value);
                return;
            case "from_len":
                $this->data[0]->from_len = $value;
                return;
            case "to":
                (new struct_sockaddr_ptr($_ = &$this->data[0]->to))->set($value);
                return;
            case "to_len":
                $this->data[0]->to_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_recv_info_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_recv_info*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_recv_info_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_recv_info_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_recv_info_ptr_ptr_ptr { return new quiche_recv_info_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_recv_info_ptr { return new quiche_recv_info_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_recv_info_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_recv_info_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_recv_info_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_recv_info_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_recv_info_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_recv_info**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_recv_info_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_recv_info_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_recv_info_ptr_ptr_ptr_ptr { return new quiche_recv_info_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_recv_info_ptr_ptr { return new quiche_recv_info_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_recv_info_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_recv_info_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_recv_info_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_recv_info_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_recv_info_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_recv_info***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_recv_info_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_recv_info_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_recv_info_ptr_ptr_ptr_ptr_ptr { return new quiche_recv_info_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_recv_info_ptr_ptr_ptr { return new quiche_recv_info_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_recv_info_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_recv_info_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_recv_info_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_recv_info_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_recv_info_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_recv_info****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_storage $from
 * @property int $from_len
 * @property struct_sockaddr_storage $to
 * @property int $to_len
 * @property struct_timespec $at
 */
class quiche_send_info implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_send_info $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_send_info_ptr { return new quiche_send_info_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "from": return new struct_sockaddr_storage($this->data->from);
            case "from_len": return $this->data->from_len;
            case "to": return new struct_sockaddr_storage($this->data->to);
            case "to_len": return $this->data->to_len;
            case "at": return new struct_timespec($this->data->at);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "from":
                (new struct_sockaddr_storage($_ = &$this->data->from))->set($value);
                return;
            case "from_len":
                $this->data->from_len = $value;
                return;
            case "to":
                (new struct_sockaddr_storage($_ = &$this->data->to))->set($value);
                return;
            case "to_len":
                $this->data->to_len = $value;
                return;
            case "at":
                (new struct_timespec($_ = &$this->data->at))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_send_info $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_send_info'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_storage $from
 * @property int $from_len
 * @property struct_sockaddr_storage $to
 * @property int $to_len
 * @property struct_timespec $at
 */
class quiche_send_info_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_send_info_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_send_info_ptr_ptr { return new quiche_send_info_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_send_info { return new quiche_send_info($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_send_info { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_send_info[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_send_info($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "from": return new struct_sockaddr_storage($this->data[0]->from);
            case "from_len": return $this->data[0]->from_len;
            case "to": return new struct_sockaddr_storage($this->data[0]->to);
            case "to_len": return $this->data[0]->to_len;
            case "at": return new struct_timespec($this->data[0]->at);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "from":
                (new struct_sockaddr_storage($_ = &$this->data[0]->from))->set($value);
                return;
            case "from_len":
                $this->data[0]->from_len = $value;
                return;
            case "to":
                (new struct_sockaddr_storage($_ = &$this->data[0]->to))->set($value);
                return;
            case "to_len":
                $this->data[0]->to_len = $value;
                return;
            case "at":
                (new struct_timespec($_ = &$this->data[0]->at))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_send_info_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_send_info*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_send_info_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_send_info_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_send_info_ptr_ptr_ptr { return new quiche_send_info_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_send_info_ptr { return new quiche_send_info_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_send_info_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_send_info_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_send_info_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_send_info_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_send_info_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_send_info**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_send_info_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_send_info_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_send_info_ptr_ptr_ptr_ptr { return new quiche_send_info_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_send_info_ptr_ptr { return new quiche_send_info_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_send_info_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_send_info_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_send_info_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_send_info_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_send_info_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_send_info***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_send_info_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_send_info_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_send_info_ptr_ptr_ptr_ptr_ptr { return new quiche_send_info_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_send_info_ptr_ptr_ptr { return new quiche_send_info_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_send_info_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_send_info_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_send_info_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_send_info_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_send_info_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_send_info****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_stream_iter implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_stream_iter $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_stream_iter_ptr { return new struct_quiche_stream_iter_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_stream_iter $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_stream_iter'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_stream_iter_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_stream_iter_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_stream_iter_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_stream_iter { return new struct_quiche_stream_iter($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_stream_iter { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_stream_iter[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_stream_iter($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_stream_iter_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_stream_iter*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_stream_iter_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_stream_iter_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_stream_iter_ptr_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_stream_iter_ptr { return new struct_quiche_stream_iter_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_stream_iter_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_stream_iter_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_stream_iter_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_stream_iter_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_stream_iter_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_stream_iter**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_stream_iter_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_stream_iter_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_stream_iter_ptr_ptr_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_stream_iter_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_stream_iter_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_stream_iter_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_stream_iter_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_stream_iter_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_stream_iter_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_stream_iter***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_stream_iter_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_stream_iter_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_stream_iter_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_stream_iter_ptr_ptr_ptr { return new struct_quiche_stream_iter_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_stream_iter_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_stream_iter_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_stream_iter_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_stream_iter_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_stream_iter_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_stream_iter****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_connection_id_iter implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_connection_id_iter $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_connection_id_iter_ptr { return new struct_quiche_connection_id_iter_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_connection_id_iter $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_connection_id_iter'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_connection_id_iter_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_connection_id_iter_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_connection_id_iter_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_connection_id_iter { return new struct_quiche_connection_id_iter($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_connection_id_iter { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_connection_id_iter[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_connection_id_iter($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_connection_id_iter_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_connection_id_iter*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_connection_id_iter_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_connection_id_iter_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_connection_id_iter_ptr_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_connection_id_iter_ptr { return new struct_quiche_connection_id_iter_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_connection_id_iter_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_connection_id_iter_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_connection_id_iter_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_connection_id_iter_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_connection_id_iter_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_connection_id_iter**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_connection_id_iter_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_connection_id_iter_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_connection_id_iter_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_connection_id_iter_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_connection_id_iter_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_connection_id_iter_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_connection_id_iter_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_connection_id_iter_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_connection_id_iter***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_connection_id_iter_ptr_ptr_ptr { return new struct_quiche_connection_id_iter_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_connection_id_iter_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_connection_id_iter_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_connection_id_iter_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_connection_id_iter_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_connection_id_iter****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $recv
 * @property int $sent
 * @property int $lost
 * @property int $retrans
 * @property int $sent_bytes
 * @property int $recv_bytes
 * @property int $lost_bytes
 * @property int $stream_retrans_bytes
 * @property int $paths_count
 * @property int $reset_stream_count_local
 * @property int $stopped_stream_count_local
 * @property int $reset_stream_count_remote
 * @property int $stopped_stream_count_remote
 */
class quiche_stats implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_stats $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_stats_ptr { return new quiche_stats_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "recv": return $this->data->recv;
            case "sent": return $this->data->sent;
            case "lost": return $this->data->lost;
            case "retrans": return $this->data->retrans;
            case "sent_bytes": return $this->data->sent_bytes;
            case "recv_bytes": return $this->data->recv_bytes;
            case "lost_bytes": return $this->data->lost_bytes;
            case "stream_retrans_bytes": return $this->data->stream_retrans_bytes;
            case "paths_count": return $this->data->paths_count;
            case "reset_stream_count_local": return $this->data->reset_stream_count_local;
            case "stopped_stream_count_local": return $this->data->stopped_stream_count_local;
            case "reset_stream_count_remote": return $this->data->reset_stream_count_remote;
            case "stopped_stream_count_remote": return $this->data->stopped_stream_count_remote;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "recv":
                $this->data->recv = $value;
                return;
            case "sent":
                $this->data->sent = $value;
                return;
            case "lost":
                $this->data->lost = $value;
                return;
            case "retrans":
                $this->data->retrans = $value;
                return;
            case "sent_bytes":
                $this->data->sent_bytes = $value;
                return;
            case "recv_bytes":
                $this->data->recv_bytes = $value;
                return;
            case "lost_bytes":
                $this->data->lost_bytes = $value;
                return;
            case "stream_retrans_bytes":
                $this->data->stream_retrans_bytes = $value;
                return;
            case "paths_count":
                $this->data->paths_count = $value;
                return;
            case "reset_stream_count_local":
                $this->data->reset_stream_count_local = $value;
                return;
            case "stopped_stream_count_local":
                $this->data->stopped_stream_count_local = $value;
                return;
            case "reset_stream_count_remote":
                $this->data->reset_stream_count_remote = $value;
                return;
            case "stopped_stream_count_remote":
                $this->data->stopped_stream_count_remote = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_stats $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_stats'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $recv
 * @property int $sent
 * @property int $lost
 * @property int $retrans
 * @property int $sent_bytes
 * @property int $recv_bytes
 * @property int $lost_bytes
 * @property int $stream_retrans_bytes
 * @property int $paths_count
 * @property int $reset_stream_count_local
 * @property int $stopped_stream_count_local
 * @property int $reset_stream_count_remote
 * @property int $stopped_stream_count_remote
 */
class quiche_stats_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_stats_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_stats_ptr_ptr { return new quiche_stats_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_stats { return new quiche_stats($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_stats { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_stats[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_stats($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "recv": return $this->data[0]->recv;
            case "sent": return $this->data[0]->sent;
            case "lost": return $this->data[0]->lost;
            case "retrans": return $this->data[0]->retrans;
            case "sent_bytes": return $this->data[0]->sent_bytes;
            case "recv_bytes": return $this->data[0]->recv_bytes;
            case "lost_bytes": return $this->data[0]->lost_bytes;
            case "stream_retrans_bytes": return $this->data[0]->stream_retrans_bytes;
            case "paths_count": return $this->data[0]->paths_count;
            case "reset_stream_count_local": return $this->data[0]->reset_stream_count_local;
            case "stopped_stream_count_local": return $this->data[0]->stopped_stream_count_local;
            case "reset_stream_count_remote": return $this->data[0]->reset_stream_count_remote;
            case "stopped_stream_count_remote": return $this->data[0]->stopped_stream_count_remote;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "recv":
                $this->data[0]->recv = $value;
                return;
            case "sent":
                $this->data[0]->sent = $value;
                return;
            case "lost":
                $this->data[0]->lost = $value;
                return;
            case "retrans":
                $this->data[0]->retrans = $value;
                return;
            case "sent_bytes":
                $this->data[0]->sent_bytes = $value;
                return;
            case "recv_bytes":
                $this->data[0]->recv_bytes = $value;
                return;
            case "lost_bytes":
                $this->data[0]->lost_bytes = $value;
                return;
            case "stream_retrans_bytes":
                $this->data[0]->stream_retrans_bytes = $value;
                return;
            case "paths_count":
                $this->data[0]->paths_count = $value;
                return;
            case "reset_stream_count_local":
                $this->data[0]->reset_stream_count_local = $value;
                return;
            case "stopped_stream_count_local":
                $this->data[0]->stopped_stream_count_local = $value;
                return;
            case "reset_stream_count_remote":
                $this->data[0]->reset_stream_count_remote = $value;
                return;
            case "stopped_stream_count_remote":
                $this->data[0]->stopped_stream_count_remote = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_stats_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_stats*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_stats_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_stats_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_stats_ptr_ptr_ptr { return new quiche_stats_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_stats_ptr { return new quiche_stats_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_stats_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_stats_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_stats_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_stats_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_stats_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_stats**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_stats_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_stats_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_stats_ptr_ptr_ptr_ptr { return new quiche_stats_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_stats_ptr_ptr { return new quiche_stats_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_stats_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_stats_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_stats_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_stats_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_stats_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_stats***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_stats_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_stats_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_stats_ptr_ptr_ptr_ptr_ptr { return new quiche_stats_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_stats_ptr_ptr_ptr { return new quiche_stats_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_stats_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_stats_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_stats_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_stats_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_stats_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_stats****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $peer_max_idle_timeout
 * @property int $peer_max_udp_payload_size
 * @property int $peer_initial_max_data
 * @property int $peer_initial_max_stream_data_bidi_local
 * @property int $peer_initial_max_stream_data_bidi_remote
 * @property int $peer_initial_max_stream_data_uni
 * @property int $peer_initial_max_streams_bidi
 * @property int $peer_initial_max_streams_uni
 * @property int $peer_ack_delay_exponent
 * @property int $peer_max_ack_delay
 * @property int $peer_disable_active_migration
 * @property int $peer_active_conn_id_limit
 * @property int $peer_max_datagram_frame_size
 */
class quiche_transport_params implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_transport_params $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_transport_params_ptr { return new quiche_transport_params_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "peer_max_idle_timeout": return $this->data->peer_max_idle_timeout;
            case "peer_max_udp_payload_size": return $this->data->peer_max_udp_payload_size;
            case "peer_initial_max_data": return $this->data->peer_initial_max_data;
            case "peer_initial_max_stream_data_bidi_local": return $this->data->peer_initial_max_stream_data_bidi_local;
            case "peer_initial_max_stream_data_bidi_remote": return $this->data->peer_initial_max_stream_data_bidi_remote;
            case "peer_initial_max_stream_data_uni": return $this->data->peer_initial_max_stream_data_uni;
            case "peer_initial_max_streams_bidi": return $this->data->peer_initial_max_streams_bidi;
            case "peer_initial_max_streams_uni": return $this->data->peer_initial_max_streams_uni;
            case "peer_ack_delay_exponent": return $this->data->peer_ack_delay_exponent;
            case "peer_max_ack_delay": return $this->data->peer_max_ack_delay;
            case "peer_disable_active_migration": return $this->data->peer_disable_active_migration;
            case "peer_active_conn_id_limit": return $this->data->peer_active_conn_id_limit;
            case "peer_max_datagram_frame_size": return $this->data->peer_max_datagram_frame_size;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "peer_max_idle_timeout":
                $this->data->peer_max_idle_timeout = $value;
                return;
            case "peer_max_udp_payload_size":
                $this->data->peer_max_udp_payload_size = $value;
                return;
            case "peer_initial_max_data":
                $this->data->peer_initial_max_data = $value;
                return;
            case "peer_initial_max_stream_data_bidi_local":
                $this->data->peer_initial_max_stream_data_bidi_local = $value;
                return;
            case "peer_initial_max_stream_data_bidi_remote":
                $this->data->peer_initial_max_stream_data_bidi_remote = $value;
                return;
            case "peer_initial_max_stream_data_uni":
                $this->data->peer_initial_max_stream_data_uni = $value;
                return;
            case "peer_initial_max_streams_bidi":
                $this->data->peer_initial_max_streams_bidi = $value;
                return;
            case "peer_initial_max_streams_uni":
                $this->data->peer_initial_max_streams_uni = $value;
                return;
            case "peer_ack_delay_exponent":
                $this->data->peer_ack_delay_exponent = $value;
                return;
            case "peer_max_ack_delay":
                $this->data->peer_max_ack_delay = $value;
                return;
            case "peer_disable_active_migration":
                $this->data->peer_disable_active_migration = $value;
                return;
            case "peer_active_conn_id_limit":
                $this->data->peer_active_conn_id_limit = $value;
                return;
            case "peer_max_datagram_frame_size":
                $this->data->peer_max_datagram_frame_size = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_transport_params $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_transport_params'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $peer_max_idle_timeout
 * @property int $peer_max_udp_payload_size
 * @property int $peer_initial_max_data
 * @property int $peer_initial_max_stream_data_bidi_local
 * @property int $peer_initial_max_stream_data_bidi_remote
 * @property int $peer_initial_max_stream_data_uni
 * @property int $peer_initial_max_streams_bidi
 * @property int $peer_initial_max_streams_uni
 * @property int $peer_ack_delay_exponent
 * @property int $peer_max_ack_delay
 * @property int $peer_disable_active_migration
 * @property int $peer_active_conn_id_limit
 * @property int $peer_max_datagram_frame_size
 */
class quiche_transport_params_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_transport_params_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_transport_params_ptr_ptr { return new quiche_transport_params_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_transport_params { return new quiche_transport_params($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_transport_params { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_transport_params[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_transport_params($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "peer_max_idle_timeout": return $this->data[0]->peer_max_idle_timeout;
            case "peer_max_udp_payload_size": return $this->data[0]->peer_max_udp_payload_size;
            case "peer_initial_max_data": return $this->data[0]->peer_initial_max_data;
            case "peer_initial_max_stream_data_bidi_local": return $this->data[0]->peer_initial_max_stream_data_bidi_local;
            case "peer_initial_max_stream_data_bidi_remote": return $this->data[0]->peer_initial_max_stream_data_bidi_remote;
            case "peer_initial_max_stream_data_uni": return $this->data[0]->peer_initial_max_stream_data_uni;
            case "peer_initial_max_streams_bidi": return $this->data[0]->peer_initial_max_streams_bidi;
            case "peer_initial_max_streams_uni": return $this->data[0]->peer_initial_max_streams_uni;
            case "peer_ack_delay_exponent": return $this->data[0]->peer_ack_delay_exponent;
            case "peer_max_ack_delay": return $this->data[0]->peer_max_ack_delay;
            case "peer_disable_active_migration": return $this->data[0]->peer_disable_active_migration;
            case "peer_active_conn_id_limit": return $this->data[0]->peer_active_conn_id_limit;
            case "peer_max_datagram_frame_size": return $this->data[0]->peer_max_datagram_frame_size;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "peer_max_idle_timeout":
                $this->data[0]->peer_max_idle_timeout = $value;
                return;
            case "peer_max_udp_payload_size":
                $this->data[0]->peer_max_udp_payload_size = $value;
                return;
            case "peer_initial_max_data":
                $this->data[0]->peer_initial_max_data = $value;
                return;
            case "peer_initial_max_stream_data_bidi_local":
                $this->data[0]->peer_initial_max_stream_data_bidi_local = $value;
                return;
            case "peer_initial_max_stream_data_bidi_remote":
                $this->data[0]->peer_initial_max_stream_data_bidi_remote = $value;
                return;
            case "peer_initial_max_stream_data_uni":
                $this->data[0]->peer_initial_max_stream_data_uni = $value;
                return;
            case "peer_initial_max_streams_bidi":
                $this->data[0]->peer_initial_max_streams_bidi = $value;
                return;
            case "peer_initial_max_streams_uni":
                $this->data[0]->peer_initial_max_streams_uni = $value;
                return;
            case "peer_ack_delay_exponent":
                $this->data[0]->peer_ack_delay_exponent = $value;
                return;
            case "peer_max_ack_delay":
                $this->data[0]->peer_max_ack_delay = $value;
                return;
            case "peer_disable_active_migration":
                $this->data[0]->peer_disable_active_migration = $value;
                return;
            case "peer_active_conn_id_limit":
                $this->data[0]->peer_active_conn_id_limit = $value;
                return;
            case "peer_max_datagram_frame_size":
                $this->data[0]->peer_max_datagram_frame_size = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_transport_params_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_transport_params*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_transport_params_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_transport_params_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_transport_params_ptr_ptr_ptr { return new quiche_transport_params_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_transport_params_ptr { return new quiche_transport_params_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_transport_params_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_transport_params_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_transport_params_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_transport_params_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_transport_params_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_transport_params**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_transport_params_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_transport_params_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_transport_params_ptr_ptr_ptr_ptr { return new quiche_transport_params_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_transport_params_ptr_ptr { return new quiche_transport_params_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_transport_params_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_transport_params_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_transport_params_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_transport_params_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_transport_params_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_transport_params***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_transport_params_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_transport_params_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_transport_params_ptr_ptr_ptr_ptr_ptr { return new quiche_transport_params_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_transport_params_ptr_ptr_ptr { return new quiche_transport_params_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_transport_params_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_transport_params_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_transport_params_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_transport_params_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_transport_params_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_transport_params****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_storage $local_addr
 * @property int $local_addr_len
 * @property struct_sockaddr_storage $peer_addr
 * @property int $peer_addr_len
 * @property int $validation_state
 * @property int $active
 * @property int $recv
 * @property int $sent
 * @property int $lost
 * @property int $retrans
 * @property int $rtt
 * @property int $cwnd
 * @property int $sent_bytes
 * @property int $recv_bytes
 * @property int $lost_bytes
 * @property int $stream_retrans_bytes
 * @property int $pmtu
 * @property int $delivery_rate
 */
class quiche_path_stats implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_path_stats $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_path_stats_ptr { return new quiche_path_stats_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "local_addr": return new struct_sockaddr_storage($this->data->local_addr);
            case "local_addr_len": return $this->data->local_addr_len;
            case "peer_addr": return new struct_sockaddr_storage($this->data->peer_addr);
            case "peer_addr_len": return $this->data->peer_addr_len;
            case "validation_state": return $this->data->validation_state;
            case "active": return $this->data->active;
            case "recv": return $this->data->recv;
            case "sent": return $this->data->sent;
            case "lost": return $this->data->lost;
            case "retrans": return $this->data->retrans;
            case "rtt": return $this->data->rtt;
            case "cwnd": return $this->data->cwnd;
            case "sent_bytes": return $this->data->sent_bytes;
            case "recv_bytes": return $this->data->recv_bytes;
            case "lost_bytes": return $this->data->lost_bytes;
            case "stream_retrans_bytes": return $this->data->stream_retrans_bytes;
            case "pmtu": return $this->data->pmtu;
            case "delivery_rate": return $this->data->delivery_rate;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "local_addr":
                (new struct_sockaddr_storage($_ = &$this->data->local_addr))->set($value);
                return;
            case "local_addr_len":
                $this->data->local_addr_len = $value;
                return;
            case "peer_addr":
                (new struct_sockaddr_storage($_ = &$this->data->peer_addr))->set($value);
                return;
            case "peer_addr_len":
                $this->data->peer_addr_len = $value;
                return;
            case "validation_state":
                $this->data->validation_state = $value;
                return;
            case "active":
                $this->data->active = $value;
                return;
            case "recv":
                $this->data->recv = $value;
                return;
            case "sent":
                $this->data->sent = $value;
                return;
            case "lost":
                $this->data->lost = $value;
                return;
            case "retrans":
                $this->data->retrans = $value;
                return;
            case "rtt":
                $this->data->rtt = $value;
                return;
            case "cwnd":
                $this->data->cwnd = $value;
                return;
            case "sent_bytes":
                $this->data->sent_bytes = $value;
                return;
            case "recv_bytes":
                $this->data->recv_bytes = $value;
                return;
            case "lost_bytes":
                $this->data->lost_bytes = $value;
                return;
            case "stream_retrans_bytes":
                $this->data->stream_retrans_bytes = $value;
                return;
            case "pmtu":
                $this->data->pmtu = $value;
                return;
            case "delivery_rate":
                $this->data->delivery_rate = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_path_stats $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_path_stats'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_storage $local_addr
 * @property int $local_addr_len
 * @property struct_sockaddr_storage $peer_addr
 * @property int $peer_addr_len
 * @property int $validation_state
 * @property int $active
 * @property int $recv
 * @property int $sent
 * @property int $lost
 * @property int $retrans
 * @property int $rtt
 * @property int $cwnd
 * @property int $sent_bytes
 * @property int $recv_bytes
 * @property int $lost_bytes
 * @property int $stream_retrans_bytes
 * @property int $pmtu
 * @property int $delivery_rate
 */
class quiche_path_stats_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_path_stats_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_path_stats_ptr_ptr { return new quiche_path_stats_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_path_stats { return new quiche_path_stats($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_path_stats { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_path_stats[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_path_stats($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "local_addr": return new struct_sockaddr_storage($this->data[0]->local_addr);
            case "local_addr_len": return $this->data[0]->local_addr_len;
            case "peer_addr": return new struct_sockaddr_storage($this->data[0]->peer_addr);
            case "peer_addr_len": return $this->data[0]->peer_addr_len;
            case "validation_state": return $this->data[0]->validation_state;
            case "active": return $this->data[0]->active;
            case "recv": return $this->data[0]->recv;
            case "sent": return $this->data[0]->sent;
            case "lost": return $this->data[0]->lost;
            case "retrans": return $this->data[0]->retrans;
            case "rtt": return $this->data[0]->rtt;
            case "cwnd": return $this->data[0]->cwnd;
            case "sent_bytes": return $this->data[0]->sent_bytes;
            case "recv_bytes": return $this->data[0]->recv_bytes;
            case "lost_bytes": return $this->data[0]->lost_bytes;
            case "stream_retrans_bytes": return $this->data[0]->stream_retrans_bytes;
            case "pmtu": return $this->data[0]->pmtu;
            case "delivery_rate": return $this->data[0]->delivery_rate;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "local_addr":
                (new struct_sockaddr_storage($_ = &$this->data[0]->local_addr))->set($value);
                return;
            case "local_addr_len":
                $this->data[0]->local_addr_len = $value;
                return;
            case "peer_addr":
                (new struct_sockaddr_storage($_ = &$this->data[0]->peer_addr))->set($value);
                return;
            case "peer_addr_len":
                $this->data[0]->peer_addr_len = $value;
                return;
            case "validation_state":
                $this->data[0]->validation_state = $value;
                return;
            case "active":
                $this->data[0]->active = $value;
                return;
            case "recv":
                $this->data[0]->recv = $value;
                return;
            case "sent":
                $this->data[0]->sent = $value;
                return;
            case "lost":
                $this->data[0]->lost = $value;
                return;
            case "retrans":
                $this->data[0]->retrans = $value;
                return;
            case "rtt":
                $this->data[0]->rtt = $value;
                return;
            case "cwnd":
                $this->data[0]->cwnd = $value;
                return;
            case "sent_bytes":
                $this->data[0]->sent_bytes = $value;
                return;
            case "recv_bytes":
                $this->data[0]->recv_bytes = $value;
                return;
            case "lost_bytes":
                $this->data[0]->lost_bytes = $value;
                return;
            case "stream_retrans_bytes":
                $this->data[0]->stream_retrans_bytes = $value;
                return;
            case "pmtu":
                $this->data[0]->pmtu = $value;
                return;
            case "delivery_rate":
                $this->data[0]->delivery_rate = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_path_stats_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_path_stats*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_path_stats_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_path_stats_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_path_stats_ptr_ptr_ptr { return new quiche_path_stats_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_path_stats_ptr { return new quiche_path_stats_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_path_stats_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_path_stats_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_path_stats_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_path_stats_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_path_stats_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_path_stats**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_path_stats_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_path_stats_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_path_stats_ptr_ptr_ptr_ptr { return new quiche_path_stats_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_path_stats_ptr_ptr { return new quiche_path_stats_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_path_stats_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_path_stats_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_path_stats_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_path_stats_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_path_stats_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_path_stats***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_path_stats_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_path_stats_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_path_stats_ptr_ptr_ptr_ptr_ptr { return new quiche_path_stats_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_path_stats_ptr_ptr_ptr { return new quiche_path_stats_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_path_stats_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_path_stats_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_path_stats_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_path_stats_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_path_stats_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_path_stats****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_path_event implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_path_event $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_path_event_ptr { return new struct_quiche_path_event_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_path_event $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_path_event'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_path_event_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_path_event_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_path_event_ptr_ptr { return new struct_quiche_path_event_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_path_event { return new struct_quiche_path_event($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_path_event { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_path_event[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_path_event($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_path_event_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_path_event*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_path_event_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_path_event_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_path_event_ptr_ptr_ptr { return new struct_quiche_path_event_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_path_event_ptr { return new struct_quiche_path_event_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_path_event_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_path_event_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_path_event_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_path_event_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_path_event_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_path_event**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_path_event_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_path_event_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_path_event_ptr_ptr_ptr_ptr { return new struct_quiche_path_event_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_path_event_ptr_ptr { return new struct_quiche_path_event_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_path_event_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_path_event_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_path_event_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_path_event_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_path_event_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_path_event***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_path_event_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_path_event_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_path_event_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_path_event_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_path_event_ptr_ptr_ptr { return new struct_quiche_path_event_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_path_event_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_path_event_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_path_event_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_path_event_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_path_event_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_path_event****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_socket_addr_iter implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_socket_addr_iter $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_socket_addr_iter_ptr { return new struct_quiche_socket_addr_iter_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_socket_addr_iter $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_socket_addr_iter'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_socket_addr_iter_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_socket_addr_iter_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_socket_addr_iter_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_socket_addr_iter { return new struct_quiche_socket_addr_iter($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_socket_addr_iter { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_socket_addr_iter[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_socket_addr_iter($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_socket_addr_iter_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_socket_addr_iter*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_socket_addr_iter_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_socket_addr_iter_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_socket_addr_iter_ptr_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_socket_addr_iter_ptr { return new struct_quiche_socket_addr_iter_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_socket_addr_iter_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_socket_addr_iter_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_socket_addr_iter_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_socket_addr_iter_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_socket_addr_iter_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_socket_addr_iter**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_socket_addr_iter_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_socket_addr_iter_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_socket_addr_iter_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_socket_addr_iter_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_socket_addr_iter_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_socket_addr_iter_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_socket_addr_iter_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_socket_addr_iter_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_socket_addr_iter***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_socket_addr_iter_ptr_ptr_ptr { return new struct_quiche_socket_addr_iter_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_socket_addr_iter_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_socket_addr_iter_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_socket_addr_iter_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_socket_addr_iter_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_socket_addr_iter****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_config implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_config $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_config_ptr { return new struct_quiche_h3_config_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_h3_config $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_config'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_config_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_config_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_config_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_config { return new struct_quiche_h3_config($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_config { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_config[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_config($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_h3_config_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_config*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_config_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_config_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_config_ptr_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_config_ptr { return new struct_quiche_h3_config_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_config_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_config_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_config_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_config_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_config_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_config**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_config_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_config_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_config_ptr_ptr_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_config_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_config_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_config_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_config_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_config_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_config_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_config***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_config_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_config_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_config_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_config_ptr_ptr_ptr { return new struct_quiche_h3_config_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_config_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_config_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_config_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_config_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_config_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_config****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_conn implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_conn $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_conn_ptr { return new struct_quiche_h3_conn_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_h3_conn $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_conn'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_conn_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_conn_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_conn_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_conn { return new struct_quiche_h3_conn($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_conn { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_conn[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_conn($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_h3_conn_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_conn*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_conn_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_conn_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_conn_ptr_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_conn_ptr { return new struct_quiche_h3_conn_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_conn_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_conn_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_conn_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_conn_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_conn_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_conn**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_conn_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_conn_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_conn_ptr_ptr_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_conn_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_conn_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_conn_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_conn_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_conn_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_conn_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_conn***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_conn_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_conn_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_conn_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_conn_ptr_ptr_ptr { return new struct_quiche_h3_conn_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_conn_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_conn_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_conn_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_conn_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_conn_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_conn****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_event implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_event $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_event_ptr { return new struct_quiche_h3_event_ptr(FFI::addr($this->data)); }
    public function set(struct_quiche_h3_event $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_event'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_event_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_event_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_event_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_event { return new struct_quiche_h3_event($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_event { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_event[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_event($this->data[$i]); } return $ret; }
    public function set(void_ptr | struct_quiche_h3_event_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_event*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_event_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_event_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_event_ptr_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_event_ptr { return new struct_quiche_h3_event_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_event_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_event_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_event_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_event_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_event_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_event**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_event_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_event_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_event_ptr_ptr_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_event_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_event_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_event_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_event_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_event_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_event_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_event***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_quiche_h3_event_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_quiche_h3_event_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_quiche_h3_event_ptr_ptr_ptr_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_quiche_h3_event_ptr_ptr_ptr { return new struct_quiche_h3_event_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_quiche_h3_event_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_quiche_h3_event_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_quiche_h3_event_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_quiche_h3_event_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_quiche_h3_event_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct quiche_h3_event****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $name
 * @property int $name_len
 * @property uint8_t_ptr $value
 * @property int $value_len
 */
class quiche_h3_header implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_header $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_header_ptr { return new quiche_h3_header_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "name": return new uint8_t_ptr($this->data->name);
            case "name_len": return $this->data->name_len;
            case "value": return new uint8_t_ptr($this->data->value);
            case "value_len": return $this->data->value_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "name":
                (new uint8_t_ptr($_ = &$this->data->name))->set($value);
                return;
            case "name_len":
                $this->data->name_len = $value;
                return;
            case "value":
                (new uint8_t_ptr($_ = &$this->data->value))->set($value);
                return;
            case "value_len":
                $this->data->value_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_h3_header $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_header'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $name
 * @property int $name_len
 * @property uint8_t_ptr $value
 * @property int $value_len
 */
class quiche_h3_header_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_header_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_header_ptr_ptr { return new quiche_h3_header_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_header { return new quiche_h3_header($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_header { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_header[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_header($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "name": return new uint8_t_ptr($this->data[0]->name);
            case "name_len": return $this->data[0]->name_len;
            case "value": return new uint8_t_ptr($this->data[0]->value);
            case "value_len": return $this->data[0]->value_len;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "name":
                (new uint8_t_ptr($_ = &$this->data[0]->name))->set($value);
                return;
            case "name_len":
                $this->data[0]->name_len = $value;
                return;
            case "value":
                (new uint8_t_ptr($_ = &$this->data[0]->value))->set($value);
                return;
            case "value_len":
                $this->data[0]->value_len = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_h3_header_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_header*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_header_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_header_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_header_ptr_ptr_ptr { return new quiche_h3_header_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_header_ptr { return new quiche_h3_header_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_header_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_header_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_header_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_header_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_header_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_header**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_header_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_header_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_header_ptr_ptr_ptr_ptr { return new quiche_h3_header_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_header_ptr_ptr { return new quiche_h3_header_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_header_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_header_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_header_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_header_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_header_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_header***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_header_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_header_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_header_ptr_ptr_ptr_ptr_ptr { return new quiche_h3_header_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_header_ptr_ptr_ptr { return new quiche_h3_header_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_header_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_header_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_header_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_header_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_header_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_header****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $urgency
 * @property int $incremental
 */
class quiche_h3_priority implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_priority $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_priority_ptr { return new quiche_h3_priority_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "urgency": return $this->data->urgency;
            case "incremental": return $this->data->incremental;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "urgency":
                $this->data->urgency = $value;
                return;
            case "incremental":
                $this->data->incremental = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(quiche_h3_priority $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_priority'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $urgency
 * @property int $incremental
 */
class quiche_h3_priority_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_priority_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_priority_ptr_ptr { return new quiche_h3_priority_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_priority { return new quiche_h3_priority($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_priority { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_priority[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_priority($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "urgency": return $this->data[0]->urgency;
            case "incremental": return $this->data[0]->incremental;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "urgency":
                $this->data[0]->urgency = $value;
                return;
            case "incremental":
                $this->data[0]->incremental = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | quiche_h3_priority_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_priority*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_priority_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_priority_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_priority_ptr_ptr_ptr { return new quiche_h3_priority_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_priority_ptr { return new quiche_h3_priority_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_priority_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_priority_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_priority_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_priority_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_priority_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_priority**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_priority_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_priority_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_priority_ptr_ptr_ptr_ptr { return new quiche_h3_priority_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_priority_ptr_ptr { return new quiche_h3_priority_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_priority_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_priority_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_priority_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_priority_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_priority_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_priority***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class quiche_h3_priority_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(quiche_h3_priority_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): quiche_h3_priority_ptr_ptr_ptr_ptr_ptr { return new quiche_h3_priority_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): quiche_h3_priority_ptr_ptr_ptr { return new quiche_h3_priority_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): quiche_h3_priority_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return quiche_h3_priority_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new quiche_h3_priority_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new quiche_h3_priority_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | quiche_h3_priority_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'quiche_h3_priority****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $s_addr
 */
class struct_in_addr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_addr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_addr_ptr { return new struct_in_addr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "s_addr": return $this->data->s_addr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "s_addr":
                $this->data->s_addr = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_in_addr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_addr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $s_addr
 */
class struct_in_addr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_addr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_addr_ptr_ptr { return new struct_in_addr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_addr { return new struct_in_addr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_addr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_addr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_addr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "s_addr": return $this->data[0]->s_addr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "s_addr":
                $this->data[0]->s_addr = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_in_addr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_addr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_addr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_addr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_addr_ptr_ptr_ptr { return new struct_in_addr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_addr_ptr { return new struct_in_addr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_addr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_addr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_addr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_addr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_addr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_addr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_addr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_addr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_addr_ptr_ptr_ptr_ptr { return new struct_in_addr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_addr_ptr_ptr { return new struct_in_addr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_addr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_addr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_addr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_addr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_addr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_addr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_addr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_addr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_addr_ptr_ptr_ptr_ptr_ptr { return new struct_in_addr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_addr_ptr_ptr_ptr { return new struct_in_addr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_addr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_addr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_addr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_addr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_addr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_addr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sin_len
 * @property int $sin_family
 * @property int $sin_port
 * @property struct_in_addr $sin_addr
 * @property string_ $sin_zero
 */
class struct_sockaddr_in implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in_ptr { return new struct_sockaddr_in_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sin_len": return $this->data->sin_len;
            case "sin_family": return $this->data->sin_family;
            case "sin_port": return $this->data->sin_port;
            case "sin_addr": return new struct_in_addr($this->data->sin_addr);
            case "sin_zero": return new string_($this->data->sin_zero);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sin_len":
                $this->data->sin_len = $value;
                return;
            case "sin_family":
                $this->data->sin_family = $value;
                return;
            case "sin_port":
                $this->data->sin_port = $value;
                return;
            case "sin_addr":
                (new struct_in_addr($_ = &$this->data->sin_addr))->set($value);
                return;
            case "sin_zero":
                (new string_($_ = &$this->data->sin_zero))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sockaddr_in $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sin_len
 * @property int $sin_family
 * @property int $sin_port
 * @property struct_in_addr $sin_addr
 * @property string_ $sin_zero
 */
class struct_sockaddr_in_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in_ptr_ptr { return new struct_sockaddr_in_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in { return new struct_sockaddr_in($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sin_len": return $this->data[0]->sin_len;
            case "sin_family": return $this->data[0]->sin_family;
            case "sin_port": return $this->data[0]->sin_port;
            case "sin_addr": return new struct_in_addr($this->data[0]->sin_addr);
            case "sin_zero": return new string_($this->data[0]->sin_zero);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sin_len":
                $this->data[0]->sin_len = $value;
                return;
            case "sin_family":
                $this->data[0]->sin_family = $value;
                return;
            case "sin_port":
                $this->data[0]->sin_port = $value;
                return;
            case "sin_addr":
                (new struct_in_addr($_ = &$this->data[0]->sin_addr))->set($value);
                return;
            case "sin_zero":
                (new string_($_ = &$this->data[0]->sin_zero))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sockaddr_in_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in_ptr_ptr_ptr { return new struct_sockaddr_in_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in_ptr { return new struct_sockaddr_in_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in_ptr_ptr_ptr_ptr { return new struct_sockaddr_in_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in_ptr_ptr { return new struct_sockaddr_in_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in_ptr_ptr_ptr_ptr_ptr { return new struct_sockaddr_in_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in_ptr_ptr_ptr { return new struct_sockaddr_in_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $ip_dst
 * @property string_ $ip_opts
 */
class struct_ip_opts implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_opts $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_opts_ptr { return new struct_ip_opts_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ip_dst": return new struct_in_addr($this->data->ip_dst);
            case "ip_opts": return new string_($this->data->ip_opts);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ip_dst":
                (new struct_in_addr($_ = &$this->data->ip_dst))->set($value);
                return;
            case "ip_opts":
                (new string_($_ = &$this->data->ip_opts))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ip_opts $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_opts'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $ip_dst
 * @property string_ $ip_opts
 */
class struct_ip_opts_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_opts_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_opts_ptr_ptr { return new struct_ip_opts_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_opts { return new struct_ip_opts($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_opts { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_opts[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_opts($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ip_dst": return new struct_in_addr($this->data[0]->ip_dst);
            case "ip_opts": return new string_($this->data[0]->ip_opts);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ip_dst":
                (new struct_in_addr($_ = &$this->data[0]->ip_dst))->set($value);
                return;
            case "ip_opts":
                (new string_($_ = &$this->data[0]->ip_opts))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ip_opts_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_opts*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_opts_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_opts_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_opts_ptr_ptr_ptr { return new struct_ip_opts_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_opts_ptr { return new struct_ip_opts_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_opts_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_opts_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_opts_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_opts_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_opts_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_opts**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_opts_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_opts_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_opts_ptr_ptr_ptr_ptr { return new struct_ip_opts_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_opts_ptr_ptr { return new struct_ip_opts_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_opts_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_opts_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_opts_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_opts_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_opts_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_opts***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_opts_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_opts_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_opts_ptr_ptr_ptr_ptr_ptr { return new struct_ip_opts_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_opts_ptr_ptr_ptr { return new struct_ip_opts_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_opts_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_opts_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_opts_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_opts_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_opts_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_opts****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_interface
 */
class struct_ip_mreq implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_ptr { return new struct_ip_mreq_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data->imr_multiaddr);
            case "imr_interface": return new struct_in_addr($this->data->imr_interface);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data->imr_multiaddr))->set($value);
                return;
            case "imr_interface":
                (new struct_in_addr($_ = &$this->data->imr_interface))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ip_mreq $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_interface
 */
class struct_ip_mreq_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_ptr_ptr { return new struct_ip_mreq_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq { return new struct_ip_mreq($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data[0]->imr_multiaddr);
            case "imr_interface": return new struct_in_addr($this->data[0]->imr_interface);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data[0]->imr_multiaddr))->set($value);
                return;
            case "imr_interface":
                (new struct_in_addr($_ = &$this->data[0]->imr_interface))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ip_mreq_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_ptr_ptr_ptr { return new struct_ip_mreq_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_ptr { return new struct_ip_mreq_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_ptr_ptr_ptr_ptr { return new struct_ip_mreq_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_ptr_ptr { return new struct_ip_mreq_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_ptr_ptr_ptr_ptr_ptr { return new struct_ip_mreq_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_ptr_ptr_ptr { return new struct_ip_mreq_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_address
 * @property int $imr_ifindex
 */
class struct_ip_mreqn implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreqn $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreqn_ptr { return new struct_ip_mreqn_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data->imr_multiaddr);
            case "imr_address": return new struct_in_addr($this->data->imr_address);
            case "imr_ifindex": return $this->data->imr_ifindex;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data->imr_multiaddr))->set($value);
                return;
            case "imr_address":
                (new struct_in_addr($_ = &$this->data->imr_address))->set($value);
                return;
            case "imr_ifindex":
                $this->data->imr_ifindex = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ip_mreqn $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreqn'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_address
 * @property int $imr_ifindex
 */
class struct_ip_mreqn_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreqn_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreqn_ptr_ptr { return new struct_ip_mreqn_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreqn { return new struct_ip_mreqn($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreqn { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreqn[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreqn($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data[0]->imr_multiaddr);
            case "imr_address": return new struct_in_addr($this->data[0]->imr_address);
            case "imr_ifindex": return $this->data[0]->imr_ifindex;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data[0]->imr_multiaddr))->set($value);
                return;
            case "imr_address":
                (new struct_in_addr($_ = &$this->data[0]->imr_address))->set($value);
                return;
            case "imr_ifindex":
                $this->data[0]->imr_ifindex = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ip_mreqn_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreqn*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreqn_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreqn_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreqn_ptr_ptr_ptr { return new struct_ip_mreqn_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreqn_ptr { return new struct_ip_mreqn_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreqn_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreqn_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreqn_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreqn_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreqn_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreqn**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreqn_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreqn_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreqn_ptr_ptr_ptr_ptr { return new struct_ip_mreqn_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreqn_ptr_ptr { return new struct_ip_mreqn_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreqn_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreqn_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreqn_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreqn_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreqn_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreqn***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreqn_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreqn_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreqn_ptr_ptr_ptr_ptr_ptr { return new struct_ip_mreqn_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreqn_ptr_ptr_ptr { return new struct_ip_mreqn_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreqn_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreqn_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreqn_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreqn_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreqn_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreqn****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_sourceaddr
 * @property struct_in_addr $imr_interface
 */
class struct_ip_mreq_source implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_source $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_source_ptr { return new struct_ip_mreq_source_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data->imr_multiaddr);
            case "imr_sourceaddr": return new struct_in_addr($this->data->imr_sourceaddr);
            case "imr_interface": return new struct_in_addr($this->data->imr_interface);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data->imr_multiaddr))->set($value);
                return;
            case "imr_sourceaddr":
                (new struct_in_addr($_ = &$this->data->imr_sourceaddr))->set($value);
                return;
            case "imr_interface":
                (new struct_in_addr($_ = &$this->data->imr_interface))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ip_mreq_source $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq_source'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in_addr $imr_multiaddr
 * @property struct_in_addr $imr_sourceaddr
 * @property struct_in_addr $imr_interface
 */
class struct_ip_mreq_source_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_source_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_source_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_source { return new struct_ip_mreq_source($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_source { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_source[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_source($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "imr_multiaddr": return new struct_in_addr($this->data[0]->imr_multiaddr);
            case "imr_sourceaddr": return new struct_in_addr($this->data[0]->imr_sourceaddr);
            case "imr_interface": return new struct_in_addr($this->data[0]->imr_interface);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "imr_multiaddr":
                (new struct_in_addr($_ = &$this->data[0]->imr_multiaddr))->set($value);
                return;
            case "imr_sourceaddr":
                (new struct_in_addr($_ = &$this->data[0]->imr_sourceaddr))->set($value);
                return;
            case "imr_interface":
                (new struct_in_addr($_ = &$this->data[0]->imr_interface))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ip_mreq_source_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq_source*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_source_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_source_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_source_ptr_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_source_ptr { return new struct_ip_mreq_source_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_source_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_source_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_source_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_source_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_source_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq_source**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_source_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_source_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_source_ptr_ptr_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_source_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_source_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_source_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_source_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_source_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_source_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq_source***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip_mreq_source_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip_mreq_source_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip_mreq_source_ptr_ptr_ptr_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip_mreq_source_ptr_ptr_ptr { return new struct_ip_mreq_source_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip_mreq_source_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip_mreq_source_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip_mreq_source_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip_mreq_source_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip_mreq_source_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip_mreq_source****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $gr_interface
 * @property struct_sockaddr_storage $gr_group
 */
class struct_group_req implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_req $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_req_ptr { return new struct_group_req_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "gr_interface": return $this->data->gr_interface;
            case "gr_group": return new struct_sockaddr_storage($this->data->gr_group);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "gr_interface":
                $this->data->gr_interface = $value;
                return;
            case "gr_group":
                (new struct_sockaddr_storage($_ = &$this->data->gr_group))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_group_req $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_req'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $gr_interface
 * @property struct_sockaddr_storage $gr_group
 */
class struct_group_req_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_req_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_req_ptr_ptr { return new struct_group_req_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_req { return new struct_group_req($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_req { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_req[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_req($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "gr_interface": return $this->data[0]->gr_interface;
            case "gr_group": return new struct_sockaddr_storage($this->data[0]->gr_group);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "gr_interface":
                $this->data[0]->gr_interface = $value;
                return;
            case "gr_group":
                (new struct_sockaddr_storage($_ = &$this->data[0]->gr_group))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_group_req_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_req*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_req_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_req_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_req_ptr_ptr_ptr { return new struct_group_req_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_req_ptr { return new struct_group_req_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_req_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_req_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_req_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_req_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_req_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_req**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_req_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_req_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_req_ptr_ptr_ptr_ptr { return new struct_group_req_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_req_ptr_ptr { return new struct_group_req_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_req_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_req_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_req_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_req_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_req_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_req***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_req_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_req_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_req_ptr_ptr_ptr_ptr_ptr { return new struct_group_req_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_req_ptr_ptr_ptr { return new struct_group_req_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_req_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_req_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_req_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_req_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_req_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_req****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $gsr_interface
 * @property struct_sockaddr_storage $gsr_group
 * @property struct_sockaddr_storage $gsr_source
 */
class struct_group_source_req implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_source_req $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_source_req_ptr { return new struct_group_source_req_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "gsr_interface": return $this->data->gsr_interface;
            case "gsr_group": return new struct_sockaddr_storage($this->data->gsr_group);
            case "gsr_source": return new struct_sockaddr_storage($this->data->gsr_source);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "gsr_interface":
                $this->data->gsr_interface = $value;
                return;
            case "gsr_group":
                (new struct_sockaddr_storage($_ = &$this->data->gsr_group))->set($value);
                return;
            case "gsr_source":
                (new struct_sockaddr_storage($_ = &$this->data->gsr_source))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_group_source_req $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_source_req'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $gsr_interface
 * @property struct_sockaddr_storage $gsr_group
 * @property struct_sockaddr_storage $gsr_source
 */
class struct_group_source_req_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_source_req_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_source_req_ptr_ptr { return new struct_group_source_req_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_source_req { return new struct_group_source_req($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_source_req { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_source_req[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_source_req($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "gsr_interface": return $this->data[0]->gsr_interface;
            case "gsr_group": return new struct_sockaddr_storage($this->data[0]->gsr_group);
            case "gsr_source": return new struct_sockaddr_storage($this->data[0]->gsr_source);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "gsr_interface":
                $this->data[0]->gsr_interface = $value;
                return;
            case "gsr_group":
                (new struct_sockaddr_storage($_ = &$this->data[0]->gsr_group))->set($value);
                return;
            case "gsr_source":
                (new struct_sockaddr_storage($_ = &$this->data[0]->gsr_source))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_group_source_req_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_source_req*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_source_req_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_source_req_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_source_req_ptr_ptr_ptr { return new struct_group_source_req_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_source_req_ptr { return new struct_group_source_req_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_source_req_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_source_req_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_source_req_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_source_req_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_source_req_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_source_req**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_source_req_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_source_req_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_source_req_ptr_ptr_ptr_ptr { return new struct_group_source_req_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_source_req_ptr_ptr { return new struct_group_source_req_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_source_req_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_source_req_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_source_req_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_source_req_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_source_req_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_source_req***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_group_source_req_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_group_source_req_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_group_source_req_ptr_ptr_ptr_ptr_ptr { return new struct_group_source_req_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_group_source_req_ptr_ptr_ptr { return new struct_group_source_req_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_group_source_req_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_group_source_req_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_group_source_req_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_group_source_req_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_group_source_req_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct group_source_req****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $msfr_ifindex
 * @property int $msfr_fmode
 * @property int $msfr_nsrcs
 * @property int $__msfr_align
 * @property struct_sockaddr_storage $msfr_group
 * @property struct_sockaddr_storage_ptr $msfr_srcs
 */
class struct___msfilterreq implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___msfilterreq $other): bool { return $this->data == $other->data; }
    public function addr(): struct___msfilterreq_ptr { return new struct___msfilterreq_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "msfr_ifindex": return $this->data->msfr_ifindex;
            case "msfr_fmode": return $this->data->msfr_fmode;
            case "msfr_nsrcs": return $this->data->msfr_nsrcs;
            case "__msfr_align": return $this->data->__msfr_align;
            case "msfr_group": return new struct_sockaddr_storage($this->data->msfr_group);
            case "msfr_srcs": return new struct_sockaddr_storage_ptr($this->data->msfr_srcs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "msfr_ifindex":
                $this->data->msfr_ifindex = $value;
                return;
            case "msfr_fmode":
                $this->data->msfr_fmode = $value;
                return;
            case "msfr_nsrcs":
                $this->data->msfr_nsrcs = $value;
                return;
            case "__msfr_align":
                $this->data->__msfr_align = $value;
                return;
            case "msfr_group":
                (new struct_sockaddr_storage($_ = &$this->data->msfr_group))->set($value);
                return;
            case "msfr_srcs":
                (new struct_sockaddr_storage_ptr($_ = &$this->data->msfr_srcs))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___msfilterreq $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __msfilterreq'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $msfr_ifindex
 * @property int $msfr_fmode
 * @property int $msfr_nsrcs
 * @property int $__msfr_align
 * @property struct_sockaddr_storage $msfr_group
 * @property struct_sockaddr_storage_ptr $msfr_srcs
 */
class struct___msfilterreq_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___msfilterreq_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___msfilterreq_ptr_ptr { return new struct___msfilterreq_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___msfilterreq { return new struct___msfilterreq($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___msfilterreq { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___msfilterreq[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___msfilterreq($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "msfr_ifindex": return $this->data[0]->msfr_ifindex;
            case "msfr_fmode": return $this->data[0]->msfr_fmode;
            case "msfr_nsrcs": return $this->data[0]->msfr_nsrcs;
            case "__msfr_align": return $this->data[0]->__msfr_align;
            case "msfr_group": return new struct_sockaddr_storage($this->data[0]->msfr_group);
            case "msfr_srcs": return new struct_sockaddr_storage_ptr($this->data[0]->msfr_srcs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "msfr_ifindex":
                $this->data[0]->msfr_ifindex = $value;
                return;
            case "msfr_fmode":
                $this->data[0]->msfr_fmode = $value;
                return;
            case "msfr_nsrcs":
                $this->data[0]->msfr_nsrcs = $value;
                return;
            case "__msfr_align":
                $this->data[0]->__msfr_align = $value;
                return;
            case "msfr_group":
                (new struct_sockaddr_storage($_ = &$this->data[0]->msfr_group))->set($value);
                return;
            case "msfr_srcs":
                (new struct_sockaddr_storage_ptr($_ = &$this->data[0]->msfr_srcs))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___msfilterreq_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __msfilterreq*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___msfilterreq_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___msfilterreq_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___msfilterreq_ptr_ptr_ptr { return new struct___msfilterreq_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___msfilterreq_ptr { return new struct___msfilterreq_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___msfilterreq_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___msfilterreq_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___msfilterreq_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___msfilterreq_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___msfilterreq_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __msfilterreq**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___msfilterreq_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___msfilterreq_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___msfilterreq_ptr_ptr_ptr_ptr { return new struct___msfilterreq_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___msfilterreq_ptr_ptr { return new struct___msfilterreq_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___msfilterreq_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___msfilterreq_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___msfilterreq_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___msfilterreq_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___msfilterreq_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __msfilterreq***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___msfilterreq_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___msfilterreq_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___msfilterreq_ptr_ptr_ptr_ptr_ptr { return new struct___msfilterreq_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct___msfilterreq_ptr_ptr_ptr { return new struct___msfilterreq_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___msfilterreq_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct___msfilterreq_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___msfilterreq_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___msfilterreq_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___msfilterreq_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __msfilterreq****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $ipi_ifindex
 * @property struct_in_addr $ipi_spec_dst
 * @property struct_in_addr $ipi_addr
 */
class struct_in_pktinfo implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_pktinfo $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_pktinfo_ptr { return new struct_in_pktinfo_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ipi_ifindex": return $this->data->ipi_ifindex;
            case "ipi_spec_dst": return new struct_in_addr($this->data->ipi_spec_dst);
            case "ipi_addr": return new struct_in_addr($this->data->ipi_addr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipi_ifindex":
                $this->data->ipi_ifindex = $value;
                return;
            case "ipi_spec_dst":
                (new struct_in_addr($_ = &$this->data->ipi_spec_dst))->set($value);
                return;
            case "ipi_addr":
                (new struct_in_addr($_ = &$this->data->ipi_addr))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_in_pktinfo $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_pktinfo'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $ipi_ifindex
 * @property struct_in_addr $ipi_spec_dst
 * @property struct_in_addr $ipi_addr
 */
class struct_in_pktinfo_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_pktinfo_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_pktinfo_ptr_ptr { return new struct_in_pktinfo_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_pktinfo { return new struct_in_pktinfo($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_pktinfo { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_pktinfo[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_pktinfo($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ipi_ifindex": return $this->data[0]->ipi_ifindex;
            case "ipi_spec_dst": return new struct_in_addr($this->data[0]->ipi_spec_dst);
            case "ipi_addr": return new struct_in_addr($this->data[0]->ipi_addr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipi_ifindex":
                $this->data[0]->ipi_ifindex = $value;
                return;
            case "ipi_spec_dst":
                (new struct_in_addr($_ = &$this->data[0]->ipi_spec_dst))->set($value);
                return;
            case "ipi_addr":
                (new struct_in_addr($_ = &$this->data[0]->ipi_addr))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_in_pktinfo_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_pktinfo*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_pktinfo_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_pktinfo_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_pktinfo_ptr_ptr_ptr { return new struct_in_pktinfo_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_pktinfo_ptr { return new struct_in_pktinfo_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_pktinfo_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_pktinfo_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_pktinfo_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_pktinfo_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_pktinfo_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_pktinfo**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_pktinfo_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_pktinfo_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_pktinfo_ptr_ptr_ptr_ptr { return new struct_in_pktinfo_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_pktinfo_ptr_ptr { return new struct_in_pktinfo_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_pktinfo_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_pktinfo_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_pktinfo_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_pktinfo_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_pktinfo_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_pktinfo***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in_pktinfo_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in_pktinfo_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in_pktinfo_ptr_ptr_ptr_ptr_ptr { return new struct_in_pktinfo_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in_pktinfo_ptr_ptr_ptr { return new struct_in_pktinfo_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in_pktinfo_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in_pktinfo_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in_pktinfo_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in_pktinfo_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in_pktinfo_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in_pktinfo****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union_anonymous_id_58 $__u6_addr
 */
class struct_in6_addr implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_addr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_addr_ptr { return new struct_in6_addr_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__u6_addr": return new union_anonymous_id_58($this->data->__u6_addr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__u6_addr":
                (new union_anonymous_id_58($_ = &$this->data->__u6_addr))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_in6_addr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_addr'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union_anonymous_id_58 $__u6_addr
 */
class struct_in6_addr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_addr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_addr_ptr_ptr { return new struct_in6_addr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_addr { return new struct_in6_addr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_addr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_addr[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_addr($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__u6_addr": return new union_anonymous_id_58($this->data[0]->__u6_addr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__u6_addr":
                (new union_anonymous_id_58($_ = &$this->data[0]->__u6_addr))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_in6_addr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_addr*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_addr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_addr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_addr_ptr_ptr_ptr { return new struct_in6_addr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_addr_ptr { return new struct_in6_addr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_addr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_addr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_addr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_addr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_addr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_addr**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_addr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_addr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_addr_ptr_ptr_ptr_ptr { return new struct_in6_addr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_addr_ptr_ptr { return new struct_in6_addr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_addr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_addr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_addr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_addr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_addr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_addr***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_addr_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_addr_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_addr_ptr_ptr_ptr_ptr_ptr { return new struct_in6_addr_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_addr_ptr_ptr_ptr { return new struct_in6_addr_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_addr_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_addr_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_addr_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_addr_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_addr_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_addr****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property unsigned_char_ptr $__u6_addr8
 * @property unsigned_short_ptr $__u6_addr16
 * @property unsigned_int_ptr $__u6_addr32
 */
class union_anonymous_id_58 implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_anonymous_id_58 $other): bool { return $this->data == $other->data; }
    public function addr(): union_anonymous_id_58_ptr { return new union_anonymous_id_58_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__u6_addr8": return new unsigned_char_ptr($this->data->__u6_addr8);
            case "__u6_addr16": return new unsigned_short_ptr($this->data->__u6_addr16);
            case "__u6_addr32": return new unsigned_int_ptr($this->data->__u6_addr32);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__u6_addr8":
                (new unsigned_char_ptr($_ = &$this->data->__u6_addr8))->set($value);
                return;
            case "__u6_addr16":
                (new unsigned_short_ptr($_ = &$this->data->__u6_addr16))->set($value);
                return;
            case "__u6_addr32":
                (new unsigned_int_ptr($_ = &$this->data->__u6_addr32))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(union_anonymous_id_58 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union anonymous id 58'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property unsigned_char_ptr $__u6_addr8
 * @property unsigned_short_ptr $__u6_addr16
 * @property unsigned_int_ptr $__u6_addr32
 */
class union_anonymous_id_58_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_anonymous_id_58_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_anonymous_id_58_ptr_ptr { return new union_anonymous_id_58_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): union_anonymous_id_58 { return new union_anonymous_id_58($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_anonymous_id_58 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return union_anonymous_id_58[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new union_anonymous_id_58($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__u6_addr8": return new unsigned_char_ptr($this->data[0]->__u6_addr8);
            case "__u6_addr16": return new unsigned_short_ptr($this->data[0]->__u6_addr16);
            case "__u6_addr32": return new unsigned_int_ptr($this->data[0]->__u6_addr32);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__u6_addr8":
                (new unsigned_char_ptr($_ = &$this->data[0]->__u6_addr8))->set($value);
                return;
            case "__u6_addr16":
                (new unsigned_short_ptr($_ = &$this->data[0]->__u6_addr16))->set($value);
                return;
            case "__u6_addr32":
                (new unsigned_int_ptr($_ = &$this->data[0]->__u6_addr32))->set($value);
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | union_anonymous_id_58_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union anonymous id 58*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_anonymous_id_58_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_anonymous_id_58_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_anonymous_id_58_ptr_ptr_ptr { return new union_anonymous_id_58_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): union_anonymous_id_58_ptr { return new union_anonymous_id_58_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_anonymous_id_58_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return union_anonymous_id_58_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_anonymous_id_58_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_anonymous_id_58_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_anonymous_id_58_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union anonymous id 58**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_anonymous_id_58_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_anonymous_id_58_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_anonymous_id_58_ptr_ptr_ptr_ptr { return new union_anonymous_id_58_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): union_anonymous_id_58_ptr_ptr { return new union_anonymous_id_58_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_anonymous_id_58_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return union_anonymous_id_58_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_anonymous_id_58_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_anonymous_id_58_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_anonymous_id_58_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union anonymous id 58***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_anonymous_id_58_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_anonymous_id_58_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_anonymous_id_58_ptr_ptr_ptr_ptr_ptr { return new union_anonymous_id_58_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): union_anonymous_id_58_ptr_ptr_ptr { return new union_anonymous_id_58_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_anonymous_id_58_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return union_anonymous_id_58_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_anonymous_id_58_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_anonymous_id_58_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_anonymous_id_58_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union anonymous id 58****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sin6_len
 * @property int $sin6_family
 * @property int $sin6_port
 * @property int $sin6_flowinfo
 * @property struct_in6_addr $sin6_addr
 * @property int $sin6_scope_id
 */
class struct_sockaddr_in6 implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in6 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in6_ptr { return new struct_sockaddr_in6_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sin6_len": return $this->data->sin6_len;
            case "sin6_family": return $this->data->sin6_family;
            case "sin6_port": return $this->data->sin6_port;
            case "sin6_flowinfo": return $this->data->sin6_flowinfo;
            case "sin6_addr": return new struct_in6_addr($this->data->sin6_addr);
            case "sin6_scope_id": return $this->data->sin6_scope_id;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sin6_len":
                $this->data->sin6_len = $value;
                return;
            case "sin6_family":
                $this->data->sin6_family = $value;
                return;
            case "sin6_port":
                $this->data->sin6_port = $value;
                return;
            case "sin6_flowinfo":
                $this->data->sin6_flowinfo = $value;
                return;
            case "sin6_addr":
                (new struct_in6_addr($_ = &$this->data->sin6_addr))->set($value);
                return;
            case "sin6_scope_id":
                $this->data->sin6_scope_id = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sockaddr_in6 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in6'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sin6_len
 * @property int $sin6_family
 * @property int $sin6_port
 * @property int $sin6_flowinfo
 * @property struct_in6_addr $sin6_addr
 * @property int $sin6_scope_id
 */
class struct_sockaddr_in6_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in6_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in6_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in6 { return new struct_sockaddr_in6($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in6 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in6[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in6($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sin6_len": return $this->data[0]->sin6_len;
            case "sin6_family": return $this->data[0]->sin6_family;
            case "sin6_port": return $this->data[0]->sin6_port;
            case "sin6_flowinfo": return $this->data[0]->sin6_flowinfo;
            case "sin6_addr": return new struct_in6_addr($this->data[0]->sin6_addr);
            case "sin6_scope_id": return $this->data[0]->sin6_scope_id;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sin6_len":
                $this->data[0]->sin6_len = $value;
                return;
            case "sin6_family":
                $this->data[0]->sin6_family = $value;
                return;
            case "sin6_port":
                $this->data[0]->sin6_port = $value;
                return;
            case "sin6_flowinfo":
                $this->data[0]->sin6_flowinfo = $value;
                return;
            case "sin6_addr":
                (new struct_in6_addr($_ = &$this->data[0]->sin6_addr))->set($value);
                return;
            case "sin6_scope_id":
                $this->data[0]->sin6_scope_id = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sockaddr_in6_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in6*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in6_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in6_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in6_ptr_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in6_ptr { return new struct_sockaddr_in6_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in6_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in6_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in6_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in6_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in6_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in6**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in6_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in6_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in6_ptr_ptr_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in6_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in6_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in6_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in6_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in6_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in6_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in6***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sockaddr_in6_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sockaddr_in6_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sockaddr_in6_ptr_ptr_ptr_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_sockaddr_in6_ptr_ptr_ptr { return new struct_sockaddr_in6_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sockaddr_in6_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_sockaddr_in6_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sockaddr_in6_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sockaddr_in6_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sockaddr_in6_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sockaddr_in6****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in6_addr $ipv6mr_multiaddr
 * @property int $ipv6mr_interface
 */
class struct_ipv6_mreq implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ipv6_mreq $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ipv6_mreq_ptr { return new struct_ipv6_mreq_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ipv6mr_multiaddr": return new struct_in6_addr($this->data->ipv6mr_multiaddr);
            case "ipv6mr_interface": return $this->data->ipv6mr_interface;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipv6mr_multiaddr":
                (new struct_in6_addr($_ = &$this->data->ipv6mr_multiaddr))->set($value);
                return;
            case "ipv6mr_interface":
                $this->data->ipv6mr_interface = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ipv6_mreq $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ipv6_mreq'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in6_addr $ipv6mr_multiaddr
 * @property int $ipv6mr_interface
 */
class struct_ipv6_mreq_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ipv6_mreq_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ipv6_mreq_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ipv6_mreq { return new struct_ipv6_mreq($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ipv6_mreq { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ipv6_mreq[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ipv6_mreq($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ipv6mr_multiaddr": return new struct_in6_addr($this->data[0]->ipv6mr_multiaddr);
            case "ipv6mr_interface": return $this->data[0]->ipv6mr_interface;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipv6mr_multiaddr":
                (new struct_in6_addr($_ = &$this->data[0]->ipv6mr_multiaddr))->set($value);
                return;
            case "ipv6mr_interface":
                $this->data[0]->ipv6mr_interface = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ipv6_mreq_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ipv6_mreq*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ipv6_mreq_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ipv6_mreq_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ipv6_mreq_ptr_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ipv6_mreq_ptr { return new struct_ipv6_mreq_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ipv6_mreq_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ipv6_mreq_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ipv6_mreq_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ipv6_mreq_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ipv6_mreq_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ipv6_mreq**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ipv6_mreq_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ipv6_mreq_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ipv6_mreq_ptr_ptr_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ipv6_mreq_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ipv6_mreq_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ipv6_mreq_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ipv6_mreq_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ipv6_mreq_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ipv6_mreq_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ipv6_mreq***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ipv6_mreq_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ipv6_mreq_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ipv6_mreq_ptr_ptr_ptr_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ipv6_mreq_ptr_ptr_ptr { return new struct_ipv6_mreq_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ipv6_mreq_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ipv6_mreq_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ipv6_mreq_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ipv6_mreq_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ipv6_mreq_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ipv6_mreq****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in6_addr $ipi6_addr
 * @property int $ipi6_ifindex
 */
class struct_in6_pktinfo implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_pktinfo $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_pktinfo_ptr { return new struct_in6_pktinfo_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ipi6_addr": return new struct_in6_addr($this->data->ipi6_addr);
            case "ipi6_ifindex": return $this->data->ipi6_ifindex;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipi6_addr":
                (new struct_in6_addr($_ = &$this->data->ipi6_addr))->set($value);
                return;
            case "ipi6_ifindex":
                $this->data->ipi6_ifindex = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_in6_pktinfo $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_pktinfo'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_in6_addr $ipi6_addr
 * @property int $ipi6_ifindex
 */
class struct_in6_pktinfo_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_pktinfo_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_pktinfo_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_pktinfo { return new struct_in6_pktinfo($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_pktinfo { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_pktinfo[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_pktinfo($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ipi6_addr": return new struct_in6_addr($this->data[0]->ipi6_addr);
            case "ipi6_ifindex": return $this->data[0]->ipi6_ifindex;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ipi6_addr":
                (new struct_in6_addr($_ = &$this->data[0]->ipi6_addr))->set($value);
                return;
            case "ipi6_ifindex":
                $this->data[0]->ipi6_ifindex = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_in6_pktinfo_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_pktinfo*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_pktinfo_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_pktinfo_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_pktinfo_ptr_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_pktinfo_ptr { return new struct_in6_pktinfo_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_pktinfo_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_pktinfo_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_pktinfo_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_pktinfo_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_pktinfo_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_pktinfo**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_pktinfo_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_pktinfo_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_pktinfo_ptr_ptr_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_pktinfo_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_pktinfo_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_pktinfo_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_pktinfo_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_pktinfo_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_pktinfo_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_pktinfo***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_in6_pktinfo_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_in6_pktinfo_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_in6_pktinfo_ptr_ptr_ptr_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_in6_pktinfo_ptr_ptr_ptr { return new struct_in6_pktinfo_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_in6_pktinfo_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_in6_pktinfo_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_in6_pktinfo_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_in6_pktinfo_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_in6_pktinfo_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct in6_pktinfo****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_in6 $ip6m_addr
 * @property int $ip6m_mtu
 */
class struct_ip6_mtuinfo implements iQuiche {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip6_mtuinfo $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip6_mtuinfo_ptr { return new struct_ip6_mtuinfo_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ip6m_addr": return new struct_sockaddr_in6($this->data->ip6m_addr);
            case "ip6m_mtu": return $this->data->ip6m_mtu;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ip6m_addr":
                (new struct_sockaddr_in6($_ = &$this->data->ip6m_addr))->set($value);
                return;
            case "ip6m_mtu":
                $this->data->ip6m_mtu = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_ip6_mtuinfo $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip6_mtuinfo'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_sockaddr_in6 $ip6m_addr
 * @property int $ip6m_mtu
 */
class struct_ip6_mtuinfo_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip6_mtuinfo_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip6_mtuinfo_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip6_mtuinfo { return new struct_ip6_mtuinfo($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip6_mtuinfo { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip6_mtuinfo[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip6_mtuinfo($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ip6m_addr": return new struct_sockaddr_in6($this->data[0]->ip6m_addr);
            case "ip6m_mtu": return $this->data[0]->ip6m_mtu;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ip6m_addr":
                (new struct_sockaddr_in6($_ = &$this->data[0]->ip6m_addr))->set($value);
                return;
            case "ip6m_mtu":
                $this->data[0]->ip6m_mtu = $value;
                return;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_ip6_mtuinfo_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip6_mtuinfo*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip6_mtuinfo_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip6_mtuinfo_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip6_mtuinfo_ptr_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip6_mtuinfo_ptr { return new struct_ip6_mtuinfo_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip6_mtuinfo_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip6_mtuinfo_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip6_mtuinfo_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip6_mtuinfo_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip6_mtuinfo_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip6_mtuinfo**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip6_mtuinfo_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip6_mtuinfo_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip6_mtuinfo_ptr_ptr_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip6_mtuinfo_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip6_mtuinfo_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip6_mtuinfo_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip6_mtuinfo_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip6_mtuinfo_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip6_mtuinfo_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip6_mtuinfo***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_ip6_mtuinfo_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_ip6_mtuinfo_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_ip6_mtuinfo_ptr_ptr_ptr_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): struct_ip6_mtuinfo_ptr_ptr_ptr { return new struct_ip6_mtuinfo_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_ip6_mtuinfo_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return struct_ip6_mtuinfo_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_ip6_mtuinfo_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_ip6_mtuinfo_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_ip6_mtuinfo_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct ip6_mtuinfo****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr { return new _Bool_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function toString(?int $length = null): string { return $length === null ? FFI::string(FFI::cdef()->cast("char*", $this->data)) : FFI::string(FFI::cdef()->cast("char*", $this->data), $length); }
    public static function persistent(string $string): self { $str = new self(FFI::cdef()->new("unsigned char[" . \strlen($string) . "]", false)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function owned(string $string): self { $str = new self(FFI::cdef()->new("unsigned char[" . \strlen($string) . "]", true)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function persistentZero(string $string): self { return self::persistent("$string\0"); }
    public static function ownedZero(string $string): self { return self::owned("$string\0"); }
    public function set(int | void_ptr | _Bool_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return '_Bool*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): _Bool_ptr { return new _Bool_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return _Bool_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): _Bool_ptr_ptr { return new _Bool_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return _Bool_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): _Bool_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return _Bool_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr { return new int8_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int8_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int8_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int8_t_ptr { return new int8_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int8_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int8_t_ptr_ptr { return new int8_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int8_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int8_t_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int8_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr { return new int16_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int16_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int16_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int16_t_ptr { return new int16_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int16_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int16_t_ptr_ptr { return new int16_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int16_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int16_t_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int16_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr { return new uint16_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint16_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint16_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint16_t_ptr { return new uint16_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint16_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint16_t_ptr_ptr { return new uint16_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint16_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint16_t_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint16_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr { return new int32_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int32_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int32_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int32_t_ptr { return new int32_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int32_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int32_t_ptr_ptr { return new int32_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int32_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int32_t_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int32_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr { return new uint32_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint32_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint32_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint32_t_ptr { return new uint32_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint32_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint32_t_ptr_ptr { return new uint32_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint32_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint32_t_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint32_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr { return new int64_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int64_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int64_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int64_t_ptr { return new int64_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int64_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int64_t_ptr_ptr { return new int64_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int64_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int64_t_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int64_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr { return new uint64_t_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint64_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint64_t*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint64_t_ptr { return new uint64_t_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint64_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint64_t_ptr_ptr { return new uint64_t_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint64_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): uint64_t_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return uint64_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class double_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(double_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): double_ptr_ptr { return new double_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): float { return $this->data[$n] + 0.0; }
    #[\ReturnTypeWillChange] public function offsetGet($offset): float { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return float[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(float | void_ptr | double_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'double*'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class double_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(double_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): double_ptr_ptr_ptr { return new double_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): double_ptr { return new double_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): double_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return double_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new double_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new double_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | double_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'double**'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class double_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(double_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): double_ptr_ptr_ptr_ptr { return new double_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): double_ptr_ptr { return new double_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): double_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return double_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new double_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new double_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | double_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'double***'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class double_ptr_ptr_ptr_ptr implements iQuiche, iQuiche_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iQuiche $data): self { return QuicheFFI::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(double_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): double_ptr_ptr_ptr_ptr_ptr { return new double_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    public function deref(int $n = 0): double_ptr_ptr_ptr { return new double_ptr_ptr_ptr($this->data[$n]); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): double_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public static function array(int $size = 1): self { return QuicheFFI::makeArray(self::class, $size); }
    /** @return double_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new double_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new double_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | double_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'double****'; }
    public static function size(): int { return QuicheFFI::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
(function() { self::$staticFFI = \FFI::cdef(QuicheFFI::TYPES_DEF); self::$__arrayWeakMap = new \WeakMap; })->bindTo(null, QuicheFFI::class)();
\class_alias(_Bool_ptr::class, uint8_t_ptr::class);
\class_alias(_Bool_ptr_ptr::class, uint8_t_ptr_ptr::class);
\class_alias(_Bool_ptr_ptr_ptr::class, uint8_t_ptr_ptr_ptr::class);
\class_alias(_Bool_ptr_ptr_ptr_ptr::class, uint8_t_ptr_ptr_ptr_ptr::class);
\class_alias(_Bool_ptr::class, unsigned_char_ptr::class);
\class_alias(_Bool_ptr_ptr::class, unsigned_char_ptr_ptr::class);
\class_alias(_Bool_ptr_ptr_ptr::class, unsigned_char_ptr_ptr_ptr::class);
\class_alias(_Bool_ptr_ptr_ptr_ptr::class, unsigned_char_ptr_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr::class, short_ptr::class);
\class_alias(int16_t_ptr_ptr::class, short_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr::class, short_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr_ptr::class, short_ptr_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr::class, unsigned_short_ptr::class);
\class_alias(uint16_t_ptr_ptr::class, unsigned_short_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr::class, unsigned_short_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr_ptr::class, unsigned_short_ptr_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, int_ptr::class);
\class_alias(int32_t_ptr_ptr::class, int_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, int_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, int_ptr_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr::class, unsigned_int_ptr::class);
\class_alias(uint32_t_ptr_ptr::class, unsigned_int_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr::class, unsigned_int_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr_ptr::class, unsigned_int_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, size_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, size_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, size_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, size_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, long_ptr::class);
\class_alias(int64_t_ptr_ptr::class, long_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, long_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, long_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, long_long_ptr::class);
\class_alias(int64_t_ptr_ptr::class, long_long_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, long_long_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, long_long_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, long_int_ptr::class);
\class_alias(int64_t_ptr_ptr::class, long_int_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, long_int_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, long_int_ptr_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr::class, unsigned_long_ptr::class);
\class_alias(uint64_t_ptr_ptr::class, unsigned_long_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr::class, unsigned_long_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr_ptr::class, unsigned_long_ptr_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr::class, unsigned_long_int_ptr::class);
\class_alias(uint64_t_ptr_ptr::class, unsigned_long_int_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr::class, unsigned_long_int_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr_ptr::class, unsigned_long_int_ptr_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr::class, unsigned_long_long_ptr::class);
\class_alias(uint64_t_ptr_ptr::class, unsigned_long_long_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr::class, unsigned_long_long_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr_ptr::class, unsigned_long_long_ptr_ptr_ptr_ptr::class);
\class_alias(int8_t_ptr::class, int_least8_t_ptr::class);
\class_alias(int8_t_ptr_ptr::class, int_least8_t_ptr_ptr::class);
\class_alias(int8_t_ptr_ptr_ptr::class, int_least8_t_ptr_ptr_ptr::class);
\class_alias(int8_t_ptr_ptr_ptr_ptr::class, int_least8_t_ptr_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr::class, int_least16_t_ptr::class);
\class_alias(int16_t_ptr_ptr::class, int_least16_t_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr::class, int_least16_t_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr_ptr::class, int_least16_t_ptr_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, int_least32_t_ptr::class);
\class_alias(int32_t_ptr_ptr::class, int_least32_t_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, int_least32_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, int_least32_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, int_least64_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, int_least64_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, int_least64_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, int_least64_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint8_t_ptr::class, uint_least8_t_ptr::class);
\class_alias(uint8_t_ptr_ptr::class, uint_least8_t_ptr_ptr::class);
\class_alias(uint8_t_ptr_ptr_ptr::class, uint_least8_t_ptr_ptr_ptr::class);
\class_alias(uint8_t_ptr_ptr_ptr_ptr::class, uint_least8_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr::class, uint_least16_t_ptr::class);
\class_alias(uint16_t_ptr_ptr::class, uint_least16_t_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr::class, uint_least16_t_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr_ptr::class, uint_least16_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr::class, uint_least32_t_ptr::class);
\class_alias(uint32_t_ptr_ptr::class, uint_least32_t_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr::class, uint_least32_t_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr_ptr::class, uint_least32_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr::class, uint_least64_t_ptr::class);
\class_alias(uint64_t_ptr_ptr::class, uint_least64_t_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr::class, uint_least64_t_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr_ptr::class, uint_least64_t_ptr_ptr_ptr_ptr::class);
\class_alias(int8_t_ptr::class, int_fast8_t_ptr::class);
\class_alias(int8_t_ptr_ptr::class, int_fast8_t_ptr_ptr::class);
\class_alias(int8_t_ptr_ptr_ptr::class, int_fast8_t_ptr_ptr_ptr::class);
\class_alias(int8_t_ptr_ptr_ptr_ptr::class, int_fast8_t_ptr_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr::class, int_fast16_t_ptr::class);
\class_alias(int16_t_ptr_ptr::class, int_fast16_t_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr::class, int_fast16_t_ptr_ptr_ptr::class);
\class_alias(int16_t_ptr_ptr_ptr_ptr::class, int_fast16_t_ptr_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, int_fast32_t_ptr::class);
\class_alias(int32_t_ptr_ptr::class, int_fast32_t_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, int_fast32_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, int_fast32_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, int_fast64_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, int_fast64_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, int_fast64_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, int_fast64_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint8_t_ptr::class, uint_fast8_t_ptr::class);
\class_alias(uint8_t_ptr_ptr::class, uint_fast8_t_ptr_ptr::class);
\class_alias(uint8_t_ptr_ptr_ptr::class, uint_fast8_t_ptr_ptr_ptr::class);
\class_alias(uint8_t_ptr_ptr_ptr_ptr::class, uint_fast8_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr::class, uint_fast16_t_ptr::class);
\class_alias(uint16_t_ptr_ptr::class, uint_fast16_t_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr::class, uint_fast16_t_ptr_ptr_ptr::class);
\class_alias(uint16_t_ptr_ptr_ptr_ptr::class, uint_fast16_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr::class, uint_fast32_t_ptr::class);
\class_alias(uint32_t_ptr_ptr::class, uint_fast32_t_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr::class, uint_fast32_t_ptr_ptr_ptr::class);
\class_alias(uint32_t_ptr_ptr_ptr_ptr::class, uint_fast32_t_ptr_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr::class, uint_fast64_t_ptr::class);
\class_alias(uint64_t_ptr_ptr::class, uint_fast64_t_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr::class, uint_fast64_t_ptr_ptr_ptr::class);
\class_alias(uint64_t_ptr_ptr_ptr_ptr::class, uint_fast64_t_ptr_ptr_ptr_ptr::class);
\class_alias(string_::class, __int8_t_ptr::class);
\class_alias(string_ptr::class, __int8_t_ptr_ptr::class);
\class_alias(string_ptr_ptr::class, __int8_t_ptr_ptr_ptr::class);
\class_alias(string_ptr_ptr_ptr::class, __int8_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr::class, __uint8_t_ptr::class);
\class_alias(unsigned_char_ptr_ptr::class, __uint8_t_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr::class, __uint8_t_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr_ptr::class, __uint8_t_ptr_ptr_ptr_ptr::class);
\class_alias(short_ptr::class, __int16_t_ptr::class);
\class_alias(short_ptr_ptr::class, __int16_t_ptr_ptr::class);
\class_alias(short_ptr_ptr_ptr::class, __int16_t_ptr_ptr_ptr::class);
\class_alias(short_ptr_ptr_ptr_ptr::class, __int16_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, __uint16_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, __uint16_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, __uint16_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, __uint16_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __int32_t_ptr::class);
\class_alias(int_ptr_ptr::class, __int32_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __int32_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __int32_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __uint32_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __uint32_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __uint32_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __uint32_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_long_ptr::class, __int64_t_ptr::class);
\class_alias(long_long_ptr_ptr::class, __int64_t_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr::class, __int64_t_ptr_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr_ptr::class, __int64_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, __uint64_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, __uint64_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, __uint64_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, __uint64_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, __darwin_intptr_t_ptr::class);
\class_alias(long_ptr_ptr::class, __darwin_intptr_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, __darwin_intptr_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, __darwin_intptr_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_natural_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_natural_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_natural_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_natural_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_ct_rune_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_ct_rune_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_ct_rune_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_ct_rune_t_ptr_ptr_ptr_ptr::class);
\class_alias(__mbstate_t::class, __darwin_mbstate_t::class);
\class_alias(__mbstate_t_ptr::class, __darwin_mbstate_t_ptr::class);
\class_alias(__mbstate_t_ptr_ptr::class, __darwin_mbstate_t_ptr_ptr::class);
\class_alias(__mbstate_t_ptr_ptr_ptr::class, __darwin_mbstate_t_ptr_ptr_ptr::class);
\class_alias(__mbstate_t_ptr_ptr_ptr_ptr::class, __darwin_mbstate_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_int_ptr::class, __darwin_ptrdiff_t_ptr::class);
\class_alias(long_int_ptr_ptr::class, __darwin_ptrdiff_t_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr::class, __darwin_ptrdiff_t_ptr_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr_ptr::class, __darwin_ptrdiff_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr::class, __darwin_size_t_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr::class, __darwin_size_t_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr::class, __darwin_size_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr_ptr::class, __darwin_size_t_ptr_ptr_ptr_ptr::class);
\class_alias(__builtin_va_list::class, __darwin_va_list::class);
\class_alias(__builtin_va_list_ptr::class, __darwin_va_list_ptr::class);
\class_alias(__builtin_va_list_ptr_ptr::class, __darwin_va_list_ptr_ptr::class);
\class_alias(__builtin_va_list_ptr_ptr_ptr::class, __darwin_va_list_ptr_ptr_ptr::class);
\class_alias(__builtin_va_list_ptr_ptr_ptr_ptr::class, __darwin_va_list_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_wchar_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_wchar_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_wchar_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_wchar_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_rune_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_rune_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_rune_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_rune_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_wint_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_wint_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_wint_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_wint_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, __darwin_clock_t_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, __darwin_clock_t_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, __darwin_clock_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, __darwin_clock_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_socklen_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_socklen_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_socklen_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_socklen_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, __darwin_ssize_t_ptr::class);
\class_alias(long_ptr_ptr::class, __darwin_ssize_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, __darwin_ssize_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, __darwin_ssize_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, __darwin_time_t_ptr::class);
\class_alias(long_ptr_ptr::class, __darwin_time_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, __darwin_time_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, __darwin_time_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_long_ptr::class, __darwin_blkcnt_t_ptr::class);
\class_alias(long_long_ptr_ptr::class, __darwin_blkcnt_t_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr::class, __darwin_blkcnt_t_ptr_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr_ptr::class, __darwin_blkcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_blksize_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_blksize_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_blksize_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_blksize_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_dev_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_dev_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_dev_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_dev_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_fsblkcnt_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_fsblkcnt_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_fsblkcnt_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_fsblkcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_fsfilcnt_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_fsfilcnt_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_fsfilcnt_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_fsfilcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_gid_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_gid_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_gid_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_gid_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_id_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_id_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_id_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_id_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, __darwin_ino64_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, __darwin_ino64_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, __darwin_ino64_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, __darwin_ino64_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, __darwin_ino_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, __darwin_ino_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, __darwin_ino_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, __darwin_ino_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_mach_port_name_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_mach_port_name_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_mach_port_name_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_mach_port_name_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_mach_port_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_mach_port_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_mach_port_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_mach_port_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, __darwin_mode_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, __darwin_mode_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, __darwin_mode_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, __darwin_mode_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_long_ptr::class, __darwin_off_t_ptr::class);
\class_alias(long_long_ptr_ptr::class, __darwin_off_t_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr::class, __darwin_off_t_ptr_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr_ptr::class, __darwin_off_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_pid_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_pid_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_pid_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_pid_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_sigset_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_sigset_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_sigset_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_sigset_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_suseconds_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_suseconds_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_suseconds_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_suseconds_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_uid_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_uid_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_uid_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_uid_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_useconds_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_useconds_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_useconds_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_useconds_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr::class, __darwin_uuid_t::class);
\class_alias(unsigned_char_ptr_ptr::class, __darwin_uuid_t_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr::class, __darwin_uuid_t_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr_ptr::class, __darwin_uuid_t_ptr_ptr_ptr::class);
\class_alias(string_::class, __darwin_uuid_string_t::class);
\class_alias(string_ptr::class, __darwin_uuid_string_t_ptr::class);
\class_alias(string_ptr_ptr::class, __darwin_uuid_string_t_ptr_ptr::class);
\class_alias(string_ptr_ptr_ptr::class, __darwin_uuid_string_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t::class, __darwin_pthread_attr_t::class);
\class_alias(struct__opaque_pthread_attr_t_ptr::class, __darwin_pthread_attr_t_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr::class, __darwin_pthread_attr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr_ptr::class, __darwin_pthread_attr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_attr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t::class, __darwin_pthread_cond_t::class);
\class_alias(struct__opaque_pthread_cond_t_ptr::class, __darwin_pthread_cond_t_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr::class, __darwin_pthread_cond_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr_ptr::class, __darwin_pthread_cond_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_cond_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t::class, __darwin_pthread_condattr_t::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr::class, __darwin_pthread_condattr_t_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr::class, __darwin_pthread_condattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr_ptr::class, __darwin_pthread_condattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_condattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, __darwin_pthread_key_t_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, __darwin_pthread_key_t_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, __darwin_pthread_key_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, __darwin_pthread_key_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t::class, __darwin_pthread_mutex_t::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr::class, __darwin_pthread_mutex_t_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr::class, __darwin_pthread_mutex_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr_ptr::class, __darwin_pthread_mutex_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_mutex_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t::class, __darwin_pthread_mutexattr_t::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr::class, __darwin_pthread_mutexattr_t_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr::class, __darwin_pthread_mutexattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr::class, __darwin_pthread_mutexattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_mutexattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t::class, __darwin_pthread_once_t::class);
\class_alias(struct__opaque_pthread_once_t_ptr::class, __darwin_pthread_once_t_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr::class, __darwin_pthread_once_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr_ptr::class, __darwin_pthread_once_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_once_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t::class, __darwin_pthread_rwlock_t::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr::class, __darwin_pthread_rwlock_t_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr::class, __darwin_pthread_rwlock_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr::class, __darwin_pthread_rwlock_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_rwlock_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t::class, __darwin_pthread_rwlockattr_t::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr::class, __darwin_pthread_rwlockattr_t_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr::class, __darwin_pthread_rwlockattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr::class, __darwin_pthread_rwlockattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_rwlockattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr::class, __darwin_pthread_t::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr::class, __darwin_pthread_t_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr_ptr::class, __darwin_pthread_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr_ptr_ptr::class, __darwin_pthread_t_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr::class, u_int8_t_ptr::class);
\class_alias(unsigned_char_ptr_ptr::class, u_int8_t_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr::class, u_int8_t_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr_ptr::class, u_int8_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, u_int16_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, u_int16_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, u_int16_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, u_int16_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, u_int32_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, u_int32_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, u_int32_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, u_int32_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, u_int64_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, u_int64_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, u_int64_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, u_int64_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, register_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, register_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, register_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, register_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, uintptr_t_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, uintptr_t_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, uintptr_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, uintptr_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, user_addr_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, user_addr_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, user_addr_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, user_addr_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, user_size_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, user_size_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, user_size_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, user_size_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, user_ssize_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, user_ssize_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, user_ssize_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, user_ssize_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, user_long_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, user_long_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, user_long_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, user_long_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, user_ulong_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, user_ulong_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, user_ulong_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, user_ulong_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, user_time_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, user_time_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, user_time_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, user_time_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, user_off_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, user_off_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, user_off_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, user_off_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, syscall_arg_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, syscall_arg_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, syscall_arg_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, syscall_arg_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, intptr_t_ptr::class);
\class_alias(long_ptr_ptr::class, intptr_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, intptr_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, intptr_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_int_ptr::class, intmax_t_ptr::class);
\class_alias(long_int_ptr_ptr::class, intmax_t_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr::class, intmax_t_ptr_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr_ptr::class, intmax_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr::class, uintmax_t_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr::class, uintmax_t_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr::class, uintmax_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr_ptr::class, uintmax_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_nl_item_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_nl_item_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_nl_item_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_nl_item_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, __darwin_wctrans_t_ptr::class);
\class_alias(int_ptr_ptr::class, __darwin_wctrans_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, __darwin_wctrans_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, __darwin_wctrans_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, __darwin_wctype_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, __darwin_wctype_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, __darwin_wctype_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, __darwin_wctype_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_int_ptr::class, ptrdiff_t_ptr::class);
\class_alias(long_int_ptr_ptr::class, ptrdiff_t_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr::class, ptrdiff_t_ptr_ptr_ptr::class);
\class_alias(long_int_ptr_ptr_ptr_ptr::class, ptrdiff_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr::class, rsize_t_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr::class, rsize_t_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr::class, rsize_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_int_ptr_ptr_ptr_ptr::class, rsize_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, wchar_t_ptr::class);
\class_alias(int_ptr_ptr::class, wchar_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, wchar_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, wchar_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, wint_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, wint_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, wint_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, wint_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr::class, u_char_ptr::class);
\class_alias(unsigned_char_ptr_ptr::class, u_char_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr::class, u_char_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr_ptr::class, u_char_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, u_short_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, u_short_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, u_short_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, u_short_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, u_int_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, u_int_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, u_int_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, u_int_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, u_long_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, u_long_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, u_long_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, u_long_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, ushort_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, ushort_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, ushort_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, ushort_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, uint_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, uint_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, uint_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, uint_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, u_quad_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, u_quad_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, u_quad_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, u_quad_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, quad_t_ptr::class);
\class_alias(int64_t_ptr_ptr::class, quad_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, quad_t_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, quad_t_ptr_ptr_ptr_ptr::class);
\class_alias(int64_t_ptr::class, qaddr_t::class);
\class_alias(int64_t_ptr_ptr::class, qaddr_t_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr::class, qaddr_t_ptr_ptr::class);
\class_alias(int64_t_ptr_ptr_ptr_ptr::class, qaddr_t_ptr_ptr_ptr::class);
\class_alias(string_::class, caddr_t::class);
\class_alias(string_ptr::class, caddr_t_ptr::class);
\class_alias(string_ptr_ptr::class, caddr_t_ptr_ptr::class);
\class_alias(string_ptr_ptr_ptr::class, caddr_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, daddr_t_ptr::class);
\class_alias(int32_t_ptr_ptr::class, daddr_t_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, daddr_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, daddr_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, dev_t_ptr::class);
\class_alias(int_ptr_ptr::class, dev_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, dev_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, dev_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, fixpt_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, fixpt_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, fixpt_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, fixpt_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_long_ptr::class, blkcnt_t_ptr::class);
\class_alias(long_long_ptr_ptr::class, blkcnt_t_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr::class, blkcnt_t_ptr_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr_ptr::class, blkcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, blksize_t_ptr::class);
\class_alias(int_ptr_ptr::class, blksize_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, blksize_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, blksize_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, gid_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, gid_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, gid_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, gid_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, in_addr_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, in_addr_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, in_addr_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, in_addr_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, in_port_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, in_port_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, in_port_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, in_port_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, ino_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, ino_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, ino_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, ino_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr::class, ino64_t_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr::class, ino64_t_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr::class, ino64_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_long_ptr_ptr_ptr_ptr::class, ino64_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, key_t_ptr::class);
\class_alias(int_ptr_ptr::class, key_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, key_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, key_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, mode_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, mode_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, mode_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, mode_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr::class, nlink_t_ptr::class);
\class_alias(unsigned_short_ptr_ptr::class, nlink_t_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr::class, nlink_t_ptr_ptr_ptr::class);
\class_alias(unsigned_short_ptr_ptr_ptr_ptr::class, nlink_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, id_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, id_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, id_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, id_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, pid_t_ptr::class);
\class_alias(int_ptr_ptr::class, pid_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, pid_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, pid_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_long_ptr::class, off_t_ptr::class);
\class_alias(long_long_ptr_ptr::class, off_t_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr::class, off_t_ptr_ptr_ptr::class);
\class_alias(long_long_ptr_ptr_ptr_ptr::class, off_t_ptr_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, segsz_t_ptr::class);
\class_alias(int32_t_ptr_ptr::class, segsz_t_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, segsz_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, segsz_t_ptr_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr::class, swblk_t_ptr::class);
\class_alias(int32_t_ptr_ptr::class, swblk_t_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr::class, swblk_t_ptr_ptr_ptr::class);
\class_alias(int32_t_ptr_ptr_ptr_ptr::class, swblk_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, uid_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, uid_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, uid_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, uid_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, clock_t_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, clock_t_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, clock_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, clock_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, ssize_t_ptr::class);
\class_alias(long_ptr_ptr::class, ssize_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, ssize_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, ssize_t_ptr_ptr_ptr_ptr::class);
\class_alias(long_ptr::class, time_t_ptr::class);
\class_alias(long_ptr_ptr::class, time_t_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr::class, time_t_ptr_ptr_ptr::class);
\class_alias(long_ptr_ptr_ptr_ptr::class, time_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, useconds_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, useconds_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, useconds_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, useconds_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, suseconds_t_ptr::class);
\class_alias(int_ptr_ptr::class, suseconds_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, suseconds_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, suseconds_t_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, errno_t_ptr::class);
\class_alias(int_ptr_ptr::class, errno_t_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, errno_t_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, errno_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct_fd_set::class, fd_set::class);
\class_alias(struct_fd_set_ptr::class, fd_set_ptr::class);
\class_alias(struct_fd_set_ptr_ptr::class, fd_set_ptr_ptr::class);
\class_alias(struct_fd_set_ptr_ptr_ptr::class, fd_set_ptr_ptr_ptr::class);
\class_alias(struct_fd_set_ptr_ptr_ptr_ptr::class, fd_set_ptr_ptr_ptr_ptr::class);
\class_alias(int_ptr::class, fd_mask_ptr::class);
\class_alias(int_ptr_ptr::class, fd_mask_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr::class, fd_mask_ptr_ptr_ptr::class);
\class_alias(int_ptr_ptr_ptr_ptr::class, fd_mask_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t::class, pthread_attr_t::class);
\class_alias(struct__opaque_pthread_attr_t_ptr::class, pthread_attr_t_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr::class, pthread_attr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr_ptr::class, pthread_attr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr::class, pthread_attr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t::class, pthread_cond_t::class);
\class_alias(struct__opaque_pthread_cond_t_ptr::class, pthread_cond_t_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr::class, pthread_cond_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr_ptr::class, pthread_cond_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr::class, pthread_cond_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t::class, pthread_condattr_t::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr::class, pthread_condattr_t_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr::class, pthread_condattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr_ptr::class, pthread_condattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr::class, pthread_condattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t::class, pthread_mutex_t::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr::class, pthread_mutex_t_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr::class, pthread_mutex_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr_ptr::class, pthread_mutex_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr::class, pthread_mutex_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t::class, pthread_mutexattr_t::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr::class, pthread_mutexattr_t_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr::class, pthread_mutexattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr::class, pthread_mutexattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr::class, pthread_mutexattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t::class, pthread_once_t::class);
\class_alias(struct__opaque_pthread_once_t_ptr::class, pthread_once_t_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr::class, pthread_once_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr_ptr::class, pthread_once_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr::class, pthread_once_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t::class, pthread_rwlock_t::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr::class, pthread_rwlock_t_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr::class, pthread_rwlock_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr::class, pthread_rwlock_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr::class, pthread_rwlock_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t::class, pthread_rwlockattr_t::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr::class, pthread_rwlockattr_t_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr::class, pthread_rwlockattr_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr::class, pthread_rwlockattr_t_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr::class, pthread_rwlockattr_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr::class, pthread_t::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr::class, pthread_t_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr_ptr::class, pthread_t_ptr_ptr::class);
\class_alias(struct__opaque_pthread_t_ptr_ptr_ptr_ptr::class, pthread_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr::class, pthread_key_t_ptr::class);
\class_alias(unsigned_long_ptr_ptr::class, pthread_key_t_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr::class, pthread_key_t_ptr_ptr_ptr::class);
\class_alias(unsigned_long_ptr_ptr_ptr_ptr::class, pthread_key_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, fsblkcnt_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, fsblkcnt_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, fsblkcnt_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, fsblkcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, fsfilcnt_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, fsfilcnt_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, fsfilcnt_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, fsfilcnt_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr::class, sa_family_t_ptr::class);
\class_alias(unsigned_char_ptr_ptr::class, sa_family_t_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr::class, sa_family_t_ptr_ptr_ptr::class);
\class_alias(unsigned_char_ptr_ptr_ptr_ptr::class, sa_family_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, socklen_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, socklen_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, socklen_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, socklen_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, sae_associd_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, sae_associd_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, sae_associd_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, sae_associd_t_ptr_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr::class, sae_connid_t_ptr::class);
\class_alias(unsigned_int_ptr_ptr::class, sae_connid_t_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr::class, sae_connid_t_ptr_ptr_ptr::class);
\class_alias(unsigned_int_ptr_ptr_ptr_ptr::class, sae_connid_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct_sa_endpoints::class, sa_endpoints_t::class);
\class_alias(struct_sa_endpoints_ptr::class, sa_endpoints_t_ptr::class);
\class_alias(struct_sa_endpoints_ptr_ptr::class, sa_endpoints_t_ptr_ptr::class);
\class_alias(struct_sa_endpoints_ptr_ptr_ptr::class, sa_endpoints_t_ptr_ptr_ptr::class);
\class_alias(struct_sa_endpoints_ptr_ptr_ptr_ptr::class, sa_endpoints_t_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_config::class, quiche_config::class);
\class_alias(struct_quiche_config_ptr::class, quiche_config_ptr::class);
\class_alias(struct_quiche_config_ptr_ptr::class, quiche_config_ptr_ptr::class);
\class_alias(struct_quiche_config_ptr_ptr_ptr::class, quiche_config_ptr_ptr_ptr::class);
\class_alias(struct_quiche_config_ptr_ptr_ptr_ptr::class, quiche_config_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_conn::class, quiche_conn::class);
\class_alias(struct_quiche_conn_ptr::class, quiche_conn_ptr::class);
\class_alias(struct_quiche_conn_ptr_ptr::class, quiche_conn_ptr_ptr::class);
\class_alias(struct_quiche_conn_ptr_ptr_ptr::class, quiche_conn_ptr_ptr_ptr::class);
\class_alias(struct_quiche_conn_ptr_ptr_ptr_ptr::class, quiche_conn_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_stream_iter::class, quiche_stream_iter::class);
\class_alias(struct_quiche_stream_iter_ptr::class, quiche_stream_iter_ptr::class);
\class_alias(struct_quiche_stream_iter_ptr_ptr::class, quiche_stream_iter_ptr_ptr::class);
\class_alias(struct_quiche_stream_iter_ptr_ptr_ptr::class, quiche_stream_iter_ptr_ptr_ptr::class);
\class_alias(struct_quiche_stream_iter_ptr_ptr_ptr_ptr::class, quiche_stream_iter_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_connection_id_iter::class, quiche_connection_id_iter::class);
\class_alias(struct_quiche_connection_id_iter_ptr::class, quiche_connection_id_iter_ptr::class);
\class_alias(struct_quiche_connection_id_iter_ptr_ptr::class, quiche_connection_id_iter_ptr_ptr::class);
\class_alias(struct_quiche_connection_id_iter_ptr_ptr_ptr::class, quiche_connection_id_iter_ptr_ptr_ptr::class);
\class_alias(struct_quiche_connection_id_iter_ptr_ptr_ptr_ptr::class, quiche_connection_id_iter_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_path_event::class, quiche_path_event::class);
\class_alias(struct_quiche_path_event_ptr::class, quiche_path_event_ptr::class);
\class_alias(struct_quiche_path_event_ptr_ptr::class, quiche_path_event_ptr_ptr::class);
\class_alias(struct_quiche_path_event_ptr_ptr_ptr::class, quiche_path_event_ptr_ptr_ptr::class);
\class_alias(struct_quiche_path_event_ptr_ptr_ptr_ptr::class, quiche_path_event_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_socket_addr_iter::class, quiche_socket_addr_iter::class);
\class_alias(struct_quiche_socket_addr_iter_ptr::class, quiche_socket_addr_iter_ptr::class);
\class_alias(struct_quiche_socket_addr_iter_ptr_ptr::class, quiche_socket_addr_iter_ptr_ptr::class);
\class_alias(struct_quiche_socket_addr_iter_ptr_ptr_ptr::class, quiche_socket_addr_iter_ptr_ptr_ptr::class);
\class_alias(struct_quiche_socket_addr_iter_ptr_ptr_ptr_ptr::class, quiche_socket_addr_iter_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_config::class, quiche_h3_config::class);
\class_alias(struct_quiche_h3_config_ptr::class, quiche_h3_config_ptr::class);
\class_alias(struct_quiche_h3_config_ptr_ptr::class, quiche_h3_config_ptr_ptr::class);
\class_alias(struct_quiche_h3_config_ptr_ptr_ptr::class, quiche_h3_config_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_config_ptr_ptr_ptr_ptr::class, quiche_h3_config_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_conn::class, quiche_h3_conn::class);
\class_alias(struct_quiche_h3_conn_ptr::class, quiche_h3_conn_ptr::class);
\class_alias(struct_quiche_h3_conn_ptr_ptr::class, quiche_h3_conn_ptr_ptr::class);
\class_alias(struct_quiche_h3_conn_ptr_ptr_ptr::class, quiche_h3_conn_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_conn_ptr_ptr_ptr_ptr::class, quiche_h3_conn_ptr_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_event::class, quiche_h3_event::class);
\class_alias(struct_quiche_h3_event_ptr::class, quiche_h3_event_ptr::class);
\class_alias(struct_quiche_h3_event_ptr_ptr::class, quiche_h3_event_ptr_ptr::class);
\class_alias(struct_quiche_h3_event_ptr_ptr_ptr::class, quiche_h3_event_ptr_ptr_ptr::class);
\class_alias(struct_quiche_h3_event_ptr_ptr_ptr_ptr::class, quiche_h3_event_ptr_ptr_ptr_ptr::class);
\class_alias(struct_in6_addr::class, in6_addr_t::class);
\class_alias(struct_in6_addr_ptr::class, in6_addr_t_ptr::class);
\class_alias(struct_in6_addr_ptr_ptr::class, in6_addr_t_ptr_ptr::class);
\class_alias(struct_in6_addr_ptr_ptr_ptr::class, in6_addr_t_ptr_ptr_ptr::class);
\class_alias(struct_in6_addr_ptr_ptr_ptr_ptr::class, in6_addr_t_ptr_ptr_ptr_ptr::class);